<!DOCTYPE html>
<html lang="en">
<head>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9QJ5D3X353"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-9QJ5D3X353');
    </script>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../../globalStyles.css">
    <meta name="author" content="Raj Gaurav Ballabh Kumar">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hibernate - Notes</title>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">

    <div class="navbar-header">
        <a href="../../index.html" class="navbar-brand">rgbk21</a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"><span
            class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="nav navbar-nav">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Projects/TwitterCritNodes/TwitterCritNodes_1.html">Identifying
                        Critical Nodes on Twitter</a>
                    <a class="dropdown-item" href="../../Projects/isRelatedTo/isRelatedTo.html">isRelatedTo</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    HTML Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../WordleCheater/index.html">Wordle Cheater</a>
                    <a class="dropdown-item" href="../../Pig_Game/index.html">2-Player Pig Game</a>
                    <a class="dropdown-item" href="../../ImageGallery/ImageGallery.html">Image Gallery</a>
                    <a class="dropdown-item" href="../../RGB_Guesser_Game/RGB.html">RGB Guesser Game</a>
                    <a class="dropdown-item" href="../../ToDoList/todo.html">To-Do List</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Notes
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Lectures/COMS_631/COMS_631_index.html">COMS 631</a>
                    <a class="dropdown-item" href="../../Lectures/COMS_535/COMS_535_index.html">COMS 535</a>
                    <a class="dropdown-item" href="../../Lectures/EffectiveJava/EffectiveJava.html">Effective Java</a>
                    <a class="dropdown-item" href="../../Lectures/DI/DI.html">Dependency Injection</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Code
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Code/ThingsToRemember/ThingsToRemember.html">Things To Remember</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes.html">Java Notes</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes_2.html">Java Notes 2</a>
                    <a class="dropdown-item" href="../../Code/LeetCode/LeetCode.html">LeetCode Notes</a>
                    <a class="dropdown-item" href="../../Code/Applying_Java_Notes/ApplyingJava_Notes.html">ApplyingJava Notes</a>
                    <a class="dropdown-item" href="../../Code/JavaScript/JavaScript.html">JavaScript Notes</a>
                    <a class="dropdown-item" href="../../Code/HTML_CSS/HTML_CSS_Basics.html">HTML & CSS Notes</a>
                    <a class="dropdown-item" href="../../Code/SQL/SQL.html">SQL Notes</a>
                    <a class="dropdown-item" href="../../Code/Spring/Spring.html">Spring Notes</a>
                    <a class="dropdown-item" href="../../Code/Kafka/Kafka.html">Kafka Notes</a>
                    <a class="dropdown-item" href="../../Code/Angular/Angular.html">Angular</a>
                    <a class="dropdown-item" href="../../Code/Hibernate/Hibernate.html">Hibernate</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    In Another Life
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../InAnotherLife/Chapter1/Chapter1.html">Chapter 1</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
        </ul>


        <ul class="navbar-nav ml-auto">
            <li class="nav-item active"><a class="nav-link" href="https://github.com/rgbk21">GitHub</a></li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.linkedin.com/in/raj-gaurav-ballabh-kumar-97002058/">LinkedIn</a>
            </li>
            <li class="nav-item active"><a class="nav-link" href="https://www.instagram.com/wobblyframes/">Instagram</a>
            </li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.facebook.com/SomeRandomThoughts">Facebook</a></li>
        </ul>

    </div>
</nav>

<div class="container">

    <button id='load-all-gists' type="button" class="btn btn-outline-primary">Show all Gists!</button>

    <div>
        This page contains my notes from the following books: <br>
        a) Hibernate in Action <br>
        b) High-Performance Java Persistence <br>
        c) Beginning Java 8 APIs, Extensions and Libraries - Kishori Sharan
    </div>

    <br>

    Index:
    <br>
    Chapter 0: <a href="#GettingStarted">Getting Started - Dummy Project</a> <br>
    Chapter 6: <a href="#Java8_JDBC">JDBC API</a> (Kishori Sharan)<br>
    Chapter 1: <a href="#Ch1_Vlad">JDBC and DB Essentials: Performance and Scaling</a> (Vlad Mihalcea)<br>
    Chapter 4: <a href="#HIA_CH4">Mapping Persistent Classes</a>

    <hr>
    <div id="GettingStarted" class="chapter">Chapter 0: Getting Started - Dummy Project</div>
    <hr>

    <div class="textual-content">
        - Refer <a href="https://spring.io/guides/gs/accessing-data-mysql/">this Spring guide</a> for details. <br>
        - Hibernate User Guide can be found <a
            href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations-hbmddl">here</a>.
        <br>
        - Entire code can be found on GitHub <a href="https://github.com/rgbk21/MySQL-CRUD">here</a>. <br>
        - On <a href="https://start.spring.io/">Initializr</a> create a new Gradle project with the following
        dependencies: Spring Data JPA, MySQL Driver, Spring Web. <br>
        - Remove the <code>sourceCompatibility = '11'</code> from <code>build.gradle</code> file if giving build errors.
        <br>
        - Spring Boot gives you defaults on all things. For example, the default database is H2. Consequently, when you
        want to use any other database, you must define the connection attributes in the
        <code>application.properties</code> file. <br>
        - For this, we would first have to separately create a new database in MySQL. We are also creating a new table.
        Alternatively, you can just create the database and have Hibernate create the table for you. We will see how to
        do it.
        <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
                <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/0c9688b5f56b4a23216911b09ac54a8c.js"></script>
            </div>
        </div>

        - Optional, but you can add the database that you just created as a datasource to IntelliJ itself so that you
        can run SQL queries from the IDE and not have to go to WorkBench everytime. <br>

        <br>
        Step 1: Select the Database tab on the right and add a datasource by clicking the plus symbol.

        <img src="imgs/Ch0/AddingDataSource.PNG"
             class="center-block img-fluid"
             alt="AddingDataSource"
             width="300">

        <br>
        Step 2: Add User, Password, Database. For your user/password combination of database, go to your MySQL
        WorkBench. Go to home, there you will see the MySQL connections. One of the existing connections is your
        user/password combination for this that you will enter in your IDE.
        Click on Test Connection. If everything was set-up correctly, you should
        see a similar message as below. Note the URL, we will be making use of it.

        <div class="row">
            <img src="imgs/Ch0/AddingDrivers.PNG"
                 class="center-block img-fluid"
                 alt="AddingDrivers"
            width="500">
        </div>

        <br>
        Step 3: Now you can run SQL commands directly in the IDE and see the output in the window below.
        <img src="imgs/Ch0/AfterAdding.PNG" class="center-block img-fluid"
             alt="AfterAdding">

        <br>
        - Moving on, we now need to add the following to the <code>application.properties</code> file

        <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
                <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/7723f262e9214ddb74526e9706b3bb5c.js"></script>
            </div>
        </div>

        Note the <code>spring.jpa.hibernate.ddl-auto=none</code> property above. <br>
        a) <code>none</code>: The default for MySQL. No change is made to the database structure. <br>
        b) <code>update</code>: Hibernate changes the database according to the given entity structures. <br>
        c) <code>create</code>: Creates the database every time but does not drop it on close. <br>
        d) <code>create-drop</code>: Creates the database and drops it when <code>SessionFactory</code> closes. <br>
        You must begin with either <code>create</code> or <code>update</code>, because you do not yet have the database
        structure. After the first run, you can switch it to <code>update</code> or <code>none</code>, according to
        program requirements. Use <code>update</code> when you want to make some change to the database structure.
        The default for H2 and other embedded databases is <code>create-drop</code>. For other databases, such as MySQL,
        the default is <code>none</code>. Since we have already created the table, we leave this as <code>none</code>.
        <br>
        - Next we create the Entity model. <br>
        - Note how we are generating the Primary Key. It's different from the way described in the docs. <code>GenerationType.SEQUENCE</code>
        is the preferred way of generating IDs in Hibernate. But MySQL does
        not support sequences. Hence we are doing it this way.
        <a href="https://stackoverflow.com/a/58749481/8742428">This SO Link </a> goes into why we are using it this
        way. Also this <a href="https://thorben-janssen.com/5-things-you-need-to-know-when-using-hibernate-with-mysql/">
        Thorben </a> link explains in more details why we are using the native generator instead.

        <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
                <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/ad962c0e5d0bdafab3ba556aac1bfd98.js"></script>
            </div>
        </div>

        - Next we create the <code>StudentRepository</code>
        <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
                <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/ab593c70880ddc54d5f32fa14e0022a4.js"></script>
            </div>
        </div>
        - Lastly we need to create a Controller to handle HTTP requests to our application.

        <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
                <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/245fa30a1b3805913019d05acc6a1cf0.js"></script>
            </div>
        </div>

        <br>
        <br>
        <li><b>What is REST</b></li>
        <div>
            - <a href="https://www.springboottutorial.com/spring-boot-crud-rest-service-with-jpa-hibernate">Source</a>
            to in 28 mins from where the text is taken <br>
            - <a href="https://spring.io/guides/tutorials/rest/">Source to Spring REST Tutorial Doc</a> that contains
            the code for creating a REST-ful API <br>
            - First of all, REST does not define a standard message exchange format. You can build REST services with
            both XML and JSON. However, JSON is a more popular format with REST. So, if it does not define a standard
            message exchange format, what is REST then? REST stands for REpresentational State Transfer. Key abstraction
            in REST is a Resource. There is no restriction on what can be a resource. A todo is a resource. A person on
            facebook is a resource. <br>
            - A resource has an URI (Uniform Resource Identifier): <br>
            /user/Ranga/todos/1 <br>
            /person/Ranga <br>
            - A resource will have representations: XML, HTML, JSON. <br>
            - A resource will have state. The representation of a resource should capture its current state. When a
            resource is requested, we provide the representation of the resource.
        </div>

        <br>
        <li><b>REST and HTTP</b></li>
        <div>
            - REST builds on top of HTTP (Hypertext Transfer Protocol). HTTP is the language of the web.
            - HTTP has a few important verbs: <br>
            <ul>
                <li><code>POST</code> - Create a new resource</li>
                <li><code>GET</code> - Read a resource</li>
                <li><code>PUT</code> - Update an existing resource</li>
                <li><code>DELETE</code> - Delete a resource</li>
            </ul>

            - HTTP also defines some standard response codes: <br>
            <ul>
                <li>200 - SUCESS</li>
                <li>404 - RESOURCE NOT FOUND</li>
                <li>400 - BAD REQUEST</li>
                <li>201 - CREATED</li>
                <li>401 - UNAUTHORIZED</li>
                <li>415 - UNSUPPORTED TYPE - Representation not supported for the resource</li>
                <li>500 - SERVER ERROR</li>
            </ul>

        </div>

        <br>
        <li><b>Restful Service Constraints</b></li>
        <div>
            a) Client - Server : There should be a service producer and a service consumer. <br>
            b) The interface (URL) is uniform and exposing resources. Interface uses nouns (not actions) <br>
            c) The service is stateless. Even if the service is called 10 times, the result must be the same. <br>
            d) The service result should be Cacheable. HTTP cache, for example. <br>
            e) Service should assume a Layered architecture. Client should not assume direct connection to server - it
            might be getting info from a middle layer - cache.
        </div>

        <br>
        <li><b>Designing RESTful APIs</b></li>
        <div>
            - Following are the important things to consider when designing RESTful API's: <br>
            a) In Rest, we think Nouns (resources) and NOT Verbs (NOT actions). So, URI's should represent resources.
            URI's should be hierarchical and as self descriptive as possible. Prefer plurals. <br>
            b) Always use HTTP Methods. <br>
            c) <code>GET</code> : Should not update anything. Should be idempotent (same result in multiple calls).
            Possible Return Codes 200 (OK) + 404 (NOT FOUND) + 400 (BAD REQUEST) <br>
            d) <code>POST</code> : Should create new resource. Ideally return JSON with link to newly created resource.
            Same return codes as get possible. In addition : Return code 201 (CREATED) is possible. <br>
            e) <code>PUT</code> : Update a known resource. ex: update client details. Possible Return Codes : 200(OK)
            <br>
            f) <code>DELETE</code> : Used to delete a resource. <br>
        </div>


        <br>
        <li><b>What is <code>ResponseEntity</code> and what is it used for</b></li>
        <div>
            -
        </div>
    </div>

    <hr>
    <div id="Java8_JDBC" class="chapter">Chapter 4: JDBC API</div>
    <hr>

    <div class="textual-content">

        - <a href="https://docs.oracle.com/cd/B28359_01/java.111/b31224/preface.htm">Oracle JDBC Reference link</a> <br>
        - <a href="https://balusc.omnifaces.org/2008/07/dao-tutorial-data-layer.html">Check this Balus C link as
        well</a>
        <br>
        -

        <div class="sub-heading">What is the JDBC API?</div>
        <div>
            - The JDBC API provides a standard database-independent interface to interact with any tabular data
            source. Goal is to interact with databases using a Java program where the Java program does not need to know
            what kind of database is installed/the program has to talk to. <br>
            - Using the JDBC API to access data in a database hides the implementation differences that exist in
            different types of databases. It achieves database transparency by defining most of its API using interfaces
            and letting the database vendors (or any third-party vendors) provide the implementations for those
            interfaces. The collection of the implementation classes that is supplied by a vendor to interact with a
            specific database is called a <i>JDBC Driver</i> <br>
            - Some JDBC drivers are written in pure Java. For purely Java-implemented JDBC drivers, you just need to
            include the vendor-supplied classes in your application CLASSPATH. Some JDBC drivers need a proprietary
            software installation on the client machine to interact with a database. <br>
            - There are different kinds of JDBC Drivers:

            <img src="imgs/Java8_JDBC_Imgs/JDBCDrivers.PNG" class="center-block img-fluid"
                 alt="JDBCDrivers"
                 width="400">

            - We are going to only use JDBC Drivers. The JDBC driver is also known as a direct-to-database pure Java
            driver. It is written in pure Java. It converts the JDBC calls into DBMS-specific calls and sends the calls
            directly to the database. It is the best suitable driver type to be used in apps. All you need to do is
            to include the driver JAR/ZIP files with your application. All major DBMS vendors supply this type
            of JDBC driver.
        </div>


        <div class="sub-heading">Connecting to a DB</div>
        <div>
            - Dummy project for setting up project is present <a href="https://github.com/rgbk21/JDBC_Setup">here on my
            GitHub</a>. <br>
            - Once you have obtained the JDBC Driver from the Oracle/Maven repository, you need to register the JDBC
            Driver with your application. A JDBC Driver is a class that implements the <code>java.sql.Driver</code>
            interface. DBMS vendors supply the JDBC driver class along with any other classes it uses. <br>
            - You need to register this JDBC Driver with the <code>java.sql.DriverManager</code> class. (Refer pg 396 of
            book if confused). You can register multiple JDBC Drivers with the DriverManager. <br>
            - When you need to establish a connection to a database, you must pass a connection URL to the <code>DriverManager</code>.
            The <code>DriverManager</code> passes the
            connection URL to all registered drivers one by one, and asks them to connect to the database using
            information
            that you supply in the connection URL. If a driver recognizes the connection URL, it connects to the
            database and
            returns the connection to the <code>DriverManager</code>. An object of the <code>java.sql.Connection</code>
            interface represents a database
            connection in a Java program. If none of the registered drivers recognize a connection URL, the <code>DriverManager</code>
            will
            throw a <code>SQLException</code> stating that it could not find a suitable driver <br>
            - There are 3 ways to register a JDBC Driver with the <code>DriverManger</code> class: <br>
            a) By setting the <code>jdbc.drivers</code> system property <br>
            b) By loading the driver class into the JVM <br>
            c) By using the <code>registerDriver()</code> method of the DriverManager class <br>

        </div>


        <div class="sub-heading">Constructing a Connection URL</div>
        <div>
            - A database connection is established using a connection URL. The format of a connection URL is dependent
            upon the DBMS and a JDBC driver. <br>
            - The syntax to define the Connection URL is:
            <code>&lt;protocol&gt;:&lt;sub-protocol&gt;:&lt;data-source-details&gt;</code>, The
            <code>&lt;protocol&gt</code> part is always set to jdbc. The <code>&lt;sub-protocol&gt;</code> part is
            vendor-specific. The <code>&lt;data-source-details&gt;</code> part is DBMS specific that is used to locate
            the database.
            In some cases, you can also specify some connection properties in this last part of the URL. <br>
            - For OracleDB it is: <code>jdbc:oracle:thin:hr/hr@//localhost:1521/orclpdb</code>. The protocol part is
            jdbc. The sub-protocol part is oracle:thin, which identifies the Oracle Corporation as the vendor, and the
            type of the driver it will use, which is thin. The data source details part is @localhost:1521/orclpdb. It
            has three subparts. The @localhost identifies the server name. You could use an IP address or a machine name
            of your Oracle database server instead. Then, it contains the port number at which Oracle's Transport
            Network Substrate (TNS) listener is running. The last part is an Oracle's instance name, which is
            orclpdb in this example. Note that the above example uses a Service Name to connect to the DB instead of a
            SID. Hence the Connection URL is formatted differently. Refer
            <a href="https://stackoverflow.com/questions/4832056/java-jdbc-how-to-connect-to-oracle-using-service-name-instead-of-sid">this
                SO Link </a>
            to read what is different and how it is formatted.
        </div>


        <div class="sub-heading">Establishing the DB Connection</div>
        <div>
            - You need to use the <code>getConnection()</code> static method of the <code>DriverManager</code> class
            to establish a connection to a database. It returns an object of the <code>java.sql.Connection</code>
            interface, which represents the database connection. The <code>getConnection()</code> method takes a
            connection URL, a user id, a password, and any number of name-value pairs using a
            <code>java.util.Properties</code> object. The <code>getConnection()</code> method is overloaded. <br>
            - The Connection interface inherits from the <code>java.lang.AutoCloseable</code> interface. That means you
            can also use a try-with-resources block to obtain a <code>Connection</code> that will be automatically
            closed when the control exits the try block. <br>
            - When you are done with a database connection, you need to close it by using the <code>close()</code>
            method of the <code>Connection</code> object.
            <br>
            - View the entire code <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/JDBCUtil.java">here</a>.

            <div class="code-block">
                <div class="expand-code-snip-btn border border-primary rounded">
                    <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
                </div>
                <div class="code-snippet">
                    <script src="https://gist.github.com/rgbk21/9f360ec68860a1352c1f175cb3b95a05.js"></script>
                </div>
            </div>
        </div>


        <div class="sub-heading">Setting the Auto-Commit Mode</div>
        <div>
            - When you connect to a database, the auto-commit property for the <code>Connection()</code> object is set
            to true by default. If a connection is in an auto-commit mode, a SQL statement is committed automatically
            after its successful execution. If a connection is not in an auto-commit mode, you must call the <code>commit()</code>
            or <code>rollback()</code> method of the <code>Connection()</code> object to commit or rollback a
            transaction. Typically, you disable the auto-commit mode for a connection in a JDBC application, so your
            application logic controls the final outcome of the transaction. To disable the auto-commit mode,
            you need to call the <code>setAutoCommit(false)</code> on the <code>Connection()</code> object after
            connection has been established (like we have done above). <br>
            - If you have enabled the auto-commit mode for your connection, you cannot use its <code>commit()</code> and
            <code>rollback()</code> methods. Calling the <code>commit()</code> and <code>rollback()</code> methods on a
            <code>Connection</code> object, which has enabled the auto-commit mode, throws an exception. JDBC also lets
            you use save points in a transaction, so that you can apply a partial rollback to a transaction. <br>
        </div>


        <div class="sub-heading">Transaction Isolation Level</div>
        <div>
            - In a multi-user database, you will often come across the following two terms: <br>
            a) Data concurrency: Data concurrency refers to the ability of multiple users to use the same data
            concurrently. <br>
            b) Data consistency: Data consistency refers to the accuracy of the data that is maintained when multiple
            users are manipulating the data concurrently. <br>
            - As the data concurrency increases (i.e. more users work on the same data), care must be taken to maintain
            a desired level of data consistency. A database maintains data consistency using locks and by isolating one
            transaction from another. How much a transaction is isolated from another transaction depends on the desired
            level of data consistency. <br>
            - There are three phenomena where data consistency may be compromised in a multi-user environment where
            multiple concurrent transactions are supported: <br><br>

            a) <b>Dirty Read</b>: In a dirty read, a transaction reads uncommitted data from another transaction.
            Consider the
            following sequence of steps, which results in inconsistent data because of a dirty read:
            <li>Transaction A inserts a new row in a table and it has not committed it yet.</li>
            <li>Transaction B reads the uncommitted row inserted by the transaction A.</li>
            <li>Transaction A rollbacks the changes.</li>
            <li>At this point, transaction B is left with data for a row that does not exist.</li>

            <br>

            b) <b>Non-Repeatable Read</b>: In a non-repeatable read, when a transaction re-reads the data, it finds that
            the
            data has been modified by another transaction that has been already committed. Consider the following
            sequence of steps, which results in inconsistent data because of a non-repeatable read:
            <li>Transaction A reads a row.</li>
            <li>Transaction B modifies or deletes the same row and commits the changes.</li>
            <li>Transaction A re-reads the same row and finds that the row has been modified or deleted.</li>

            <br>

            c) <b>Phantom Read</b>: In a phantom read, when a transaction re-executes the same query, it finds more data
            that
            satisfies the query. Consider the following sequence of steps, which results in inconsistent data, because
            of a phantom read:
            <li>Transaction A executes a query (say Q) and finds X number of rows matching the query</li>
            <li>Transaction B inserts some rows that satisfy the query Q criteria and commits.</li>
            <li>Transaction A re-executes the same query (Q) and finds Y number of rows (Y > X) matching the query.</li>

            <br>

            - <a
                href="https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read">SO
            Link </a> explaining the difference between Non-Repeatable Read and Phantom Read. (Basically: A
            non-repeatable read occurs, when during the course of a transaction, a row is retrieved twice and the values
            within the row differ between reads. A phantom read occurs when, in the course of a transaction, two
            identical queries are executed, and the collection of rows returned by the second query is different from
            the first. So, while the Non-Repeatable Read applies to a single row, the Phantom Read is about a range of
            records which satisfy a given query filtering criteria.) <br>
            - The ANSI SQL-92 standard defines four transaction isolation levels in terms of the above-described three
            situations for data consistency. Each isolation level defines what kinds of data inconsistencies are
            allowed, or not allowed. The four transaction isolation levels and their correspondiYou can check the
            updated value by runningng constants in Java are
            as follows:
            <li>Read Uncommitted (<code>TRANSACTION_READ_UNCOMMITTED</code>)</li>
            <li>Read Committed (<code>TRANSACTION_READ_COMMITTED</code>)</li>
            <li>Repeatable Read (<code>TRANSACTION_REPEATABLE_READ</code>)</li>
            <li>Serializable (<code>TRANSACTION_SERIALIZABLE</code>)</li>

            <br>

            - The below table shows the four isolation levels and the three permitted situations. It is up to a DBMS to
            decide how they implement these isolation levels.

            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Isolation Level</th>
                    <th>Dirty Read</th>
                    <th>Non-Repeatable Read</th>
                    <th>Phantom Read</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Read Uncommitted</td>
                    <td>Permitted</td>
                    <td>Permitted</td>
                    <td>Permitted</td>
                </tr>
                <tr>
                    <td>Read Committed</td>
                    <td>Not Permitted</td>
                    <td>Permitted</td>
                    <td>Permitted</td>
                </tr>
                <tr>
                    <td>Repeatable Read</td>
                    <td>Not Permitted</td>
                    <td>Not Permitted</td>
                    <td>Permitted</td>
                </tr>
                <tr>
                    <td>Serializable</td>
                    <td>Not Permitted</td>
                    <td>Not Permitted</td>
                    <td>Not Permitted</td>
                </tr>
                </tbody>
            </table>

            - Even if the SQL standard mandates the use of the <code>TRANSACTION_SERIALIZABLE</code> isolation level,
            most database management systems use a different default level. Oracle, for example, has a default isolation
            level of <code>TRANSACTION_READ_COMMITTED</code> <a
                href="https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions/">(Source)</a>. <br>
            - <a href="https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions/">This link</a> from
            Vlad's blog explains the isolation levels. <a
                href="https://stackoverflow.com/questions/4034976/difference-between-read-commited-and-repeatable-read">This
            SO Link</a> explains the difference between <code>TRANSACTION_READ_COMMITTED</code> and <code>TRANSACTION_REPEATABLE_READ</code>.
        </div>


        <div class="sub-heading">JDBC-Types-to-Java-Types Mapping</div>
        <div>
            - The JDBC API allows you to access and manipulate data stored in a database in a Java environment. The
            database uses its own data types, whereas Java uses its own. We use three sets of methods while
            working with data in JDBC programs: getXxx(), setXxx(), and updateXxx(), where Xxx indicates a data type
            such as int, String, Date, etc. These methods are found in many interfaces such as PreparedStatement,
            ResultSet. <br>
            - A getXxx() method is used to read data from a JDBC environment to a Java program. A setXxx() method is
            used to set a value in a Java program that will finally be passed to a JDBC environment. An updateXxx()
            method is used to update a data element that was retrieved from a JDBC environment and the updated value
            will be passed again to a JDBC environment. <br>
        </div>


        <div class="sub-heading">Executing SQL Statements</div>
        <div>
            - Based on the type of work that a SQL statement performs in a DBMS, it can be categorized as follows: <br>
            a) Data Definition Language (DDL) Statement: Examples are <code>CREATE TABLE</code>,
            <code>ALTER TABLE</code>. <br>
            b) Data Manipulation Language (DML) Statement: <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>,
            <code>DELETE</code> <br>
            c) Data Control Language (DCL) Statement: <code>GRANT</code>, <code>REVOKE</code> <br>
            d) Transaction Control Language (TCL) Statement: <code>COMMIT</code>, <code>ROLLBACK</code>,
            <code>SAVEPOINT</code> <br>

            <br>
            - An instance of the <code>STATEMENT</code> interface represents a SQL Statement in a Java program. Java
            uses three different interfaces to represent SQL statements in different formats: <br>
            a) <code><b>Statement</b></code>: If you have a SQL statement in the form of a string, you can use a
            <code>Statement</code> object to execute it. The SQL statement may or may not return a result set.
            Typically, a <code>SELECT</code> statement returns a result set with zero or more records. The SQL
            statements in the string format are compiled each time they are executed. <br>
            b) <code><b>PreparedStatement</b></code>: You can use a <code>PreparedStatement</code>, if you want to
            precompile a
            SQL statement once and execute it multiple times. It lets you specify a SQL statement in the form of a
            string that uses placeholders. You need to supply the values of the placeholders before you execute the
            statement. Using a <code>PreparedStatement</code> object is preferred over using a <code>Statement</code>
            object. Refer page 414 of book for the reasons why.<br>
            c) <code><b>CallableStatement</b></code>: You can use a <code>CallableStatement</code> object to execute a
            database-stored procedure or function in a database. The stored procedure may return result sets. <br>
            - The <code>PreparedStatement</code> inherits from the <code>Statement</code> interface and the <code>CallableStatement</code>
            inherits from the <code>PreparedStatement</code>
        </div>


        <div class="sub-heading">Results of executing an SQL Statement</div>
        <div>
            - When you execute a SQL statement, the DBMS may return zero or more results. The results may include update
            counts (number of records affected in the database) or result sets (a group of records). <br>
            - When you execute a SELECT statement, it returns a result set. When you execute an UPDATE or DELETE
            statement, it returns an update count, which is the number of records affected in the database by the SQL.
            When you execute a stored procedure, it may return multiple update counts as well as multiple result sets. A
            JDBC driver will let you get to the results in the order they were returned from the database.
            <br>
        </div>


        <div class="sub-heading">Using the Statement interface</div>
        <div>
            - You can use a <code>Statement</code> to execute any kind of SQL statement. You use one of its three
            methods called <code>execute()</code>, <code>executeUpdate()</code>, and <code>executeQuery()</code> to
            execute a SQL statement. <br>
            - The <code><b>execute()</b></code> method in the Statement interface is a general-purpose method that you
            can use
            to execute any types of SQL statements. Typically, it is used to execute a SQL statement that does not
            return a result set, such as a DDL statement like <code>CREATE TABLE</code>. The returned value from the
            <code>execute()</code> method indicates the status of the returned result set. If the first result is a
            <code>ResultSet</code> object, it returns true. It returns false if the first result is an update count or
            no result is returned from the DBMS. <br>
            - The <code><b>executeUpdate()</b></code> method is used to execute a SQL statement that updates the data in
            the
            database such as <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements. It returns the
            number of rows affected in the database by the execution of the statement. You may use this method to
            execute other kinds of SQL statements, such as a <code>CREATE TABLE</code> statement which do not return
            anything. The method returns zero when the SQL statement does not return anything.
            You should NOT use this method to execute a <code>SELECT</code> statement. Java 8 has added a <code>executeLargeUpdate()</code>
            method that works the same as the <code>executeUpdate()</code> method, except that it returns a long instead
            of an int. Use this method when you expect the update count to exceed <code>Integer.MAX_VALUE</code>.<br>
            - The <code><b>executeQuery()</b></code> method is especially designed to execute a SQL statement that
            produces one
            and only one result set. It is best suited for executing a <code>SELECT</code> statement. Although you can
            execute a stored procedure (which produces a result set) using this method of the <code>Statement</code>
            interface, you should instead use the specially designed <code>CallableStatement</code> interface's
            <code>execute()</code> method to execute a stored procedure.
        </div>


        <div class="sub-heading">Steps to execute a SQL Statement using a Statement object</div>
        <div>
            - <a href="https://github.com/rgbk21/JDBC_Setup/tree/master/src/main/java/com/example/demo/Statement">Github
            repo for the code</a> using <code>Statement</code> interface. <br>
            1) Get a <code>Connection</code> object: <br>
            <code>Connection conn = JDBCUtil.getConnection();</code> <br>

            2) Create a <code>Statement</code> object using the <code>createStatement()</code> method of the <code>Connection</code>
            object. <br>
            <code>Statement stmt = conn.createStatement();</code> <br>

            3) Execute one or more SQL statements by calling one of the three methods of the <code>Statement</code>
            object. <br>
            <code>// Increase everyone's income by 10%</code> <br>
            <code>String sql = "update person set income = income * 1.1";</code> <br>
            <code>int rowsUpdated = stmt.executeUpdate(sql);</code> <br>
            <code>// Execute other SQL statements using stmt</code> <br>

            4) Close the <code>Statement</code> object to release the resources. <br>
            <code>stmt.close();</code> <br>

            5) Commit the transaction. <br>
            <code>conn.commit()</code> <br>
        </div>


        <div class="sub-heading">Using the PreparedStatement Interface</div>
        <div>
            - The <code>PreparedStatement</code> interface inherits from the <code>Statement</code> interface. It is
            preferred over the <code>Statement</code> interface to execute a SQL statement. It precompiles the SQL
            statement. It reuses the precompiled SQL statement if the statement is executed multiple times. It lets you
            prepare a SQL statement, which is in a string format, using placeholders for input parameters. <br>
            - A question mark in a SQL string is a placeholder for an input parameter whose value will be supplied
            before the statement is executed. Each placeholder has an index. The first placeholder in a SQL string is
            given an index of 1, the second placeholder an index of 2, and so on. Note that the index of the placeholder
            starts at 1, not 0. <br>
        </div>


        <div class="sub-heading">Steps to execute a SQL Statement using a PreparedStatement object</div>
        <div>
            - <a
                href="https://github.com/rgbk21/JDBC_Setup/tree/master/src/main/java/com/example/demo/PreparedStatement">Github
            repo</a> for the code using <code>PreparedStatement</code> interface. <br>

            0) Create a SQL statement: <br>
            <code>String sqlQuery = "INSERT INTO person " +</code> <br>
            <code> "(person_id, first_name, last_name, gender, dob, income) " +</code> <br>
            <code> "VALUES " +</code> <br>
            <code> "(?, ?, ?, ?, ?, ?)";</code> <br>

            1) Get a <code>Connection</code> object: <br>
            <code>Connection conn = JDBCUtil.getConnection();</code> <br>

            2) Obtain a PreparedStatement for the sql. <br>
            <code>PreparedStatement pStmnt = conn.prepareStatement(sqlQuery);</code> <br>

            3) Set the values for the placeholders <br>
            <code>pStmnt.setInt(1, 3);</code> <br>
            <code>pStmnt.setString(2, "Charlie");</code> <br>
            <code>pStmnt.setString(3, "Doe");</code> <br>
            <code>pStmnt.setString(4, "M");</code> <br>
            <code>java.sql.Date dob = java.sql.Date.valueOf("1990-01-03");</code> <br>
            <code>pStmnt.setDate(5, dob);</code> <br>
            <code>pStmnt.setDouble(6, 50000);</code> <br>

            4) Now it is time to send the SQL statement with the values for the placeholders to the database. You
            execute a SQL statement in a <code>PreparedStatement</code> using one of its <code>execute()</code>, <code>executeUpdate()</code>,
            and <code>executeQuery()</code> methods. These methods take no arguments. Recall that the
            <code>Statement</code> interface has the same methods, which take SQL strings as their arguments. The <code>PreparedStatement</code>
            interface has added three methods with the same name, which take no arguments, because it gets its SQL
            string when it is created. <br>

            //Execute the INSERT statement in pStmnt <br>
            <code>pstmt.executeUpdate();</code> <br>

            5) Close the <code>PreparedStatement</code> object to release the resources. <br>
            <code>pstmt.close();</code> <br>

            6) Commit the transaction. <br>
            <code>conn.commit()</code> <br>
        </div>


        <div class="sub-heading">How do you reuse a PreparedStatement?</div>
        <div>
            - Repopulate the placeholder values and call one of its <code>execute()</code> methods again. When you
            invoke the setXxx() method on a <code>PreparedStatement</code> object again, its previously set value
            for the specified placeholder is overwritten with the new value. A <code>PreparedStatement</code> keeps
            holding the set values for its placeholder even after it is executed. Therefore, if you want to set the same
            value for a placeholder for multiple executions, you need to set the value for that placeholder only once.
            <br>
            - If you want to clear the values of all placeholders, you can use the <code>clearParameters()</code> method
            of the <code>PreparedStatement</code> interface.
        </div>

        <div class="sub-heading">CallableStatement interface</div>
        <div>
            - TODO
        </div>


        <div class="sub-heading">What is a <code>ResultSet</code></div>
        <div>
            - When you execute a query (a <code>SELECT</code> statement) in a database, it returns the matching records
            in the form of a result set. You can consider a result set as a data arranged in rows and columns. The
            returned data obviously depends upon the <code>SELECT</code> statement that you send to the DB. <br>
            - The <code>Statement</code> (or <code>PreparedStatement</code> or <code>CallableStatement</code>) object
            returns the result of a query as a <code>ResultSet</code> object. The "Result Set" is an instance of a class
            that implements the <code>ResultSet</code> interface that lets you access and manipulate the returned data.
            A <code>ResultSet</code> object also contains information about the properties of the columns in the result
            set such as the data types of the columns, names of the columns, etc. <br>
            - A <code>ResultSet</code> object maintains a <i>cursor</i>, which points to a row in the result set. The
            cursor can point to only one row at a time. The row to which it points at a particular point in time is
            called the <i>current row</i>.
        </div>

        <div class="sub-heading">Properties of a <code>ResultSet</code></div>
        <div>
            <li><b>Scrollability</b>: Scrollability determines the ability of the ResultSet to scroll through the rows.
                By default, a <code>ResultSet</code> is scrollable only in the forward direction. When you have a
                forward-only scrollable <code>ResultSet</code>, you can move the cursor starting from the first row to
                the last row. Once you move to the last row, you cannot reuse the <code>ResultSet</code> object
                because you cannot scroll back in a forward-only scrollable <code>ResultSet</code>. <br>
                - You can also create
                a <code>ResultSet</code> that can scroll in the forward as well as the backward direction.
                This <code>ResultSet</code> is called a <i>bidirectional scrollable</i> <code>ResultSet</code>.
                A bidirectional scrollable <code>ResultSet</code> has another property called <i>update sensitivity</i>.
                It determines whether the changes in the underlying database will be reflected in the result set while
                you are scrolling through its rows. A scroll sensitive <code>ResultSet</code> shows you changes made in
                the database, whereas a scroll insensitive one would not show you the changes made in the database after
                you have opened the <code>ResultSet</code>. <br>

                - The following three constants in the ResultSet interface are used to specify the scrollability of a
                ResultSet: <br>
                a) <code>TYPE_FORWARD_ONLY</code>: Allows a <code>ResultSet</code> object to move only in the forward
                direction. <br>
                b) <code>TYPE_SCROLL_SENSITIVE</code>: Allows a <code>ResultSet</code> object to move in the forward and
                backward directions. It makes the changes in the underlying database made by other transactions or
                statements in the same transaction visible to the <code>ResultSet</code> object. This type of <code>ResultSet</code>
                is aware of the changes made to its data by other means. <br>
                c) <code>TYPE_SCROLL_INSENSITIVE</code>: Allows a <code>ResultSet</code> object to move in the forward
                and backward directions. It DOES NOT make the changes in the underlying database made by other
                transactions or statements in the same transaction visible to the <code>ResultSet</code> object while
                scrolling. This type of <code>ResultSet</code> determines its data set when it is open and the data set
                does not change if it is updated through any other means EXCEPT through this <code>ResultSet</code>
                object itself. If you want to get up-to-date data, you must re-execute the query.
            </li>
            <br>
            <li><b>Concurrency</b>: Concurrency refers to its ability of the <code>ResultSet</code> to update data. By
                default, a <code>ResultSet</code> is read-only and it does not let you update its data. If you want to
                update data in a database through a <code>ResultSet</code>, you need to request an updatable result set
                from the JDBC driver. <br>
                - The following two constants in the ResultSet interface are used to specify the concurrency of a
                ResultSet: <br>
                a) <code>CONCUR_READ_ONLY</code>: Makes a result set read-only. <br>
                b) <code>CONCUR_UPDATABLE</code>: Makes a result set updatable.
            </li>
            <br>
            <li><b>Holdability</b>: Holdability refers to the state of the <code>ResultSet</code> after a transaction
                that it is associated with has been committed.
                A <code>ResultSet</code> may be closed or kept open when the transaction is committed. The default value
                of the holdability of a <code>ResultSet</code> is dependent on the JDBC driver. <br>
                - The holdability of a <code>ResultSet</code> is specified using one of the following two constants
                defined in the <code>ResultSet</code> interface: <br>
                a) <code>HOLD_CURSORS_OVER_COMMIT</code>: Keeps the <code>ResultSet</code> open after the transaction is
                committed. <br>
                b) <code>CLOSE_CURSORS_AT_COMMIT</code>: Closes the <code>ResultSet</code> after the transaction is
                committed.
            </li>

            <br>

            - For an OracleDB, you can check these values by running <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/SupportedResultSetProperties.java">this
            code</a>. The own****AreVisible shows whether inserts/updates/deletes using the same ResultSet are visible
            within that ResultSet itself. Read more at <a href="https://stackoverflow.com/a/16959086/8742428">this SO
            Link</a>.
            <div class="code-block">
                <div class="expand-code-snip-btn border border-primary rounded">
                    <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
                </div>
                <div class="code-snippet">
                    <script src="https://gist.github.com/rgbk21/b548900f48ce185a42b196591b686670.js"></script>
                </div>
            </div>
        </div>


        <div class="sub-heading">Getting a <code>ResultSet</code></div>
        <div>
            - Example code on Github <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/QueryPersonTest.java">here</a>.
            <br>
            - You can get a result set from a database using a <code>Statement</code>, a <code>PreparedStatement</code>,
            or a <code>CallableStatement</code>. In simple cases, you call <code>executeQuery()</code> method of a
            <code>Statement</code> object or a <code>PreparedStatement</code> object with a <code>SELECT</code>
            statement that will return a <code>ResultSet</code>. <br>
            - In the beginning, the cursor points before the first row in the result set. This row is an imaginary row.
            You must move the cursor to a valid row before you can access the column's values for that row. Calling the
            <code>next()</code> method moves the cursor to the next row. Hence, the first time that you get a <code>ResultSet</code>
            objet, you have to call it's <code>next()</code> method in order to read the first row of the result set.
            <br>
            - Also, important to note that the <code>next()</code> method returns a <code>boolean</code> value. It
            returns true if the cursor is positioned to a valid row. Otherwise, it returns false. If you call the
            <code>next()</code> method on an empty <code>ResultSet</code> object for the first time, it will return
            false, because there is no valid row to move to. If the current row is the last row in the result set,
            calling the <code>next()</code> method will position the cursor after the last row and it will return false.
            <br>
            - When a cursor is positioned after the last row in a forward-only scrollable <code>ResultSet</code> object,
            you cannot do anything with it, except close it using its <code>close()</code> method. You cannot reopen a
            <code>ResultSet</code> either. To iterate through the result set data again, you must re-execute the query
            and obtain a new <code>ResultSet</code>. A bidirectional scrollable <code>ResultSet</code> on the other hand
            allows you to iterate through the rows as many times as you want. <br>
            - When you do not create the <code>ResultSet</code>, you must know the cursor position correctly in order to
            process the rows in a specific order. The following four methods of the <code>ResultSet</code> interface let
            you know if the cursor is before the first row, on the first row, on the last row, or after the last row:
            <br>
            <code>isBeforeFirst()</code>, <code>isFirst()</code>, <code>isLast()</code>, <code>isAfterLast()</code> <br>
        </div>

        <div class="sub-heading">Reading values from a <code>ResultSet</code></div>
        <div>
            - A <code>ResultSet</code> object lets you read the value of a column from its current row using one of its
            getXxx() method, where Xxx is the data type of the column. <br>
            - You must specify the index or name of the column in the getXxx() method whose value you want to read. The
            getXxx() methods are overloaded. One version accepts an int parameter, which lets you use the column index
            and another version accepts a String parameter, which lets you use the column label. If the column label is
            not specified in the query, you can specify the column name. <br>
            - Example: <code>SELECT person_id AS "Person ID", first_name, last_name FROM person</code> <br>
            - In the <code>ResultSet</code>, the <code>person_id</code> column has a column index of 1, the <code>first_name</code>
            column has a column index of 2, and the <code>last_name</code> column has a column index of 3. You have
            specified <code>Person ID</code> as the column label for the <code>person_id</code> column. You have not
            specified the column labels for the <code>first_name</code> and <code>last_name</code> columns. To get the
            value of the <code>person_id</code> column, you need to use either <code>getInt(1)</code> or
            <code>getInt("PERSON ID")</code>. To get the value of the <code>first_name</code> column, you need to use
            either <code>getString(2)</code> or <code>getString("first_name")</code>.
        </div>


        <div class="sub-heading">Handling <code>null</code> values in a <code>ResultSet</code></div>
        <div>
            - Example code present <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/QueryPersonTest.java#L79-L81">here</a>.
            <br>
            - In a <code>ResultSet</code>, when a column has a null value, the getXxx() method returns the default value
            for the Xxx data type. For example, for numeric data types (int, double, byte, etc.), the getXxx() method
            returns zero when the column has a null value. A getXxx() method returns false for the boolean data type
            when the column has null value. The getXxx() returns <code>null</code> if Xxx is a reference type. <br>
            - If you want to know whether the column value, which you read using a getXxx() method, is null, you need to
            call the <code>wasNull()</code> method immediately after calling the getXxx() method. If the
            <code>wasNull()</code> method returns true, the column value is null in the result set. If the <code>wasNull()</code>
            method returns false, the column value is not null in the result set. Note that the <code>wasNull()</code>
            method does not accept any parameter and it returns null value status of the last read column using a
            getXxx() method.
        </div>


        <div class="sub-heading">Getting the number of Rows in a <code>ResultSet</code></div>
        <div>
            - There is no method in the <code>ResultSet</code> interface that returns the number of rows in the result
            set. The <code>ResultSet</code> interface contains a <code>getRow()</code> method that returns the current
            row number in the <code>ResultSet</code>. It returns zero if there is no current row, such as when the
            cursor is before the first row or after the last row. <br>
            - If you want to know the number of rows in a forward-only scrollable <code>ResultSet</code> BEFORE you
            start iterating over the <code>ResultSet</code>, the only way to do this is to get the
            <code>ResultSet</code> twice. But, between the time when you get the first result set and when you get the
            second result set, the data in the database might change, which will make the row
            count from the first execution invalid. <br>
            - Another way is to execute a separate SQL query - <code>SELECT COUNT(*) FROM person WHERE ...</code> once
            you are done running your <code>SELECT</code> statement. But you again run into the same issue of another
            transaction possibly changing the DB between the first and the second query. <br>
            - The solution is to use a Bidirectional Scrollable ResultSet.
        </div>

        <div class="sub-heading">Using a Bidirectional Scrollable ResultSet</div>
        <div>
            - Code present <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/BidirectionalScrollableResultSet.java">here
            on Github</a>. <br>
            - After you get the <code>ResultSet</code>, call its <code>last()</code> method to move its cursor to the
            last row in the result set. Call the <code>getRow()</code> method when the cursor is at the last row.
            The <code>getRow()</code> method will return the row number of the last row, which will be the number of
            rows in the result set. <br>
            - If you want to process the result set after getting the number of rows, you can call its <code>beforeFirst()</code>
            method to scroll the cursor before the first row and start a while-loop to process the rows in the result
            set again. <br>
            - After getting a <code>ResultSet</code> object, it is very important to check if it
            supports bidirectional scrolling before you call the <code>last()</code> method on it. A forward-only <code>ResultSet</code>
            object will throw a <code>SQLException</code> if you call the <code>last()</code> method. You can get the
            scrollable property of a <code>ResultSet</code> object by calling its <code>getType()</code> method.
        </div>


        <div class="sub-heading">Bidirectional Scrollable ResultSet</div>
        <div>
            - <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/BidirectionalScrollableResultSet.java#L20-L32">Code</a>
            on how to create <code>Statement</code> with Bi-directional result set. <br>
            - There are overloaded methods of the <code>createStatement</code>, <code>prepareStatement</code>, and
            <code>prepareCall</code> that let you specify the scrollability, concurrency, and holdability of the
            <code>ResultSet</code>. <br>
            - The default <code>createStatement()</code> and <code>prepareStatement()</code> (<a
                href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html#createStatement()">link to Java
            Docs for the method</a> )that do not accept any arguments set up the following kind of
            <code>ResultSet</code>: Result sets created using the returned <code>Statement</code> object will by default
            be type <code>TYPE_FORWARD_ONLY</code> and have a concurrency level of <code>CONCUR_READ_ONLY</code>. The
            holdability of the created result sets can be determined by calling <code>getHoldability()</code>. <br>
            - The JDBC driver determines the default value for the holdability of a ResultSet. Different JDBC drivers
            have different default values for this property.
        </div>

        <div class="sub-heading">ResultSet and Fetch Size</div>
        <div>
            - Note that a <code>ResultSet</code> does not retrieve all rows for a query at once. The number of rows a
            ResultSet will retrieve from the database is JDBC driver-dependent. <br>
            - You can give a hint to the JDBC driver using the <code>setFetchSize(int fetchSize)</code> method of the
            <code>ResultSet</code> object to fetch a specified number of rows from the database whenever more rows are
            needed. Read the Java Docs for the <code>setFetchSize</code> <a
                href="https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#setFetchSize(int)">here</a>.
            Read about how the <code>setFetchSize</code> method works on SO <a
                href="https://stackoverflow.com/questions/1318354/what-does-statement-setfetchsizensize-method-really-do-in-sql-server-jdbc-driv">here</a>
            and
            <a href="https://stackoverflow.com/a/42379544/8742428">here</a>.
            The difference between the <code>setFetchSize()</code> method on <code>ResultSet</code> and
            <code>Statement</code> can be read on <a
                href="https://stackoverflow.com/questions/37394440/difference-between-setting-a-fetch-size-on-statement-vs-resultset">this
            SO Link</a> (The only place the fetch size really matters is on the ResultSet. When a ResultSet is created,
            it gets its fetch size from the Statement that was used to create it, but it can be changed later.
            Think of the Statement's fetch size as a default that will be passed to all the ResultSets it creates. If
            you don't want to use this default, you can override it.).
            <br>
            - Oracle specific documentation can be read <a
                href="https://docs.oracle.com/cd/E18283_01/java.112/e16548/resltset.htm#i1023619">here</a>. This says:
            When the statement object run a query, the fetch size of the statement object is passed to the result set
            object produced by the query. However, you can also set the fetch size in the result set object to override
            the statement fetch size that was passed to it. Note: Changes made to the fetch size of a statement object
            after a result set is produced will have no affect on that result set. By default, when Oracle JDBC runs a
            query, it retrieves a result set of 10 rows at a time from the database cursor. This is the default Oracle
            row fetch size value. You can change the number of rows retrieved with each trip to the database cursor by
            changing the row fetch size value.<br>
            - Note that there is a <code>setFetchSize</code> method on all <code>Statement</code>,
            <code>PreparedStatement</code>, <code>CallableStatement</code>, and <code>ResultSet</code> objects. <br>
            - When does a <code>ResultSet</code> need to fetch more rows from the database?
            A <code>ResultSet</code> needs to fetch more rows if you position its cursor to a row that is not in its
            cache. For example, calling the <code>next()</code> method of a <code>ResultSet</code> may trigger a fetch
            from the database. Suppose a <code>ResultSet</code> fetches 10 records at a time. If you call the <code>next()</code>
            method the first time, it will fetch and cache 10 records and, for nine subsequent calls to its
            <code>next()</code> method, it will give you rows from its cache. Fetching and caching rows for a <code>ResultSet</code>
            is dependent on a JDBC driver and the underlying DBMS. <br>
            - There is also a <code>setMaxRows</code> method on the <code>RowSet</code> interface as shown <a
                href="https://docs.oracle.com/javase/7/docs/api/javax/sql/RowSet.html#setMaxRows(int)">here</a>. This is
            different from the <code>setFetchSize</code> as explained on <a
                href="https://stackoverflow.com/a/32399694/8742428">this SO Link</a>. <br>
            - Question: So loading the entire ResultSet into the memory is to be avoided. So suppose if we set the
            setFetchSize to 25, and then fetch the next 25 rows, ie. 26-50, are the rows from 1-25 removed from the
            memory? If I am using a bi-directional ResultSet, and decide to go back to row 1 for example, will this
            cause another trip to the OracleDB?
        </div>


        <div class="sub-heading">Scrolling Through Rows of a ResultSet</div>
        <div>
            - There are two sets of rows that a cursor may point to. One set of rows consists of two imaginary rows -
            one before the first row and one after the last row. Another set of rows consists of the rows that match the
            query. <br>
            - You can use the <code>getRow()</code> method of the <code>ResultSet</code> interface to get the row number
            of the row at which the cursor is currently positioned. If the cursor is positioned before the first row or
            after the last row, the <code>getRow()</code> method returns zero.
            <img src="imgs/Java8_JDBC_Imgs/ResultSet.PNG" class="center-block img-fluid"
                 alt="ResultSet"
                 width="800">
            - If you have a <code>ResultSet</code> object that has its scrollability set to forward-only, you can only
            use its <code>next()</code> method to move the cursor, which moves its cursor one row in the forward
            direction. <br>
            - If a <code>ResultSet</code> has a bidirectional scrollability, you have many methods to change its cursor
            position. <br>
            - A cursor movement can either be an absolute movement or a relative movement. <br>
            - Refer page 455 of book for description about all the methods that can be used to scroll through the <code>ResultSet</code>
            <br>
            - Use the <code>last()</code> method with caution. This method call will force the JDBC driver to retrieve
            all rows from the database. If a DBMS does not support a bidirectional scrollable cursor, a JDBC
            driver will have to cache all rows on the client. For a very large result set, it may affect the performance
            of the application adversely.
        </div>


        <div class="sub-heading">Closing a ResultSet</div>
        <div>
            - You can close a ResultSet object by calling its <code>close()</code> method. <br>
            - A ResultSet object can also be closed implicitly in the following situations: <br>
            a) When the Statement object that produces the ResultSet object is closed, it automatically
            closes the ResultSet object. <br>
            b) When a Statement object is re-executed, its previously opened ResultSet object is closed. <br>
            c) If a Statement object produces multiple result sets, retrieving the next result set closes the
            previously retrieved ResultSet. <br>
            d) If it is a forward-only scrollable ResultSet, a JDBC driver may choose to close it when its
            next() method returns false as the part of optimization. Once the next() method returns
            false for a forward-only scrollable ResultSet, you cannot do anything with that ResultSet
            anyway.
        </div>

        <div class="sub-heading">Making changes to a ResultSet</div>
        <div>
            - You can use a <code>ResultSet</code> to perform insert, update, and delete operations on database tables.
            The concurrency for the <code>ResultSet</code> object must be <code>ResultSet.CONCUR_UPDATABLE</code> in
            order to perform updates on the <code>ResultSet</code>.
        </div>


        <div class="sub-heading">Inserting a Row using a ResultSet</div>
        <div>
            - Code to insert a row <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/ResultSetInsert.java">here</a>
            on github. <br>
            - In addition to the two imaginary rows that we saw earlier, <code>ResultSet</code> has a third imaginary
            row that is called the <i>insert row</i>. You can think of this row as an empty new row, which acts as a
            staging area for a new row that you want to insert.<br>
            - You can position the cursor to the insert row using the <code>ResultSet</code> object's <code>moveToInsertRow()</code>
            method. When the cursor moves to the insert row, it remembers its previous position. You can call the <code>moveToCurrentRow()</code>
            method to move the cursor from the insert row back to the previously current row. <br>
            - So the steps that you follow in order to insert a new row are as follows: <br>
            a) Move the cursor to an insert row to add a new row: <br>
            <code>resultSet.moveToInsertRow();</code> <br>
            b) Set the values for all the columns (at least for non-nullable columns) using one of the updateXxx()
            methods of the ResultSet interface. <br>
            c) Send changes to the database: <br>
            <code>resultSet.insertRow()</code> <br>
            The call to the <code>insertRow()</code> method may or may not make the inserted row a permanent row in the
            database. If the auto-commit mode is enabled for the <code>Connection</code>, the <code>insertRow()</code>
            call will also commit your transaction. In that case, the new row becomes part of the database permanently.
            If the auto-commit mode is disabled for the <code>Connection</code>, you can make the insert permanent by
            committing the transaction, or cancel the insert by rolling back the transaction. <br>
            d) After inserting your row, you can move back to your previous current row: <br>
            <code>resultSet.moveToCurrentRow();</code> <br>
            Note that moving to another row before calling the <code>insertRow()</code> method after calling the
            <code>moveToInsertRow()</code> method discards the new row. <br>

            <br>
            - Question: why can't I see the values that I insert in the same ResultSet even though my ResultSet is set
            to <code>TYPE_SCROLL_SENSITIVE</code>? This <a href="https://stackoverflow.com/a/16959086/8742428">SO Link
            explains</a> why (You might also want to check <code>DatabaseMetaData.ownInsertsAreVisible(int)</code> and
            related methods for your specific database and driver.) You can check these values for the OracleDB by
            running
            <a href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/SupportedResultSetProperties.java#L40">this
                code here</a>. <br>
            Question: Why does using <code>SELECT * FROM people;</code> generate a read only ResultSet. Read at <a
                href="https://stackoverflow.com/a/26672027/8742428">this SO Link</a>. (To produce a scroll-sensitive
            result set a query cannot use "SELECT * ".) <br>

        </div>


        <div class="sub-heading">Updating a Row using a ResultSet</div>
        <div>
            - Code to update the row <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/ResultSetUpdate.java">here</a>.
            Question asked on SO regarding behavior <a
                href="https://stackoverflow.com/questions/64069368/ownupdatesarevisible-for-type-forward-only-oracledb-prints-false">here</a>.
            <br>
            - Steps involved in updating an existing row in a ResultSet object: <br>
            1) Move the cursor to a valid row in the result set. Note that you can update data only for an
            existing row. It is obvious that the cursor should not be positioned before the first row or
            after the last row if you want to update the data in a row. <br>
            2) Call an updateXxx() method for a column to update the column's value. <br>
            3) If you do not want to go ahead with the changes made using updateXxx() method calls,
            you need to call the <code>cancelRowUpdates()</code> method of the <code>ResultSet</code> to cancel the
            changes. <br>
            4) When you are done updating all the column's values for the current row, call the
            <code>updateRow()</code> method to send the changes to the database. If the auto-commit mode is
            enabled for the <code>Connection</code>, changes will be committed. Otherwise, you need to commit
            the changes to the database. <br>
            5) If you move the cursor to a different row before calling the <code>updateRow()</code>, all your changes
            made using the updateXxx() method calls will be discarded. <br>
            6) There is another way to lose your updates to columns in a row. If you call the
            <code>refreshRow()</code> method after calling updateXxx(), but before calling <code>updateRow()</code>,
            your changes will be lost because the JDBC driver will refresh the row's data from the database.

            <br><br>

            - Note that you do not have to set the scrollability of the <code>ResultSet</code> to <code>TYPE_SCROLL_SENSITIVE</code>
            in order to see your changes in the DB. Because as is specified in it's definition, "<code>TYPE_SCROLL_SENSITIVE</code>
            makes the changes in the underlying database made by OTHER transactions or statements in the same
            transaction visible to the ResultSet object." So the changes made by your transaction would still be visible
            if you just left it to <code>TYPE_FORWARD_ONLY</code>. <br>
            - What does it mean for changes to be "visible"?
            <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/jjdbc/resultset.html#JJDBC-GUID-71728FB5-5112-4204-B563-A40D8C5FD783">Source</a>
        </div>


        <div class="sub-heading">Deleting a Row using a ResultSet</div>
        <div>
            - Code <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/ResultSet/ResultSetDelete.java">here</a>.
            <br>
            - Unlike UPDATE and INSERT operations in a result set, which require a separate step to propagate the
            changes to the database, a DELETE operation in a result set is immediately run in the corresponding row in
            the database as well. Once you call deleteRow method, the changes are made permanent with the next
            transaction COMMIT operation.
            Remember also that by default, the auto-commit flag is set to true. Therefore, unless you override this
            default, any deleteRow method operation is run and committed immediately.
            <a href="https://docs.oracle.com/cd/B28359_01/java.111/b31224/resltset.htm#sthref982">Oracle JDBC Docs</a>
            Source. <br>
        </div>


        <div class="sub-heading">Using RowSets</div>
        <div>
            - An instance of the <code>RowSet</code> interface is a wrapper for a result set. The <code>RowSet</code>
            interface inherits from the <code>ResultSet</code> interface.
        </div>

        <div class="sub-heading">Advantages of using RowSets</div>
        <div>
            - When you use a <code>ResultSet</code> object, you must deal with the <code>Connection</code> and <code>Statement</code>
            objects at the same time. A <code>RowSet</code> hides the complexities of using the <code>Connection</code>
            and
            <code>Statement</code> objects from the developers. <br>
            - A <code>ResultSet</code> is not <code>Serializable</code> and therefore, it cannot be sent over the
            network or saved to the disk for later use. A <code>RowSet</code> is <code>Serializable</code>. It can be
            sent over the network or saved to a disk for later use. <br>
            - A <code>ResultSet</code> is always connected to a data source. A <code>RowSet</code> object does not need
            to be connected to its data source all the time. It can connect to the database when needed such as
            to retrieve/update data in the data source. <br>
            - A <code>RowSet</code> is by default scrollable and updatable. <br>
            - The two properties of a <code>RowSet</code>, serialization and connectionlessness, makes it very useful in
            a thin client environment such as a mobile device or a web application. A thin client does not
            need to have a JDBC driver. <br>
            - A <code>RowSet</code> also supports filtering of data after the data has been retrieved. Filtering of data
            is not possible in a <code>ResultSet</code>. You must use a <code>WHERE</code> clause in a query to filter
            data in the database itself if you use a <code>ResultSet</code>. <br>
            - A <code>RowSet</code> makes it possible to join two or more data sets based on their columns values
            after they have been retrieved from their data sources.
        </div>


        <div class="sub-heading">Disadvantages of using RowSets</div>
        <div>
            - A specific <code>RowSet</code> implementation may cache data in memory. You need to be careful when
            using such type of RowSets. You should not fetch large volumes of data using these RowSets.
            Otherwise, it may slow down the application. <br>
            - With cached data in a <code>RowSet</code>, there are more possibilities of data inconsistency between the
            data in the <code>RowSet</code> and data in the data source, when changes are applied to the data source.
        </div>

        <div class="sub-heading">Creating a RowSet</div>
        <div>
            - Code to set up a Util Class for creating <code>RowSet</code> <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/RowSetUtil.java">here</a>.
            <br>
            - The following interfaces in the <code>javax.sql.rowset</code> package define five types of rowsets: <br>
            a) JdbcRowSet <br>
            b) CachedRowSet <br>
            c) WebRowSet <br>
            d) FilteredRowSet <br>
            e) JoinRowSet <br>
            - Each type of rowset has features that are suitable for specific needs. All these rowset interfaces
            inherit, directly or indirectly, from the <code>RowSet</code> interface. The <code>RowSet</code> interface
            is inherited from the <code>ResultSet</code> interface. Therefore,
            all methods in the <code>ResultSet</code> interface are also available in all types of rowsets.

            <img src="imgs/Java8_JDBC_Imgs/RowSet_ClassDiagram.PNG" class="center-block img-fluid"
                 alt="RowSet_ClassDiagram"
                 width="300">
        </div>


        <div class="sub-heading">JDBCRowSet</div>
        <div>
            - Refer how to create JDBCRowSet code to read from a table and update a table<a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/RowSet/JDBCRowSetTest.java">here</a>.
            <br>
            - A <code>JdbcRowSet</code> is also called a <i>connected rowset</i> because it always maintains a database
            connection. <br>
            - You can think of a <code>JdbcRowSet</code> as a thin wrapper for a <code>ResultSet</code>. As a <code>ResultSet</code>
            always maintains a database connection, so does a <code>JdbcRowSet</code>. It adds some methods that let you
            configure the connection behaviors. <br>
            - Updating data using a <code>JdbcRowSet</code> is similar to updating data using a <code>ResultSet</code>.
            Make sure that you set the auto-commit mode for the rowset appropriately. <br>
            - Note that you must call the <code>updateRow()</code> method of the <code>JdbcRowSet</code> after updating
            the column's value and before you scroll to another row. Otherwise, your changes will be lost as it is lost
            in the case of updating data in a <code>ResultSet</code>. In case of <code>JdbcRowSet</code>, you do not
            have a direct access to the <code>Connection</code> object. You need to use <code>JdbcRowSet</code> object's
            <code>commit()</code> and <code>rollback()</code> methods to commit and rollback changes to the database.
        </div>


        <div class="sub-heading">CachedRowSet</div>
        <div>
            - A <code>CachedRowSet</code> is also called a <i>disconnected rowset</i> because it is disconnected
            from a database when it does not need a database connection. It keeps the database connection open only for
            the duration it needs to interact with the database. Once it is done with the connection, it disconnects.
            For example, it connects to a database when it needs to retrieve or update data. <br>
            - It retrieves all data generated by the command and caches the data in memory. Care should be taken not to
            retrieve a large volume of data in a <code>CachedRowSet</code>. Otherwise, it may degrade the performance of
            the application. It provides a new feature called <i>paging</i>, which lets you deal with large volume of
            data in chunks. <br>
            - A <code>CachedRowSet</code> is always serializable, scrollable, and updatable. <br>
            - You can use the following 4 methods to populate data in a <code>CachedRowSet</code>: <br>
            a) <code>void execute() throws SQLException</code> <br>
            b) <code>void execute(Connection conn) throws SQLException</code> <br>
            c) <code>void populate(ResultSet data) throws SQLException</code> <br>
            d) <code>void populate(ResultSet rs, int startRow) throws SQLException</code> <br>
            - What is the actual documentation supposed to be? Is it <a
                href="https://docs.oracle.com/cd/B28359_01/java.111/b31224/jcrowset.htm">this</a> or <a
                href="https://docs.oracle.com/javase/7/docs/api/javax/sql/rowset/CachedRowSet.html">this</a>????? <br>
            - <a href="https://docs.oracle.com/javase/7/docs/api/javax/sql/rowset/CachedRowSet.html">This Java Doc
            link</a> explains how paging works in <code>CachedRowSet</code>. <br>

            <br>

            - A <code>CachedRowSet</code> provides an additional feature called <i>paging</i> to let you retrieve rows
            generated by a command in chunks. The chunk of rows that is retrieved at one time is called a <i>page</i>.
            You can think of a page as a set of rows, where you decide the number of rows in the set. The maximum number
            of rows in a page is called the <i>page size</i>. <br>
            - Suppose a command for a <code>CachedRowSet</code> generates 500 rows. By calling its
            <code>setPageSize(90)</code>, it will retrieve a maximum of 90 rows at a time. When you call its
            <code>execute()</code> method, it will retrieve the first 90 rows. To retrieve the next 90 rows, you need to
            call its
            <code>nextPage()</code> method. When it has retrieved five pages (450 rows), calling the
            <code>nextPage()</code> will retrieve the remaining 50 rows. <br>
            - It also provides a <code>previousPage()</code> method to retrieve the previous page. You can use the
            <code>nextPage()</code> and <code>previousPage()</code> methods of a <code>CachedRowSet</code> to retrieve
            and process a large result set in chunks. <br>
            - Check the code for how to use paging in <code>CachedRowSet</code> <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/master/src/main/java/com/example/demo/RowSet/CachedRowSetTest.java#L19">here</a>.

            <br>
            <br>
            - Code <a
                href="https://github.com/rgbk21/JDBC_Setup/blob/3f74e3cd944fd23b4a2956eb105bf89e8b3b3a71/src/main/java/com/example/demo/RowSet/CachedRowSetTest.java#L25">here</a>.
            Good luck.
            - You can update the data in a <code>CachedRowSet</code> and save the changes back to the database. The
            process of saving changes to the database for a <code>CachedRowSet</code> is different from that of a <code>JdbcRowSet</code>.
            There are two main reasons to keep the save process a little different for a <code>CachedRowSet</code>.
            First, it is disconnected and you do not want to connect to the database often. Second, the updated data may
            have conflicts with the data stored in the database. <br>
            - The process of inserting, updating, and deleting rows in a <code>CachedRowSet</code> is the same as in a
            <code>JdbcRowSet</code>. But note that these methods do not send changes to the database when used with a
            <code>CachedRowSet</code>. <br>
            - After you make changes to a <code>CachedRowSet</code>, you can send changes to the database by calling its
            <code>acceptChanges()</code> method that may commit the changes if you have set the <code>commit-on-accept-change</code>
            value to true. You need to refer to the implementation details of the <code>CachedRowSet</code> on how it
            lets you set the <code>commit-on-accept-change</code> value. If it is set to false, you need to use the
            <code>commit()</code> or <code>rollback()</code> method of the <code>CachedRowSet</code> interface to commit
            or rollback changes. <br>
            - What??? <br>
            - A <code>CachedRowSet</code> has to deal with conflicts that may exist between the data in it and the data
            in the database. For example, you might have retrieved a row from the database, changed the data, and kept
            the changes in the <code>CachedRowSet</code> for a long time. When you are ready to save your changes,
            another user might have changed the values for the same rows before you. A <code>CachedRowSet</code> uses a
            synchronization provider object to synchronize the changes with the database. It uses another object, a
            synchronization resolver, to resolve any conflicts that it detects during
            the synchronization process. When conflicts are detected during the <code>acceptChanges()</code> method
            call, it throws a <code>SyncProviderException</code>. You can get the synchronization resolver object that
            is an instance of the <code>SyncResolver</code> interface, using the <code>getSyncResolver()</code> method
            of the <code>SyncProviderException</code> object.
            A <code>SyncResolver</code> object lets you navigate through all conflicts and change the values in the rows
            with conflicts to new resolved values. You need to use the <code>setResolvedValue()</code> method of a
            <code>SyncResolver</code> object to set the resolved value when a conflict is detected. <br>
        </div>


        <div class="sub-heading">WebRowSet</div>
        <div>
            - TODO: Code Examples <br>
            - The <code>WebRowSet</code> interface inherits from the <code>CachedRowSet</code> interface. It adds two
            more features to the <code>CachedRowSet</code>:
            reading data and metadata from an XML document, and exporting data and metadata to an XML document. The
            two methods that it adds to provide XML support are <code>readXML()</code> and <code>writeXML()</code>.
        </div>

        <div class="sub-heading">FilteredRowSet</div>
        <div>
            - TODO: Code Examples <br>
            - The <code>FilteredRowSet</code> interface inherits from the <code>WebRowSet</code> interface. It provides
            filtering capability to a rowset at the client side. <br>
            - You can apply a filter to the rowset by using a where clause in its SQL command, which is
            executed in a database. But a <code>FilteredRowSet</code> lets you filter the rows of a rowset after it has
            retrieved the data from a database. <br>
            - Setting a filter to a rowset does not delete the rows from the rowset. Rather, it lets you access only
            those rows that meet the filter criteria. The filter also applies to inserting, updating, and deleting the
            rows in the rowset. You can only read, insert, update, and delete rows that meet the filter criteria. You
            can reset the filter any time you want to view all rows of a rowset. A filter is an object of a class that
            implements the <code>javax.sql.rowset.Predicate</code> interface.
        </div>


        <div class="sub-heading">JoinRowSet</div>
        <div>
            - TODO: Code Examples <br>
            - The JoinRowSet interface inherits from the WebRowSet interface. It provides the ability to combine (or
            join) two or
            more disconnected rowsets into one rowset. Rows from two or more tables are joined in a query using a SQL
            JOIN.
            A JoinRowSet lets you have a SQL JOIN between two or more rowsets without using a SQL JOIN in a query. <br>
            - There are 5 standard types of Joins: <br>
            a) Inner Join <br>
            b) Left Outer Join <br>
            c) Right Outer Join <br>
            d) Full Join <br>
            e) Cross Join
        </div>

        <div class="sub-heading">BatchUpdates</div>
        <div>
            - You saw examples of using the <code>Statement</code>, <code>PreparedStatement</code>, and <code>CallableStatement</code>
            interfaces that let you send one SQL command (or stored procedure call) at a time to the database. The JDBC
            API includes a batch update feature that lets you send multiple update commands to a database in a batch (in
            one bundle) for execution. A batch update greatly improves performance. <br>
            - The update commands that you can use in a batch update are SQL INSERT, UPDATE,
            DELETE, and stored procedures. A command in a batch should not produce a result set. Otherwise, the JDBC
            driver will throw a <code>SQLException</code>. A command should generate an update count that will indicate
            the number of rows affected in the database by the execution of that command.
        </div>
    </div>


    <hr>
    <div id="Ch1_Vlad" class="chapter">Chapter 1: JDBC and DB Essentials: Performance and Scaling</div>
    <hr>

    <div>
        - Github repo for Vlad <a href="https://github.com/vladmihalcea/high-performance-java-persistence">here</a>.
    </div>

    <div class="sub-heading">Understanding entities and value types</div>


    <div id="HIA_CH4" class="chapter">Chapter 4: Mapping Persistent Classes</div>

    <div class="textual-content">

        <div class="sub-heading">Understanding entities and value types</div>
        <div>
            - Fine-grained domain models means more classes than tables.
        </div>

    </div>


</div>
<script src="../../script.js"></script>
</body>
</html>
