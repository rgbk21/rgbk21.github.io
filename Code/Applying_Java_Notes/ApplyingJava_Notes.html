<!DOCTYPE html>
<html>
<head>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="ApplyingJava_Notes.css">
    <meta name="keywords" content="Java, Floats, Overflow, Unboxing, Autoboxing">
    <meta name="author" content="Raj Gaurav Ballabh Kumar">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applying Java - Notes</title>
</head>

<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">

    <div class="navbar-header">
        <a href="../../index.html" class="navbar-brand"> rgbk21</a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"><span
            class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="nav navbar-nav">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Projects/TwitterCritNodes/TwitterCritNodes_1.html">Identifying
                        Critical Nodes on Twitter</a>
                    <a class="dropdown-item" href="../../Projects/isRelatedTo/isRelatedTo.html">isRelatedTo</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    HTML Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../ImageGallery/ImageGallery.html">Image Gallery</a>
                    <a class="dropdown-item" href="../../RGB_Guesser_Game/RGB.html">RGB Guesser Game</a>
                    <a class="dropdown-item" href="../../ToDoList/todo.html">To-Do List</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Notes
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../COMS_631/COMS_631_index.html">COMS 631</a>
                    <a class="dropdown-item" href="../../COMS_535/COMS_535_index.html">COMS 535</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Code
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Code/ThingsToRemember/ThingsToRemember.html">Things To
                        Remember</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes.html">Java Notes</a>
                    <a class="dropdown-item" href="../../Code/Applying_Java_Notes/ApplyingJava_Notes.html">ApplyingJava
                        Notes</a>
                    <a class="dropdown-item" href="../../Code/Spring/Spring.html">Spring Notes</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    In Another Life
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../InAnotherLife/Chapter1.html">Chapter 1</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
        </ul>


        <ul class="navbar-nav ml-auto">
            <li class="nav-item active"><a class="nav-link" href="https://github.com/rgbk21">GitHub</a></li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.linkedin.com/in/raj-gaurav-ballabh-kumar-97002058/">LinkedIn</a>
            </li>
            <li class="nav-item active"><a class="nav-link" href="https://www.instagram.com/wobblyframes/">Instagram</a>
            </li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.facebook.com/SomeRandomThoughts">Facebook</a></li>
        </ul>

    </div>
</nav>

<div class="container">
    <div>
        This page mainly contains my notes from a) Java: The Complete Reference, and b) <a href="#head-first">Head
        First: Servlets and JSP</a>
    </div>

    <div class="chapter">Chapter 34: Java Beans</div>
    <div class="textual-content">

        <div class="sub-heading">What is a Java Bean</div>
        <div class="textual-content">
            - A <i>Java Bean</i> is a software content that has been designed to be reusable in a variety of different
            environments. There is no restriction in the capability (in terms of complexity) of a Java Bean. A bean may
            perform a simple function or a complicated function.
            <br>
            - At a basic level, <a
                href="https://stackoverflow.com/questions/21866571/difference-between-javabean-and-spring-bean">JavaBeans
            are simply Java classes</a> which adhere to certain coding conventions.
            Specifically, classes that have:
            <ul>
                <li><code>public</code> default (no argument) constructors</li>
                <li>allow access to their properties using accessor (getter and setter) methods</li>
                <li>implement <code>java.io.Serializable</code></li>
                <li>all JavaBean instance variables should be private</li>
            </ul>
        </div>
        <div class="sub-heading">What is the difference between a Java Bean and a POJO</div>
        <div class="textual-content">
            - A JavaBean follows <a
                href="https://stackoverflow.com/questions/1394265/what-is-the-difference-between-a-javabean-and-a-pojo">certain
            conventions</a>. Getter/setter naming, having a public default constructor, being
            serializable etc. See <a href="https://docstore.mik.ua/orelly/java-ent/jnut/ch06_02.htm">JavaBeans
            Conventions</a> for more details.
            <br>
            - A POJO (plain-old-Java-object) isn't rigorously defined. It's a Java object that doesn't have a
            requirement
            to implement a particular interface or derive from a particular base class, or make use of particular
            annotations in order to be compatible with a given framework, and can be any arbitrary (often relatively
            simple) Java object.
            <br>
            - All JavaBeans are POJOs but not all POJOs are JavaBeans.
        </div>
        <div class="sub-heading">What is the difference between a Java Bean and a Spring Bean</div>
        <div class="textual-content">
            - A Spring bean is basically an object managed by Spring. More specifically, it is an object that is
            instantiated, configured and otherwise managed by a Spring Framework container. Spring beans are defined in
            Spring configuration files (or, more recently, with annotations), instantiated by Spring containers, and
            then injected into applications.
            <br>
            - Note that Spring beans need not always be JavaBeans. Spring beans might not implement the
            <code>java.io.Serializable</code> interface, can have arguments in their constructors, etc.
            This is the very basic difference between JavaBeans and Spring beans.
            <br>
            - <a href="http://www.shaunabram.com/beans-vs-pojos/">The reason Spring managed objects are referred to as
            beans</a> is because in the very early versions, Spring was
            intended only for use with JavaBeans. That is no longer the case of course: Spring can manage just about any
            object, even if it doesn’t have JavaBean type characteristics such as default constructors or mutator
            methods (getters and setters). None the less, the term ‘Spring beans’ has stuck.
            Can Spring beans be POJOs? Yes, and they usually are (although they don’t have to be – e.g. Spring can be
            used with ‘heavyweight’ Java objects, such as EJBs).
            Can Spring beans be JavaBeans? As I have said, yes and again they often are but don’t have to be.
        </div>
        <div class="sub-heading"><a
                href="https://stackoverflow.com/questions/3461199/what-is-the-advantage-of-using-java-beans">Advantages
            of a Bean</a></div>
        <div class="textual-content">
            A JavaBean on its own is not terribly interesting, it's just a Java class that conforms to some standards.
            However, conformance with this standard is one of the pillars on which the Java EE
            framework is built and it comes up in quite a few places. FYI, there are a few different types of EJB listed
            below:
            <ul>
                <li><b>Entity Beans</b>:</li>
                <div>You might want to read/write objects to/from an underlying database. You could use JDBC/SQL to do
                    this but you could also use a persistance framework. The Java EE spec includes a spec for
                    persistance whereby you declare your class to be an "entity bean" and have Java automatically
                    generate database tables and logic to map between entries in your database and objects in your
                    program. The actual implementation is provided by a lower level library such as Eclipselink,
                    Toplink, Hibernate etc. but the Java API abstracts away any differences between them.
                    <br>
                    Session beans represent logic while entity beans represented persistent objects. <a
                            href="https://stackoverflow.com/a/13501659/8742428">These days entity
                        beans aren't used anymore in favour to JPA entities.</a>
                </div>
                <li><b>Stateful Session Beans</b></li>
                <div>
                    Imagine that you want to create an instance of a Java class which exists on separate JVM. The JVMs
                    might be running on the same physical machine but equally, may be on separate machines communicating
                    over a network. Using a Java EE application server, you can create a class which can be instantiated
                    by clients of the app server. These clients can instantiate a class which will act just like a
                    normal object but any methods that are invoked on the object get executed on the server with the
                    results being passed back to the caller. It's basically an object oriented form of remote procedure
                    calls.
                </div>
                <li><b>Stateless Session Beans</b></li>
                <div>
                    This is a minor variation on stateful session beans. With stateful beans, if the server has 1000
                    clients then it will potentially have to create 1000 instances of the bean and remember which
                    instance belongs to which client. With stateless beans, the server creates a pool of beans and
                    doesn't bother to remember which client owns which bean. When a client invokes a method, the server
                    picks a bean from the pool and uses it, returning it to the pool on completion. You use stateful
                    session beans when you want the server to remember details about each client, you will use stateless
                    beans when you don't need to remember client specific details. Note that the stateless beans may
                    well have state, it's just that this state won't be of interest to the client.
                </div>
                <li><b>Singleton Beans</b></li>
                <div>
                    //TODO..?
                </div>
            </ul>
        </div>
        <div class="sub-heading">Introspection</div>
        <div class="textual-content">
            Introspection is the automatic process of analyzing a bean's design patterns to reveal the bean's
            properties, events, and methods. This process controls the publishing and discovery of bean operations and
            properties.
            <br>
            There are two ways in which the developer of a Bean can indicate which of its properties, events, and
            methods should be exposed. With the first method, simple naming conventions are used. These allow the
            introspection mechanisms to infer information about a Bean. In the second way, an additional class that
            extends the <code>BeanInfo</code> interface is provided that explicitly supplies this information.
            <br>
            The introspection mechanism finds all of the public methods of a Bean. Protected and private methods are not
            presented.
        </div>
        <div class="sub-heading">Design Pattern for Properties</div>
        <div class="textual-content">
            A <i>property</i> is a subset of a Bean’s state. The values assigned to the properties determine the
            behavior and
            appearance of that component. A property is set through a setter method. A property is obtained by a getter
            method. <a href="https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html">There are two
            types of properties:</a>
            <ul>
                <li><b>Simple</b>:
                    A simple property has a single value. It can be identified by the following design patterns, where
                    <code>N</code> is the name of the property and <code>T</code> is its type:
                    <br>
                    <code>public T getN()</code>
                    <br>
                    <code>public void setN(T arg)</code>
                    <br>
                    A read/write property has both of these methods to access its values. A read-only property has only
                    a get method. A write-only property has only a set method.
                </li>
                <li><b>Indexed</b>:
                    An indexed property consists of multiple values. It can be identified by the following design
                    patterns, where <code>N</code> is the name of the property and <code>T</code> is its type:
                    <br>
                    <code>public T getN(int index);</code>
                    <br>
                    <code>public void setN(int index, T value);</code>
                    <br>
                    <code>public T[] getN();</code>
                    <br>
                    <code>public void setN(T values[]);</code>
                    <br>
                </li>
            </ul>
        </div>
        <div class="sub-heading">Design Pattern for Events</div>
        <div>
            Beans use the delegation event model that was discussed earlier in this book. Beans can generate events and
            send them to other objects. These can be identified by the following design patterns, where <code>T</code>
            is the type of the event:
            <br>
            <code>public void addTListener(TListener eventListener)</code>
            <br>
            <code>public void addTListener(TListener eventListener) throws java.util.TooManyListenersException</code>
            <br>
            <code>public void removeTListener(TListener eventListener)</code>
            <br>
            These methods are used to add or remove a listener for the specified event. The version of
            <code>addTListener()</code> that does not throw an exception can be used to <i>multicast</i> an event, which
            means that more than one listener can register for the event notification. The version that throws <code>TooManyListenersException</code>
            <i>unicasts</i> the event, which means that the number of listeners can be restricted to one. In either
            case, <code>removeTListener()</code> is used to remove the listener.
            <br>
            //TODO: Example code of how to actually use a listener to listen for an event and take action based on it.
        </div>
    </div>
    <hr>
    <div id="head-first">
        These are my notes from the book - Head First: Servlets and JSP
    </div>
    <div>
        Index:
        <br>
        <a href="#Ch1">Chapter 1: Why use Servlets and JSPs</a>
        <br>
        <a href="#Ch2">Chapter 2: Web App Architecture</a>
        <br>
        <a href="#Ch3">Chapter 3: Mini MVC Tutorial</a>
    </div>
    <div id="Ch1" class="chapter">Chapter 1: Why use Servlets and JSPs</div>
    <div class="textual-content">
        - To prevent deployment problems that come with building stand alone apps, we instead deploy our apps to the
        browser.
        <div class="row">
            <img src="./Snaps/Servers_And_Clients.PNG" class="center-block img-fluid" alt="Servers_And_Clients"
                 width="500">
        </div>
        <br>
        Terminology:
        <ul>
            <li><b>Web Server</b>:
                A web browser lets a user request a resource. The web server receives the request, finds the resource,
                and
                then sends it back to the user. A resource can be anything - HTML page, image, PDF File. If the
                requested
                resource is not found, the server replies with a <code>404-Not Found</code> error code.
                <br>
                - A web server can refer to either the physical machine (hardware) or the web server application
                (software).
            </li>
            <li><b>Web Client</b>:
                Both the human and the browser application (Mozilla, Chrome) being used are referred to as the Web
                Client. A
                web browser can communicate with the web server. It can interpret the HTML code that is send as a part
                of
                the server's response and render that web page. Hence a Web Client (browser) lets the user request
                something
                from the server and shows the user the result of that request.
            </li>
            <li><b>HTML</b>: When a server answers a request, the server usually sends some type of content for the
                browser to
                display. This content is written in HTML.
                <br>
                - Two important tags in HTML are:
                <code>form</code> and <code>input</code>
                <div class="code-snippet">
                    <script src="https://gist.github.com/rgbk21/7ccd6f864eb2faf71f645955dfe6c4d2.js"></script>
                </div>
            </li>
            <li><b>HTTP</b>: Most of the conversations held on the web between clients and servers are held using HTTP
                Protocol, which allows for simple request- response type conversations. The client sends an
                <code>HTTP Request</code> and the Server responds with a <code>HTTP Response</code>.
                <br>
                HTTP runs on top of TCP/IP. The structure of and HTTP conversation is a simple Request/Response.
                <br><b>Key elements of the request stream are:</b>
                <ul>
                    <li>HTTP Method Name(the action to be performed): The method name tells the server the kind of
                        request that is being made, and how the rest of the message will be formatted. The
                        <code>HTTP</code> protocol has several methods, but we mostly use <code>GET</code> and <code>POST</code>
                        methods.
                        <ul>
                            <li><code>GET</code>: Gets a resource (HTML page, image, file,..) from the server and sends
                                it back to the Client. You can also send some data with a <code>GET</code> request, but
                                this is not recommended. Firstly, because the number of characters that are sent via a
                                <code>GET</code> request are limited and secondly all the data sent in a
                                <code>GET</code> request is visible in the URL. The "?" separates the path and the
                                parameters. Together, the entire String is the request that is the URL that is sent with
                                the request.
                                <div class="row">
                                    <img src="./Snaps/GET_REQUEST.PNG" class="center-block img-fluid" alt="GET_REQUEST"
                                         width="600">
                                </div>
                            </li>
                            <li><code>POST</code>: With POST, you can request something and at the same time send form
                                data to the server. For eg., if the user has completed a long form, you want this data
                                to be stored into a database. In this case you would use a <code>POST</code> method. The
                                data to be sent back to the server is known as the "payload" or the "message body".
                                <div class="row">
                                    <img src="./Snaps/POST_REQUEST.PNG" class="center-block img-fluid"
                                         alt="POST_REQUEST"
                                         width="600">
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li>The page to access (a URL)</li>
                    <li>Form parameters (like arguments to a method). These are sometimes also called "query strings"
                    </li>
                </ul>


                <b>Key elements of the response are:</b>
                <ul>
                    <li>A status code (for whether the request was successful)</li>
                    <li>Content-type (text, picture, HTML). Also known as MIME type</li>
                    <li>The actual content</li>
                </ul>
                <div>
                    <img src="./Snaps/HTTP_RESPONSE.PNG" class="center-block img-fluid" alt="HTTP_RESPONSE"
                         width="600">
                </div>
                - An HTTP response can contain HTML. HTTP adds a Header to the response generated by the server. This
                Header information helps the client process the response. Inside this response can be a
                <code>&lthtml&gt&lt/html&gt </code> that the client then renders as the HTML page that we finally see.
                <br>
            </li>
            <b>All the pieces in one page:</b>
            <div class="row">
                <img src="./Snaps/All-The-Pieces.PNG" class="float-left img-fluid" alt="All-The-Pieces"
                     width="500">
            </div>
            <b>What is a URL</b>:
            <div class="row">
                <img src="./Snaps/Whta_Is_URL.PNG" class="float-left img-fluid" alt="What_Is_URL"
                     width="500">
            </div>
            <div>
                <b>What is a TCP Port</b>:
                <br>
                A TCP port is a 16-bit number that uniquely identifies the software that is running
                on the hardware. They are NOT physical ports on a system. They are just numbers representing an
                applications. As per the standard, the HTTP Server Software runs on Port 80. Without port numbers, the
                Server would have no way of telling which application/software a Client wants to connect to.
                <br>
                - There are a bunch of other ports that are pre-defined to connect to specific services.
            </div>
            <div>
                <b>Two things the Server won't do on its own:</b>
                <ul>
                    <li>Dynamic Content: The Web Server Application serves only static pages, but a spearate "helper"
                        application that the web server can communicate with can build non-static, just-in-time web
                        pages.
                        Just-in-time web pages do not exist before the request comes in. Once the request comes in, the
                        helper app "writes" the HTML and the web server sends the page back to the Client as if it were
                        a
                        static web page.
                    </li>
                    <li>Saving data on the Server: A WEb Server cannot process form data. When the web server sees a
                        request
                        for a helper app, it assumes that all of the parameters are emant for the Helper app and hence
                        passes all of the parameters to it
                    </li>
                </ul>
            </div>
            <div>
                <b>What is a Servlet? And what is JSP?</b>
                <br>
                - The Helper App in Java is known as a Servlet. So a Servlet is just some Java code. But when the web
                server
                calls the helper Servlet, it expects HTML code in return. This is done by using using the <code>PrintWriter.println()</code>
                method. The HTML code that is to be returned to the web server is included as a <code>String</code> type
                argument in the <code>println()</code> method. As you can hope, stuffing properly formatted HTML tags
                into
                the <code>println()</code>is not a viable solution. For eg. you will have to manually escape every quote
                character (") because Java treats them as end of string character. And HTML happens to use a ton of
                quotes
                to specify the attribute values and what not.
                <br>
                - To solve this problem, JSPs were introduced. This allows us to add Java code to HTML instead of
                writing
                HTML code in a Java class. The JSP page contains java variables that calls the main Java code and
                creates
                the completed HTML page as a JIT web page.
                <br>
            </div>
        </ul>
    </div>
    <div id="Ch2" class="chapter">Chapter 2: Web App Architecture</div>
    <div class="textual-content">
        <div>
            <b>What is a Container?</b>
            <br>
            - Servlets don't have a <code>main()</code> method. They are under the control of another Java application
            known as the <code>Container</code>.
            <br>
            - Apache is you web server application. Tomcat is your Container. When your web server application gets a
            request for a <code>Servlet</code> (as opposed to, say, a plain static HTML page) the server hands the
            request not to the servlet itself, but to the <code>Container</code> in which the servlet is <i>deployed</i>.
            <br>
            - It's the Container that gives the Servlet the HTTP Request and Response, and it's the Container that calls
            the servlet's methods like <code>doGet()</code> and <code>doPost()</code>.
            <div class="row">
                <img src="./Snaps/Ch2/ContainerDescription.PNG" class="center-block img-fluid"
                     alt="ContainerDescription"
                     width="500">
            </div>
        </div>
        <div>
            <b>What does the Container give you?</b>
            <br>
            <ul>
                <li><b>Communication Support</b>: The Container(Tomcat) provides an easy way for your Servlets to talk
                    to your Web
                    Server. You don't have to build a ServerSocket, listen on a port, create Streams, etc. The Container
                    knows the protocol between the Web Server and itself, so that your Servlet does not have to worry
                    about, say, the API between the Apache Web Server and your own web application code.
                </li>
                <li><b>Lifecycle Management:</b> The Container controls the life and death of you servlets. It takes
                    control of loading the classes, instantiating and initializing the servlets, invoking the servlets
                    methods, and making servlets instances available for garbage collection. With the Container in
                    control, you do not have to worry about the resource management.
                </li>
                <li>
                    <b>Multithreading Support:</b> The COntianer automatically creates a new Java thread for every
                    servlet request that it receives. When the Servlet's done running the HTTP <code>service()</code>
                    method for that Client's request, the thread completes (dies). But you are still responsible for
                    Thread safety and other synchronization issues. It's just that the work involved in creating and
                    deleting threads is reduced.
                </li>
                <li>
                    <b>Declarative Security:</b> XML Deployment Descriptors allow you to configure Security without
                    having to hard-code it into any of your servlets or other classes.
                </li>
                <li><b>JSP Support: </b></li>
                Container also takes care of translating the JSP code into real Java.
            </ul>
        </div>
        <div>
            <b>How the Container handles a request: </b>
            <br>
            <b>Step 1: </b> User clicks on a link that has a URL to a servlet instead of a static web page
            <div class="row">
                <img src="./Snaps/Ch2/Step-1.PNG" class="float-left img-fluid"
                     alt="Step1"
                     width="500">
            </div>
            <b>Step 2: </b> The Container "sees" that the request is for a Servlet, so the container creates two
            objects:
            <ul>
                <li>HttpServletRequest</li>
                <li>HttpServletResponse</li>
            </ul>
            <div class="row">
                <img src="./Snaps/Ch2/Step-2.PNG" class="float-left img-fluid"
                     alt="Step2"
                     width="500">
            </div>
            <b>Step 3: </b> The Container finds the correct Servlet based on the URL in the request, creates or
            allocates a thread for that request, and passes the request and response objects to the Servlet thread.
            <div class="row">
                <img src="./Snaps/Ch2/Step-3.PNG" class="float-left img-fluid"
                     alt="Step3"
                     width="500">
            </div>
            <b>Step 4: </b> The Container calls the Servlet's <code>service()</code> method. Depending on the type of
            the request, the <code>service()</code> methods calls either the <code>doGet()</code> or
            <code>doPost()</code> methods. For this example, we assume that the request was a HTTP GET method.
            <div class="row">
                <img src="./Snaps/Ch2/Step-4.PNG" class="float-left img-fluid"
                     alt="Step4"
                     width="500">
            </div>
            <b>Step 5: </b> The <code>doGet()</code> method generates the dynamic page and stuffs the page into the
            response object. Remember that the Container still has a reference to the Response object.
            <div class="row">
                <img src="./Snaps/Ch2/Step-5.PNG" class="float-left img-fluid"
                     alt="Step5"
                     width="500">
            </div>
            <b>Step 6: </b> The thread completes, the container converts the response object into an HTTP Response,
            sends it back to the client, and then deletes the request and the response object.
            <div class="row">
                <img src="./Snaps/Ch2/Step-6.PNG" class="float-left img-fluid"
                     alt="Step6"
                     width="500">
            </div>
        </div>

        <div>
            <b>What makes a Servlet a Servlet: </b>
            <br>
            Note that a Servlet class (in this case <code>Ch2Servlet</code>) does not have a <code>main()</code> method.
            It only has a <code>doGet()</code> method.
            <div class="row">
                <img src="./Snaps/Ch2/AServletIsAServlet.PNG" class="float-left img-fluid"
                     alt="Servlet?"
                     width="600">
            </div>
        </div>

        <div>
            <b>When a Client clicks on a URL containing a Servlet in Step 1, how does the Container know which Servlet
                to call?</b>
            <br>
            A Servlet can have 3 names:
            <ul>
                <li>Public URL Name: The name encoded into the HTML so that when the user clicks a link that is supposed
                    to go to that servlet, this public URL is sent to the Server in the HTTP Request.
                </li>
                <li>File Path Name (XXXX.class name): This (XXXX) is the ACTUAL name of the .class file that is stored
                    on the server.
                </li>
                <li>Deployment Name: It is a secret internal name (not known to the Client) that is given to the .class
                    file. This <i>can</i> be the same as the File Path Name, but can be something completely different
                    as well.
                </li>
            </ul>
            - Thus we can <i>map</i> the Public URL to a Deployment name and have that Deployment name refer to a .class
            file.
            <br>
            - Why do we do this:
            <ul>
                <li>Flexibility: We can change the path of the .class file without breaking the path of every file that
                    referenced this class file
                </li>
                <li>Security: We do not want the Client ot know the internal directory structure of the Server.</li>
            </ul>
        </div>

        <div>
            <b>How do we do this mapping: Deployment Descriptors</b>
            <br>
            When you deploy your servlet into your web Container, you will create an XML document called the
            <code>Deployment Descriptor</code> to tell the container how to run your Servlets and JSPs.
            <br>
            - We use two XML elements to map URLs to Servlets - one to map the Client-known <i>Public URL Name</i> to
            our
            own <i>internal deployment name</i>, and the other to map our own <i>internal deployment name</i> to the
            fully-qualified <i>class-name</i>
            <br>
            - The two DD elements for URL Mappings are:
            <ul>
                <li><code>&ltservlet&gt</code>: maps internal name to fully-qualified class name</li>
                <li><code>&ltservlet-mapping&gt</code>: maps internal name public URL name</li>
            </ul>
            - DD also helps us to customize other aspects of our web application like adding security roles, error
            pages, tag libraries. All this can be done without changing the source code.
            <div class="row">
                <img src="./Snaps/Ch2/DeploymetnDescriptor.PNG" class="float-left img-fluid"
                     alt="DeploymentDescriptor"
                     width="650">
            </div>
            - Note that the <code>&ltservlet-class&gt</code> tag still contains only the class name and not the complete
            path of the the .class file. This is because the Container has a specific place that it will look for all
            Servlets for which you have specified a mapping in the DD.
        </div>

        <div>
            <b>What is MVC: Media-View-Controller</b>
            <br>
            - The essence of MVC is that you separate the business logic from the presentation, but put something in <i>between</i>
            them so that the business logic can stand on its own as a reusable Java class, and doesn't have to know
            anything about the view. In other words, the business logic should never go into the Servlet. Because the
            Servlet contains the JSP page, it means that the business logic is tied to the JSP page. We cannot re-use
            the business logic for some other kind of view, like a GUI. The business logic should always be in a
            standalone Java class that can be reused.
            <br>
            - Model-View-Controller takes the business logic out of the Servlet and puts it in a "Model" - a reusable
            plain old Java class. The Model is a combination of the business data and the methods that operate on the
            data.

            <div class="row">
                <img src="./Snaps/Ch2/MVC.PNG" class="float-left img-fluid"
                     alt="MVC"
                     width="650">
            </div>
            - Thus for each Servlet, there will be a new business logic class that will be the <code>Model</code>, a JSP
            page that will be the <code>View</code>, and the original Servlet, bereft of any logic or HTML, that will
            form
            the <code>Controller</code> part of the puzzle.
            <div class="row">
                <img src="./Snaps/Ch2/MVC-IN-Action.PNG" class="float-left img-fluid"
                     alt="MVC"
                     width="650">
            </div>
            - But now the problem is that there are a gazillion little Servlets, and all they are doing is updating the
            Model and then displaying the View. Lot of code duplication apparently...
        </div>
        <div class="row">
            <img src="./Snaps/Ch2/Table.PNG" class="center-block img-fluid"
                 alt="Table"
                 width="650">
        </div>
        <div>
            <b>How doe J2EE fit into all of this?</b>
            <br>
            The Java 2 Enterprise Edition is kind of a super-spec - it incorporates other specifications, including the
            Servlets 2.4 Spec and the JSP 2.0 spec. That's for the Web Container. But the J2EE 1.4 spec also includes
            the Enterprise JavaBean 2.1 specification, for the EJB Container. In other words, the web container is for
            the <i>web</i> components (servlets and JSPs) whereas the EJB COntainer is for the <i>business</i>
            components.
            <br>
            - A fully-compliant J2EE server must have <i>both</i> a web Container abd an EJB Container (plus other
            things including a JNDI and JMS implementation). Tomcat is just a web Container!(?). It is still compliant
            with the portions of J2EE spec that address the web container.
        </div>
    </div>
    <div id="Ch3" class="chapter">Chapter 3: Mini MVC Tutorial</div>
    <div class="textual-content">
        The process for creating a <a
            href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-ee-application.html#3f8fcb52">Enterprise
        Application in IntelliJ</a> can be found here.
        <div>
            <p id="app_architecture">Here is the architecture of the Web App:</p>
            <div class="row">
                <img src="./Snaps/Ch3/MyBeerApp-Architecture.PNG" class="center-block img-fluid"
                     alt="MyBeerApp-Architecture"
                     width="750">
            </div>
        </div>
        <div>
            <p><b>Creating the Development Environment:</b></p>
            <p>
                -<code>index.jsp</code> is the file that contains the first page that the user sees when they login into
                the <code>http://localhost:8080/BeerV2_war_exploded/</code>. Changing the name of <code>index.jsp</code>
                to some other name causes the app to stop working for some reason.
                <br>
                - The <code>web.xml</code> is the Deployment Descriptor that we looked at in the previous chapter.
            </p>
            <div class="row">
                <img src="./Snaps/Ch3/Development-Environment.png" class="center-block img-fluid"
                     alt="Development-Environment"
                     width="1000">
            </div>
        </div>
        <div class="code-snippet">
            <p>This is an example of Tomcat Log generated when the Web-App was deployed successfully. </p>
            <script src="https://gist.github.com/rgbk21/d37b5c60853094b332ce7a976dc94161.js"></script>
        </div>
        <div>
            <b>Creating the Deployment Environment:</b>
            <div class="row">
                <img src="./Snaps/Ch3/Deployment-Environment.png" class="center-block img-fluid"
                     alt="Deployment-Environment"
                     width="1100">
            </div>
        </div>
        Let's finish the app now, one step at a time:
        <br>
        <div>
            <a href="#app_architecture"><b>Step 1</b></a>: The Client makes a request for the form.html page
            <br>
            <a href="#app_architecture"><b>Step 2</b></a>: The Container retrieves the form.html page
            <br>
            <a href="#app_architecture"><b>Step 3</b></a>: The Container returns the page to the browser where the user
            answers the question on the form
            and
            Clicks Submit
            <div class="row">
                <img src="./Snaps/Ch3/Form.PNG" class="float-left img-fluid"
                     alt="Form"
                     width="400">
            </div>
            <br>
            Clicking the SUBMIT button causes the HTML form to send a <code>POST</code> request to the server. This
            request is sent to the <code>SelectBeer.do</code> file (Line 9). Remember that there is no actual class
            named such.
            It's mapped to an internal Servlet name using the Deployment Descriptors.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/455e078ee0d33fe25ef7e6e215deb3c5.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 4</b></a>: The browser sends the request data to the Container
            <br>
            Now the Container has to figure out which is the actual Class to which the <code>SelectBeer.do</code> maps.
            For this, the Container looks in the <code>web.xml</code> file (Deployment Descriptor). The Container finds
            out that the <code>SelectBeer.do</code> file maps to the <code>Ch3 Beer</code> internal name, which in turn
            maps to the <code>com.example.web.BeerSelect</code> Java Class. Now the Container knows which Servlet to
            call.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/c932fc1d0153401e578ea9037ed0b428.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 5</b></a>: The Container finds the correct Servlet and passes the
            request to the Servlet. This class
            acts as the Controller, calling the Model <code>BeerExpert</code> for the business logic, and the View
            <code>result.jsp</code> for the reponse.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/94dbb35d88a6d04c4f1f44c75f1e8d18.js"></script>
            </div>
            <br>
            <a href="#app_architecture"><b>Step 6</b></a>: The Servlet calls the BeerExpert class for help.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/f2f3e7794dd719fc9f752776ed97e16b.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 7</b></a>: The BeerExpert class returns an answer that the Servlet class
            adds to the request
            object.
            <br>
            The Container provides a mechanism called "Request Dispatching" that allows one container-manged component
            to call another container-managed component. This is what we use here - the Servlet gets the info from the
            model, saves it in the request object, then dipatches the request to the JSP.
            <br>
            <a href="#app_architecture"><b>Step 8</b></a>: The Servlet forwards the request to the JSP.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/0cf2bcafb2f011b8ca5a9bbcded5d011.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 9</b></a>: The JSP gets the answer from the request object.
            <br>
            <a href="#app_architecture"><b>Step 10</b></a>: The JSP generates a page for the Container.
            <br>
            <a href="#app_architecture"><b>Step 11</b></a>: The Container returns the page to the User.


        </div>

    </div>
</div>


</body>
</html>
