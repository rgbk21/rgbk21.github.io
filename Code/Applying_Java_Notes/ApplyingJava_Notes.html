<!DOCTYPE html>
<html>
<head>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="ApplyingJava_Notes.css">
    <meta name="keywords" content="Java, Floats, Overflow, Unboxing, Autoboxing">
    <meta name="author" content="Raj Gaurav Ballabh Kumar">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applying Java - Notes</title>
</head>

<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">

    <div class="navbar-header">
        <a href="../../index.html" class="navbar-brand"> rgbk21</a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"><span
            class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="nav navbar-nav">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Projects/TwitterCritNodes/TwitterCritNodes_1.html">Identifying
                        Critical Nodes on Twitter</a>
                    <a class="dropdown-item" href="../../Projects/isRelatedTo/isRelatedTo.html">isRelatedTo</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    HTML Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../ImageGallery/ImageGallery.html">Image Gallery</a>
                    <a class="dropdown-item" href="../../RGB_Guesser_Game/RGB.html">RGB Guesser Game</a>
                    <a class="dropdown-item" href="../../ToDoList/todo.html">To-Do List</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Notes
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../COMS_631/COMS_631_index.html">COMS 631</a>
                    <a class="dropdown-item" href="../../COMS_535/COMS_535_index.html">COMS 535</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Code
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Code/ThingsToRemember/ThingsToRemember.html">Things To
                        Remember</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes.html">Java Notes</a>
                    <a class="dropdown-item" href="../../Code/Applying_Java_Notes/ApplyingJava_Notes.html">ApplyingJava
                        Notes</a>
                    <a class="dropdown-item" href="../../Code/Spring/Spring.html">Spring Notes</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    In Another Life
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../InAnotherLife/Chapter1.html">Chapter 1</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
        </ul>


        <ul class="navbar-nav ml-auto">
            <li class="nav-item active"><a class="nav-link" href="https://github.com/rgbk21">GitHub</a></li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.linkedin.com/in/raj-gaurav-ballabh-kumar-97002058/">LinkedIn</a>
            </li>
            <li class="nav-item active"><a class="nav-link" href="https://www.instagram.com/wobblyframes/">Instagram</a>
            </li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.facebook.com/SomeRandomThoughts">Facebook</a></li>
        </ul>

    </div>
</nav>

<div class="container">
    <div>
        This page mainly contains my notes from a) Java: The Complete Reference, and b) <a href="#head-first">Head
        First: Servlets and JSP</a>
    </div>

    <hr>
    <div class="chapter">Chapter 34: Java Beans</div>
    <hr>
    <div class="textual-content">

        <div class="sub-heading">What is a Java Bean</div>
        <div class="textual-content">
            - A <i>Java Bean</i> is a software content that has been designed to be reusable in a variety of different
            environments. There is no restriction in the capability (in terms of complexity) of a Java Bean. A bean may
            perform a simple function or a complicated function.
            <br>
            - At a basic level, <a
                href="https://stackoverflow.com/questions/21866571/difference-between-javabean-and-spring-bean">JavaBeans
            are simply Java classes</a> which adhere to certain coding conventions.
            Specifically, classes that have:
            <ul>
                <li><code>public</code> default (no argument) constructors</li>
                <li>allow access to their properties using accessor (getter and setter) methods</li>
                <li>implement <code>java.io.Serializable</code></li>
                <li>all JavaBean instance variables should be private</li>
            </ul>
        </div>
        <div class="sub-heading">What is the difference between a Java Bean and a POJO</div>
        <div class="textual-content">
            - A JavaBean follows <a
                href="https://stackoverflow.com/questions/1394265/what-is-the-difference-between-a-javabean-and-a-pojo">certain
            conventions</a>. Getter/setter naming, having a public default constructor, being
            serializable etc. See <a href="https://docstore.mik.ua/orelly/java-ent/jnut/ch06_02.htm">JavaBeans
            Conventions</a> for more details.
            <br>
            - A POJO (plain-old-Java-object) isn't rigorously defined. It's a Java object that doesn't have a
            requirement
            to implement a particular interface or derive from a particular base class, or make use of particular
            annotations in order to be compatible with a given framework, and can be any arbitrary (often relatively
            simple) Java object.
            <br>
            - All JavaBeans are POJOs but not all POJOs are JavaBeans.
        </div>
        <div class="sub-heading">What is the difference between a Java Bean and a Spring Bean</div>
        <div class="textual-content">
            - A Spring bean is basically an object managed by Spring. More specifically, it is an object that is
            instantiated, configured and otherwise managed by a Spring Framework container. Spring beans are defined in
            Spring configuration files (or, more recently, with annotations), instantiated by Spring containers, and
            then injected into applications.
            <br>
            - Note that Spring beans need not always be JavaBeans. Spring beans might not implement the
            <code>java.io.Serializable</code> interface, can have arguments in their constructors, etc.
            This is the very basic difference between JavaBeans and Spring beans.
            <br>
            - <a href="http://www.shaunabram.com/beans-vs-pojos/">The reason Spring managed objects are referred to as
            beans</a> is because in the very early versions, Spring was
            intended only for use with JavaBeans. That is no longer the case of course: Spring can manage just about any
            object, even if it doesn’t have JavaBean type characteristics such as default constructors or mutator
            methods (getters and setters). None the less, the term ‘Spring beans’ has stuck.
            Can Spring beans be POJOs? Yes, and they usually are (although they don’t have to be – e.g. Spring can be
            used with ‘heavyweight’ Java objects, such as EJBs).
            Can Spring beans be JavaBeans? As I have said, yes and again they often are but don’t have to be.
        </div>
        <div class="sub-heading"><a
                href="https://stackoverflow.com/questions/3461199/what-is-the-advantage-of-using-java-beans">Advantages
            of a Bean</a></div>
        <div class="textual-content">
            A JavaBean on its own is not terribly interesting, it's just a Java class that conforms to some standards.
            However, conformance with this standard is one of the pillars on which the Java EE
            framework is built and it comes up in quite a few places. FYI, there are a few different types of EJB listed
            below:
            <ul>
                <li><b>Entity Beans</b>:</li>
                <div>You might want to read/write objects to/from an underlying database. You could use JDBC/SQL to do
                    this but you could also use a persistance framework. The Java EE spec includes a spec for
                    persistance whereby you declare your class to be an "entity bean" and have Java automatically
                    generate database tables and logic to map between entries in your database and objects in your
                    program. The actual implementation is provided by a lower level library such as Eclipselink,
                    Toplink, Hibernate etc. but the Java API abstracts away any differences between them.
                    <br>
                    Session beans represent logic while entity beans represented persistent objects. <a
                            href="https://stackoverflow.com/a/13501659/8742428">These days entity
                        beans aren't used anymore in favour to JPA entities.</a>
                </div>
                <li><b>Stateful Session Beans</b></li>
                <div>
                    Imagine that you want to create an instance of a Java class which exists on separate JVM. The JVMs
                    might be running on the same physical machine but equally, may be on separate machines communicating
                    over a network. Using a Java EE application server, you can create a class which can be instantiated
                    by clients of the app server. These clients can instantiate a class which will act just like a
                    normal object but any methods that are invoked on the object get executed on the server with the
                    results being passed back to the caller. It's basically an object oriented form of remote procedure
                    calls.
                </div>
                <li><b>Stateless Session Beans</b></li>
                <div>
                    This is a minor variation on stateful session beans. With stateful beans, if the server has 1000
                    clients then it will potentially have to create 1000 instances of the bean and remember which
                    instance belongs to which client. With stateless beans, the server creates a pool of beans and
                    doesn't bother to remember which client owns which bean. When a client invokes a method, the server
                    picks a bean from the pool and uses it, returning it to the pool on completion. You use stateful
                    session beans when you want the server to remember details about each client, you will use stateless
                    beans when you don't need to remember client specific details. Note that the stateless beans may
                    well have state, it's just that this state won't be of interest to the client.
                </div>
                <li><b>Singleton Beans</b></li>
                <div>
                    //TODO..?
                </div>
            </ul>
        </div>
        <div class="sub-heading">Introspection</div>
        <div class="textual-content">
            Introspection is the automatic process of analyzing a bean's design patterns to reveal the bean's
            properties, events, and methods. This process controls the publishing and discovery of bean operations and
            properties.
            <br>
            There are two ways in which the developer of a Bean can indicate which of its properties, events, and
            methods should be exposed. With the first method, simple naming conventions are used. These allow the
            introspection mechanisms to infer information about a Bean. In the second way, an additional class that
            extends the <code>BeanInfo</code> interface is provided that explicitly supplies this information.
            <br>
            The introspection mechanism finds all of the public methods of a Bean. Protected and private methods are not
            presented.
        </div>
        <div class="sub-heading">Design Pattern for Properties</div>
        <div class="textual-content">
            A <i>property</i> is a subset of a Bean’s state. The values assigned to the properties determine the
            behavior and
            appearance of that component. A property is set through a setter method. A property is obtained by a getter
            method. <a href="https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html">There are two
            types of properties:</a>
            <ul>
                <li><b>Simple</b>:
                    A simple property has a single value. It can be identified by the following design patterns, where
                    <code>N</code> is the name of the property and <code>T</code> is its type:
                    <br>
                    <code>public T getN()</code>
                    <br>
                    <code>public void setN(T arg)</code>
                    <br>
                    A read/write property has both of these methods to access its values. A read-only property has only
                    a get method. A write-only property has only a set method.
                </li>
                <li><b>Indexed</b>:
                    An indexed property consists of multiple values. It can be identified by the following design
                    patterns, where <code>N</code> is the name of the property and <code>T</code> is its type:
                    <br>
                    <code>public T getN(int index);</code>
                    <br>
                    <code>public void setN(int index, T value);</code>
                    <br>
                    <code>public T[] getN();</code>
                    <br>
                    <code>public void setN(T values[]);</code>
                    <br>
                </li>
            </ul>
        </div>
        <div class="sub-heading">Design Pattern for Events</div>
        <div>
            Beans use the delegation event model that was discussed earlier in this book. Beans can generate events and
            send them to other objects. These can be identified by the following design patterns, where <code>T</code>
            is the type of the event:
            <br>
            <code>public void addTListener(TListener eventListener)</code>
            <br>
            <code>public void addTListener(TListener eventListener) throws java.util.TooManyListenersException</code>
            <br>
            <code>public void removeTListener(TListener eventListener)</code>
            <br>
            These methods are used to add or remove a listener for the specified event. The version of
            <code>addTListener()</code> that does not throw an exception can be used to <i>multicast</i> an event, which
            means that more than one listener can register for the event notification. The version that throws <code>TooManyListenersException</code>
            <i>unicasts</i> the event, which means that the number of listeners can be restricted to one. In either
            case, <code>removeTListener()</code> is used to remove the listener.
            <br>
            //TODO: Example code of how to actually use a listener to listen for an event and take action based on it.
        </div>
    </div>

    <hr>
    <div class="chapter">Chapter 35: Introducing Servlets</div>
    <hr>

    <div class="textual-content">
        <div class="sub-heading">The javax.servlet Package</div>
        <div>
            The javax.servlet package contains a number of interfaces and classes that establish the framework in which
            servlets operate.
            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Interface</th>
                    <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Servlet</td>
                    <td>Declares the life cycle methods for a Servlet</td>
                </tr>
                <tr>
                    <td>ServletConfig</td>
                    <td>Allows Servlets to get intiialization parameters</td>
                </tr>
                <tr>
                    <td>ServletContext</td>
                    <td>Enables servlets to log events and access information about their environment</td>
                </tr>
                <tr>
                    <td>ServletRequest</td>
                    <td>Used to read data froma Client Request</td>
                </tr>
                <tr>
                    <td>Servlet Response</td>
                    <td>Used to write data to a Client Response</td>
                </tr>
                </tbody>
            </table>

            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Class</th>
                    <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>GenericServlet</td>
                    <td>Implements the <code>Servlet</code> and the <code>ServletConfig</code> interfaces</td>
                </tr>
                <tr>
                    <td>ServletInputStream</td>
                    <td>Encapsulates an input stream for reading requests from a client</td>
                </tr>
                <tr>
                    <td>ServletOutputStream</td>
                    <td>Encapsulates an output stream for writing response to a Client</td>
                </tr>
                <tr>
                    <td>ServletException</td>
                    <td>Indicates a Servlet error occurred</td>
                </tr>
                <tr>
                    <td>UnavailableException</td>
                    <td>Indicates a Servlet is Unavailable</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="sub-heading">The Servlet Interface</div>
        <div>
            - Defines methods that all servlets must implement.
            <br>
            - A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests
            from Web clients, usually across HTTP, the HyperText Transfer Protocol.
            <br>
            - To implement this interface, you can write a generic servlet that extends <code>javax.servlet.GenericServlet</code>
            or an
            HTTP servlet that extends <code>javax.servlet.http.HttpServlet</code>.
            <br>
            - This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from
            the server. These are known as life-cycle methods and are called in the following sequence:
            <br>
            1) The servlet is constructed, then initialized with the init method.
            <br>
            2) Any calls from clients to the service method are handled.
            <br>
            3) The servlet is taken out of service, then destroyed with the destroy method, then garbage collected and
            finalized.
            <br>
            - In addition to the life-cycle methods, this interface provides the <code>getServletConfig</code> method,
            which the
            servlet can use to get any startup information, and the <code>getServletInfo</code> method, which allows the
            servlet to
            return basic information about itself, such as author, version, and copyright.
        </div>
        <br>

        <table class="table table-bordered table-sm">
            <thead>
            <tr>
                <th>Method</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>void init(ServletConfig sc) throws ServletException</td>
                <td>Called when the Servlet is initialized. Initialization parameters for the Servlet can be obtained
                    from the sc. A ServletExce[tion should be thrown if the Servlet cannot be intiialized
                </td>
            </tr>
            <tr>
                <td>void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</td>
                <td>Called to process a request from the Client. The request from the clint can be read from req, the
                    response to the client can be written to res. An exception is generated if if a servlet or IO
                    problem occurs.
                </td>
            </tr>
            <tr>
                <td>void destroy()</td>
                <td>Called when the Servlet is unloaded from the memory</td>
            </tr>
            <tr>
                <td>String getServletInfo()</td>
                <td>Returns a String describing the Servlet</td>
            </tr>
            <tr>
                <td>ServletConfig getServletConfig()</td>
                <td>Returns a ServletConfig object that contains any initialization parameters</td>
            </tr>
            </tbody>
        </table>

        <div class="sub-heading">The ServletConfig Interface</div>
        <div>
            - A servlet configuration object used by a servlet container to pass information to a servlet during
            initialization.

        </div>

        <div class="sub-heading">The ServletContext Interface</div>
        <div>
            - The <code>ServletContext</code> object is contained within the <code>ServletConfig</code> object, which
            the Web server provides the servlet when the servlet is initialized.
            <br>
            - This interface defines a set of methods that a servlet uses to communicate with its servlet container, for
            example, to get
            the MIME type of a file, dispatch requests, or write to a log file.
            <br>
            - There is one context per "web application" per Java Virtual Machine. (A "web application" is a collection
            of
            servlets and content installed under a specific subset of the server's URL namespace such as /catalog and
            possibly installed via a .war file.
        </div>

        <div class="sub-heading">The ServletRequest Interface</div>
        <div>
            - Defines an object to provide client request information to a servlet.
            <br>
            - The servlet container creates a ServletRequest object and passes it as an argument to the servlet's
            service method.
            <br>
            - A ServletRequest object provides data including parameter name and values, attributes, and an input
            stream.
            Interfaces that extend <code>ServletRequest</code> can provide additional protocol-specific data (for
            example, HTTP data
            is provided by <code>HttpServletRequest</code>.
        </div>

        <div class="sub-heading">The ServletResponse Interface</div>
        <div>
            - Defines an object to assist a servlet in sending a response to the client.
            <br>
            - The servlet container creates a <code>ServletResponse</code> object and passes it as an argument to the
            servlet's service method.
            <br>
            - To send binary data in a MIME body response, use the <code>ServletOutputStream</code> returned by <code>getOutputStream()</code>.
            To send character data, use the <code>PrintWriter</code> object returned by <code>getWriter()</code>. To mix
            binary and text data, for example, to create a multipart response, use a <code>ServletOutputStream</code>
            and manage the character sections manually.
        </div>

        <div class="sub-heading">The GenericServlet Class</div>
        <div>
            - Defines a generic, protocol-independent servlet. To write an HTTP servlet for use on the Web, extend
            <code>HttpServlet</code> instead.
            <br>
            - <code>GenericServlet</code> implements the <code>Servlet</code> and <code>ServletConfig</code> interfaces.
            .
        </div>

        <div class="sub-heading">The javax.servlet.http Package</div>
        <div>
            - The preceding examples have used the classes and interfaces defined in javax.servlet. However, when
            working with HTTP, you will normally use the interfaces and classes in <code>javax.servlet.http</code>.
            <br>
            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Interface</th>
                    <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>HttpServletRequest</td>
                    <td>Extends the <code>ServletRequest</code> interface to enable servlets to read data from the HTTP
                        Request
                    </td>
                </tr>
                <tr>
                    <td>HttpServletResponse</td>
                    <td>Extends the <code>ServletResponse</code> interface to enable servlets to write data to an HTTP
                        response
                    </td>
                </tr>
                <tr>
                    <td>HttpSession</td>
                    <td>Provides a way to identify a user across more than one page request or visit to a Web site and
                        to store information about that user.
                    </td>
                </tr>
                </tbody>
            </table>

            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Class</th>
                    <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Cookie</td>
                    <td>Allows state information to be stored ona Client machine
                    </td>
                </tr>
                <tr>
                    <td>HttpServlet</td>
                    <td>Provides methods to handle HTTP requests and responses.
                    </td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="sub-heading">The HttpServletRequest Interface</div>
        <div>
            - Extends the <code>ServletRequest</code> interface to provide request information for HTTP servlets.
            <br>
            - The servlet container creates an <code>HttpServletRequest</code> object and passes it as an argument to
            the servlet's service methods (doGet, doPost, etc).
            <br>
            - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html">Java EE Link to
            the methods</a>
        </div>

        <div class="sub-heading">The HttpServletResponse Interface</div>
        <div>
            - Extends the <code>ServletResponse</code> interface to provide HTTP-specific functionality in sending a
            response. For example, it has methods to access HTTP headers and cookies.
            <br>
            - The servlet container creates an <code>HttpServletResponse</code> object and passes it as an argument to
            the servlet's service methods (doGet, doPost, etc).
            <br>
            - Several constants are defined that correspond to the different status codes that can be assigned to a HTTP
            Response.
            <br>
            - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html">Java EE Link to
            the methods</a>
        </div>

        <div class="sub-heading">The HttpSession Interface</div>
        <div>
            - Provides a way to identify a user across more than one page request or visit to a Web site and to store
            information about that user.
            <br>
            - The servlet container uses this interface to create a session between an HTTP client and an HTTP server.
            The session persists for a specified time period, across more than one connection or page request from the
            user. A session usually corresponds to one user, who may visit a site many times. The server can maintain a
            session in many ways such as using cookies or rewriting URLs.
            <br>
            - This interface allows servlets to:
            <ul>
                <li>View and manipulate information about a session, such as the session identifier, creation time, and
                    last accessed time
                </li>
                <li>Bind objects to sessions, allowing user information to persist across multiple user connections</li>
            </ul>
            - //<b>TODO:</b>
            <br>
            - When an application stores an object in or removes an object from a session, the session checks whether
            the object implements <code>HttpSessionBindingListener</code>. If it does, the servlet notifies the object
            that it has
            been bound to or unbound from the session. Notifications are sent after the binding methods complete. For
            session that are invalidated or expire, notifications are sent after the session has been invalidated or
            expired.
            <br>
            - When container migrates a session between VMs in a distributed container setting, all session attributes
            implementing the <code>HttpSessionActivationListener</code> interface are notified.
            <br>
            - A servlet should be able to handle cases in which the client does not choose to join a session, such as
            when cookies are intentionally turned off. Until the client joins the session, <code>isNew</code> returns
            true. If the client chooses not to join the session, <code>getSession</code> will return a different session
            on each request, and <code>isNew</code> will always return true.
            <br>
            - Session information is scoped only to the current web application (<code>ServletContext</code>), so
            information stored in one context will not be directly visible in another.
            <br>
            - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html">Java EE Link to
            the methods</a>
        </div>

        <div class="sub-heading">The Cookie Class</div>
        <div>
            - The Cookie class encapsulates a cookie. A cookie is stored on a client and contains state information.
            <br>
            - Cookies are valuable for tracking user activities. For example, assume that a user visits an online store.
            A cookie can save the user’s name, address, and other information. The user does not need to enter this data
            each time he or she visits the store.
            <br>
            - A servlet can write a cookie to a user’s machine via the <code>addCookie()</code> method of the <code>HttpServletResponse</code>
            interface. The data for that cookie is then included in the header of the HTTP response that is sent to the
            browser. The names and values of cookies are stored on the user’s machine.
            <br>
            - Some of the information that can be saved for each cookie includes the following:
            <ul>
                <li>The name of the cookie</li>
                <li>The value of the cookie</li>
                <li>The expiration date of the cookie</li>
                <li>The domain and path of the cookie</li>
            </ul>
            - The expiration date determines when this cookie is deleted from the user’s machine. If an expiration date
            is not explicitly assigned to a cookie, it is deleted when the current browser session ends.
            <br>
            - The domain and path of the cookie determine when it is included in the header of an HTTP request. If the
            user enters a URL whose domain and path match these values, the cookie is then supplied to the web server.
            Otherwise, it is not.
            <br>
            - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html">Java EE Link to
            the methods</a>
        </div>

        <div class="sub-heading">The HttpServlet Class</div>
        <div>
            - The <code>HttpServlet</code> class extends <code>GenericServlet</code>. It is commonly used when
            developing servlets that receive and process HTTP requests.
            <br>
            - Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site. A subclass
            of <code>HttpServlet</code> must override at least one method, usually one of these:
            <ul>
                <li><code>doGet</code>, if the servlet supports HTTP GET requests</li>
                <li><code>doPost</code>, for HTTP POST requests</li>
                <li><code>doPut</code>, for HTTP PUT requests</li>
                <li><code>doDelete</code>, for HTTP DELETE requests</li>
                <li><code>init</code> and <code>destroy</code>, to manage resources that are held for the life of the
                    servlet
                </li>
                <li><code>getServletInfo</code>, which the servlet uses to provide information about itself</li>
            </ul>
            - There's almost no reason to override the <code>service</code> method. service handles standard HTTP
            requests by dispatching them to the handler methods for each HTTP request type (the doXXX methods listed
            above).
            Likewise, there's almost no reason to override the <code>doOptions</code> and <code>doTrace</code> methods.
            <br>
            - Servlets typically run on multi-threaded servers, so be aware that a servlet must handle concurrent
            requests and be careful to synchronize access to shared resources. Shared resources include in-memory data
            such as instance or class variables and external objects such as files, database connections, and network
            connections.
            <br>
            - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">Java EE Link to
            the methods</a>
        </div>

        <div class="sub-heading">Using Cookies</div>
        <div>
            //TODO: There is an example in the book that you have to code
        </div>

        <div class="sub-heading">Session Tracking</div>
        <div>
            - HTTP is a stateless protocol. Each request is independent of the previous one. However, in some
            applications, it is necessary to save state information so that information can be collected from several
            interactions between a browser and a server. Sessions provide such a mechanism.
            <br>
            - A session can be created via the <code>getSession()</code> method of <code>HttpServletRequest</code>. An
            <code>HttpSession</code> object is returned. This object can store a set of bindings that associate names
            with objects. The <code>setAttribute()</code>,
            <code>getAttribute()</code>, <code>getAttributeNames()</code>, and <code>removeAttribute()</code> methods of
            <code>HttpSession</code> manage these bindings. Session state is shared by all servlets that are associated
            with a client.
        </div>

        <div class="row">
            <img src="./Snaps/Notatbility.png" class="center-block img-fluid"
                 alt="Step1"
                 width=100%>
        </div>


    </div>
    <hr>
    <div id="head-first">
        These are my notes from the book - Head First: Servlets and JSP
    </div>
    <div>
        Index:
        <br>
        <a href="#Ch1">Chapter 1: Why use Servlets and JSPs</a>
        <br>
        <a href="#Ch2">Chapter 2: Web App Architecture</a>
        <br>
        <a href="#Ch3">Chapter 3: Mini MVC Tutorial</a>
        <br>
        <a href="#Ch4">Chapter 4: Request and Response - Being a Servlet</a>
        <br>
        <a href="#Ch5">Chapter 5: Attributes and Listeners - Being a Servlet</a>
        <br>
        <a href="#Ch6">Chapter 6: Session Management - Conversational State</a>
        <br>
        <a href="#Ch7">Chapter 7: Using JSP - Being a JSP</a>
        <br>
        <a href="#Ch8">Chapter 8: Scriptless JSP - Script-free pages</a>
        <br>


    </div>
    <hr>
    <div id="Ch1" class="chapter">Chapter 1: Why use Servlets and JSPs</div>
    <hr>
    <div class="textual-content">
        - To prevent deployment problems that come with building stand alone apps, we instead deploy our apps to the
        browser.
        <div class="row">
            <img src="./Snaps/Servers_And_Clients.PNG" class="center-block img-fluid" alt="Servers_And_Clients"
                 width="500">
        </div>
        <br>
        Terminology:
        <ul>
            <li><b>Web Server</b>:
                A web browser lets a user request a resource. The web server receives the request, finds the resource,
                and
                then sends it back to the user. A resource can be anything - HTML page, image, PDF File. If the
                requested
                resource is not found, the server replies with a <code>404-Not Found</code> error code.
                <br>
                - A web server can refer to either the physical machine (hardware) or the web server application
                (software).
            </li>
            <li><b>Web Client</b>:
                Both the human and the browser application (Mozilla, Chrome) being used are referred to as the Web
                Client. A
                web browser can communicate with the web server. It can interpret the HTML code that is sent as a part
                of
                the server's response and render that web page. Hence a Web Client (browser) lets the user request
                something
                from the server and shows the user the result of that request.
            </li>
            <li><b>HTML</b>: When a server answers a request, the server usually sends some type of content for the
                browser to
                display. This content is written in HTML.
                <br>
                - Two important tags in HTML are:
                <code>form</code> and <code>input</code>
                <div class="code-snippet">
                    <script src="https://gist.github.com/rgbk21/7ccd6f864eb2faf71f645955dfe6c4d2.js"></script>
                </div>
            </li>
            <li><b>HTTP</b>: Most of the conversations held on the web between clients and servers are held using HTTP
                Protocol, which allows for simple request-response type conversations. The client sends an
                <code>HTTP Request</code> and the Server responds with a <code>HTTP Response</code>.
                <br>
                HTTP runs on top of TCP/IP. The structure of and HTTP conversation is a simple Request/Response.
                <br><b>Key elements of the request stream are:</b>
                <ul>
                    <li>HTTP Method Name(the action to be performed): The method name tells the server the kind of
                        request that is being made, and how the rest of the message will be formatted. The
                        <code>HTTP</code> protocol has several methods, but we mostly use <code>GET</code> and <code>POST</code>
                        methods.
                        <ul>
                            <li><code>GET</code>: Gets a resource (HTML page, image, file,..) from the server and sends
                                it back to the Client. You can also send some data (from the Client to the Server) with
                                a <code>GET</code> request, but
                                this is not recommended. Firstly, because the number of characters that are sent via a
                                <code>GET</code> request are limited and secondly all the data sent in a
                                <code>GET</code> request is visible in the URL. The "?" separates the path and the
                                parameters. Together, the entire String is the request that is the URL that is sent with
                                the request.
                                <div class="row">
                                    <img src="./Snaps/GET_REQUEST.PNG" class="center-block img-fluid" alt="GET_REQUEST"
                                         width="600">
                                </div>
                            </li>
                            <li><code>POST</code>: With POST, you can request something and at the same time send form
                                data to the server. For eg., if the user has completed a long form, you want this data
                                to be stored into a database. In this case you would use a <code>POST</code> method. The
                                data to be sent back to the server is known as the "payload" or the "message body".
                                <div class="row">
                                    <img src="./Snaps/POST_REQUEST.PNG" class="center-block img-fluid"
                                         alt="POST_REQUEST"
                                         width="600">
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li>The page to access (a URL)</li>
                    <li>Form parameters (like arguments to a method). These are sometimes also called "query strings"
                    </li>
                </ul>


                <b>Key elements of the response are:</b>
                <ul>
                    <li>A status code (for whether the request was successful)</li>
                    <li>Content-type (text, picture, HTML). Also known as MIME type</li>
                    <li>The actual content</li>
                </ul>
                <div>
                    <img src="./Snaps/HTTP_RESPONSE.PNG" class="center-block img-fluid" alt="HTTP_RESPONSE"
                         width="600">
                </div>
                - An HTTP response can contain HTML. HTTP adds a Header to the response generated by the server. This
                Header information helps the client process the response. Inside this response can be a
                <code>&lthtml&gt&lt/html&gt </code> that the client then renders as the HTML page that we finally see.
                <br>
            </li>
        </ul>
        <b>All the pieces in one page:</b>
        <div class="row">
            <img src="./Snaps/All-The-Pieces.PNG" class="float-left img-fluid" alt="All-The-Pieces"
                 width="500">
        </div>
        <b>What is a URL</b>:
        <div class="row">
            <img src="./Snaps/Whta_Is_URL.PNG" class="float-left img-fluid" alt="What_Is_URL"
                 width="500">
        </div>
        <div>
            <b>What is a TCP Port</b>:
            <br>
            A TCP port is a 16-bit number that uniquely identifies the software that is running
            on the hardware. They are NOT physical ports on a system. They are just numbers representing an
            applications. As per the standard, the HTTP Server Software runs on Port 80. Without port numbers, the
            Server would have no way of telling which application/software a Client wants to connect to.
            <br>
            - There are a bunch of other ports that are pre-defined to connect to specific services.
        </div>
        <div>
            <b>Two things the Server won't do on its own:</b>
            <ul>
                <li>Dynamic Content: The Web Server Application serves only static pages, but a separate "helper"
                    application that the web server can communicate with can build non-static, just-in-time web
                    pages.
                    Just-in-time web pages do not exist before the request comes in. Once the request comes in, the
                    helper app "writes" the HTML and the web server sends the page back to the Client as if it were
                    a
                    static web page.
                </li>
                <li>Saving data on the Server: A Web Server cannot process form data. When the web server sees a
                    request
                    for a helper app, it assumes that all of the parameters are meant for the Helper app and hence
                    passes all of the parameters to it.
                </li>
            </ul>
        </div>
        <div>
            <b>What is a Servlet? And what is JSP?</b>
            <br>
            - The Helper App in Java is known as a Servlet. So a Servlet is just some Java code. But when the web
            server
            calls the helper Servlet, it expects HTML code in return. This is done by using using the <code>PrintWriter.println()</code>
            method. The HTML code that is to be returned to the web server is included as a <code>String</code> type
            argument in the <code>println()</code> method. As you can hope, stuffing properly formatted HTML tags
            into
            the <code>println()</code>is not a viable solution. For eg. you will have to manually escape every quote
            character (") because Java treats them as end of string character. And HTML happens to use a ton of
            quotes
            to specify the attribute values and what not.
            <br>
            - To solve this problem, JSPs were introduced. This allows us to add Java code to HTML instead of
            writing
            HTML code in a Java class. The JSP page contains java variables that calls the main Java code and
            creates
            the completed HTML page as a JIT web page.
            <br>
        </div>

    </div>

    <hr>
    <div id="Ch2" class="chapter">Chapter 2: Web App Architecture</div>
    <hr>
    <div class="textual-content">
        <div>
            <b>What is a Container?</b>
            <br>
            - Servlets don't have a <code>main()</code> method. They are under the control of another Java application
            known as the <code>Container</code>.
            <br>
            - Apache is you web server application. Tomcat is your Container. When your web server application gets a
            request for a <code>Servlet</code> (as opposed to, say, a plain static HTML page) the server hands the
            request not to the servlet itself, but to the <code>Container</code> in which the servlet is <i>deployed</i>.
            <br>
            - It's the Container that gives the Servlet the HTTP Request and Response, and it's the Container that calls
            the servlet's methods like <code>doGet()</code> and <code>doPost()</code>.
            <div class="row">
                <img src="./Snaps/Ch2/ContainerDescription.PNG" class="center-block img-fluid"
                     alt="ContainerDescription"
                     width="500">
            </div>
        </div>
        <div>
            <b>What does the Container give you?</b>
            <br>
            <ul>
                <li><b>Communication Support</b>: The Container(Tomcat) provides an easy way for your Servlets to talk
                    to your Web
                    Server. You don't have to build a ServerSocket, listen on a port, create Streams, etc. The Container
                    knows the protocol between the Web Server and itself, so that your Servlet does not have to worry
                    about, say, the API between the Apache Web Server and your own web application code.
                </li>
                <li><b>Lifecycle Management:</b> The Container controls the life and death of you servlets. It takes
                    control of loading the classes, instantiating and initializing the servlets, invoking the servlets
                    methods, and making servlets instances available for garbage collection. With the Container in
                    control, you do not have to worry about the resource management.
                </li>
                <li>
                    <b>Multithreading Support:</b> The Container automatically creates a new Java thread for every
                    servlet request that it receives. When the Servlet's done running the HTTP <code>service()</code>
                    method for that Client's request, the thread completes (dies). But you are still responsible for
                    Thread safety and other synchronization issues. It's just that the work involved in creating and
                    deleting threads is reduced.
                </li>
                <li>
                    <b>Declarative Security:</b> XML Deployment Descriptors allow you to configure Security without
                    having to hard-code it into any of your servlets or other classes.
                </li>
                <li><b>JSP Support: </b></li>
                Container also takes care of translating the JSP code into real Java.
            </ul>
        </div>
        <div>
            <b>How the Container handles a request: </b>
            <br>
            <b>Step 1: </b> User clicks on a link that has a URL to a servlet instead of a static web page
            <div class="row">
                <img src="./Snaps/Ch2/Step-1.PNG" class="float-left img-fluid"
                     alt="Step1"
                     width="500">
            </div>
            <b>Step 2: </b> The Container "sees" that the request is for a Servlet, so the container creates two
            objects:
            <ul>
                <li>HttpServletRequest</li>
                <li>HttpServletResponse</li>
            </ul>
            <div class="row">
                <img src="./Snaps/Ch2/Step-2.PNG" class="float-left img-fluid"
                     alt="Step2"
                     width="500">
            </div>
            <b>Step 3: </b> The Container finds the correct Servlet based on the URL in the request, creates or
            allocates a thread for that request, and passes the request and response objects to the Servlet thread.
            <div class="row">
                <img src="./Snaps/Ch2/Step-3.PNG" class="float-left img-fluid"
                     alt="Step3"
                     width="500">
            </div>
            <b>Step 4: </b> The Container calls the Servlet's <code>service()</code> method. Depending on the type of
            the request, the <code>service()</code> methods calls either the <code>doGet()</code> or
            <code>doPost()</code> methods. For this example, we assume that the request was a HTTP GET method.
            <div class="row">
                <img src="./Snaps/Ch2/Step-4.PNG" class="float-left img-fluid"
                     alt="Step4"
                     width="500">
            </div>
            <b>Step 5: </b> The <code>doGet()</code> method generates the dynamic page and stuffs the page into the
            response object. Remember that the Container still has a reference to the Response object.
            <div class="row">
                <img src="./Snaps/Ch2/Step-5.PNG" class="float-left img-fluid"
                     alt="Step5"
                     width="500">
            </div>
            <b>Step 6: </b> The thread completes, the container converts the response object into an HTTP Response,
            sends it back to the client, and then deletes the request and the response object.
            <div class="row">
                <img src="./Snaps/Ch2/Step-6.PNG" class="float-left img-fluid"
                     alt="Step6"
                     width="500">
            </div>
        </div>

        <div>
            <b>What makes a Servlet a Servlet: </b>
            <br>
            Note that a Servlet class (in this case <code>Ch2Servlet</code>) does not have a <code>main()</code> method.
            It only has a <code>doGet()</code> method.
            <div class="row">
                <img src="./Snaps/Ch2/AServletIsAServlet.PNG" class="float-left img-fluid"
                     alt="Servlet?"
                     width="600">
            </div>
        </div>

        <div>
            <b>When a Client clicks on a URL containing a Servlet in Step 1, how does the Container know which Servlet
                to call?</b>
            <br>
            A Servlet can have 3 names:
            <ul>
                <li>Public URL Name: The name encoded into the HTML so that when the user clicks a link that is supposed
                    to go to that servlet, this public URL is sent to the Server in the HTTP Request.
                </li>
                <li>File Path Name (XXXX.class name): This (XXXX) is the ACTUAL name of the .class file that is stored
                    on the server.
                </li>
                <li>Deployment Name: It is a secret internal name (not known to the Client) that is given to the .class
                    file. This <i>can</i> be the same as the File Path Name, but can be something completely different
                    as well.
                </li>
            </ul>
            - Thus we can <i>map</i> the Public URL to a Deployment name and have that Deployment name refer to a .class
            file.
            <br>
            - Why do we do this:
            <ul>
                <li>Flexibility: We can change the path of the .class file without breaking the path of every file that
                    referenced this class file
                </li>
                <li>Security: We do not want the Client to know the internal directory structure of the Server.</li>
            </ul>
        </div>

        <div>
            <b>How do we do this mapping: Deployment Descriptors</b>
            <br>
            When you deploy your servlet into your web Container, you will create an XML document called the
            <code>Deployment Descriptor</code> to tell the container how to run your Servlets and JSPs.
            <br>
            - We use two XML elements to map URLs to Servlets - one to map the Client-known <i>Public URL Name</i> to
            our
            own <i>internal deployment name</i>, and the other to map our own <i>internal deployment name</i> to the
            fully-qualified <i>class-name</i>
            <br>
            <b>//TODO:</b> Where is the DD file stored in the IntelliJ project that we created?
            <br>
            - The two DD elements for URL Mappings are:
            <ul>
                <li><code>&ltservlet&gt</code>: maps internal name to fully-qualified class name</li>
                <li><code>&ltservlet-mapping&gt</code>: maps internal name to public URL name</li>
            </ul>
            - DD also helps us to customize other aspects of our web application like adding security roles, error
            pages, tag libraries. All this can be done without changing the source code.
            <div class="row">
                <img src="./Snaps/Ch2/DeploymetnDescriptor.PNG" class="float-left img-fluid"
                     alt="DeploymentDescriptor"
                     width="650">
            </div>
            - Note that the <code>&ltservlet-class&gt</code> tag still contains only the class name and not the complete
            path of the the .class file. This is because the Container has a specific place that it will look for all
            Servlets for which you have specified a mapping in the DD.
        </div>

        <div>
            <b>What is MVC: Model-View-Controller</b>
            <br>
            - The essence of MVC is that you separate the business logic from the presentation, but put something in <i>between</i>
            them so that the business logic can stand on its own as a reusable Java class, and doesn't have to know
            anything about the view. In other words, the business logic should never go into the Servlet. Because the
            Servlet contains the JSP page, it means that the business logic is tied to the JSP page. We cannot re-use
            the business logic for some other kind of view, like a GUI. The business logic should always be in a
            standalone Java class that can be reused.
            <br>
            - Model-View-Controller takes the business logic out of the Servlet and puts it in a "Model" - a reusable
            plain old Java class. The Model is a combination of the business data and the methods that operate on the
            data.

            <div class="row">
                <img src="./Snaps/Ch2/MVC.PNG" class="float-left img-fluid"
                     alt="MVC"
                     width="650">
            </div>
            - Thus for each Servlet, there will be a new business logic class that will be the <code>Model</code>, a JSP
            page that will be the <code>View</code>, and the original Servlet, bereft of any logic or HTML, that will
            form
            the <code>Controller</code> part of the puzzle.
            <div class="row">
                <img src="./Snaps/Ch2/MVC-IN-Action.PNG" class="float-left img-fluid"
                     alt="MVC"
                     width="650">
            </div>
            - But now the problem is that there are a gazillion little Servlets, and all they are doing is updating the
            Model and then displaying the View. Lot of code duplication apparently...
        </div>
        <div class="row">
            <img src="./Snaps/Ch2/Table.PNG" class="center-block img-fluid"
                 alt="Table"
                 width="650">
        </div>
        <div>
            <b>How does J2EE fit into all of this</b>
            <br>
            The Java 2 Enterprise Edition is kind of a super-spec - it incorporates other specifications, including the
            Servlets 2.4 Spec and the JSP 2.0 spec. That's for the Web Container. But the J2EE 1.4 spec also includes
            the Enterprise JavaBean 2.1 specification, for the EJB Container. In other words, the web container is for
            the <i>web</i> components (servlets and JSPs) whereas the EJB Container is for the <i>business</i>
            components.
            <br>
            - A fully-compliant J2EE server must have <i>both</i> a web Container and an EJB Container (plus other
            things including a JNDI and JMS implementation). Tomcat is just a web Container!(?). It is still compliant
            with the portions of J2EE spec that address the web container.
        </div>
    </div>

    <hr>
    <div id="Ch3" class="chapter">Chapter 3: Mini MVC Tutorial</div>
    <hr>
    <div class="textual-content">
        The process for creating a <a
            href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-ee-application.html#3f8fcb52">Enterprise
        Application in IntelliJ</a> can be found here.
        <div>
            <p id="app_architecture">Here is the architecture of the Web App:</p>
            <div class="row">
                <img src="./Snaps/Ch3/MyBeerApp-Architecture.PNG" class="center-block img-fluid"
                     alt="MyBeerApp-Architecture"
                     width="750">
            </div>
        </div>
        <div>
            <p><b>Creating the Development Environment:</b></p>
            <p>
                -<code>index.jsp</code> is the file that contains the first page that the user sees when they login into
                the <code>http://localhost:8080/BeerV2_war_exploded/</code>. Changing the name of <code>index.jsp</code>
                to some other name causes the app to stop working for some reason.
                <br>
                - The <code>web.xml</code> is the Deployment Descriptor that we looked at in the previous chapter.
            </p>
            <div class="row">
                <img src="./Snaps/Ch3/Development-Environment.png" class="center-block img-fluid"
                     alt="Development-Environment"
                     width="1000">
            </div>
        </div>
        <div class="code-snippet">
            <p>This is an example of Tomcat Log generated when the Web-App was deployed successfully. </p>
            <script src="https://gist.github.com/rgbk21/d37b5c60853094b332ce7a976dc94161.js"></script>
        </div>
        <div>
            <b>Creating the Deployment Environment:</b>
            <div class="row">
                <img src="./Snaps/Ch3/Deployment-Environment.png" class="center-block img-fluid"
                     alt="Deployment-Environment"
                     width="1100">
            </div>
        </div>
        Let's finish the app now, one step at a time:
        <br>
        <div>
            <a href="#app_architecture"><b>Step 1</b></a>: The Client makes a request for the form.html page
            <br>
            <a href="#app_architecture"><b>Step 2</b></a>: The Container retrieves the form.html page
            <br>
            <a href="#app_architecture"><b>Step 3</b></a>: The Container returns the page to the browser where the user
            answers the question on the form
            and
            Clicks Submit
            <div class="row">
                <img src="./Snaps/Ch3/Form.PNG" class="float-left img-fluid"
                     alt="Form"
                     width="400">
            </div>
            <br>
            Clicking the SUBMIT button causes the HTML form to send a <code>POST</code> request to the server. This
            request is sent to the <code>SelectBeer.do</code> file (Line 9). Remember that there is no actual class
            named such.
            It's mapped to an internal Servlet name using the Deployment Descriptors.
            <div id="Step3" class="code-snippet">
                <script src="https://gist.github.com/rgbk21/455e078ee0d33fe25ef7e6e215deb3c5.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 4</b></a>: The browser sends the request data to the Container
            <br>
            Now the Container has to figure out which is the actual Class to which the <code>SelectBeer.do</code> maps.
            For this, the Container looks in the <code>web.xml</code> file (Deployment Descriptor). The Container finds
            out that the <code>SelectBeer.do</code> file maps to the <code>Ch3 Beer</code> internal name, which in turn
            maps to the <code>com.example.web.BeerSelect</code> Java Class. Now the Container knows which Servlet to
            call.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/c932fc1d0153401e578ea9037ed0b428.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 5</b></a>: The Container finds the correct Servlet and passes the
            request to the Servlet. This class
            acts as the Controller, calling the Model <code>BeerExpert</code> for the business logic, and the View
            <code>result.jsp</code> for the response.
            <div id="setAttributeExample" class="code-snippet">
                <script src="https://gist.github.com/rgbk21/94dbb35d88a6d04c4f1f44c75f1e8d18.js"></script>
            </div>
            <br>
            <a href="#app_architecture"><b>Step 6</b></a>: The Servlet calls the BeerExpert class for help.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/f2f3e7794dd719fc9f752776ed97e16b.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 7</b></a>: The BeerExpert class returns an answer that the Servlet class
            adds to the request
            object.
            <br>
            The Container provides a mechanism called "Request Dispatching" that allows one container-manged component
            to call another container-managed component. This is what we use here - the Servlet gets the info from the
            model, saves it in the request object, then dipatches the request to the JSP.
            <br>
            <a href="#app_architecture"><b>Step 8</b></a>: The Servlet forwards the request to the JSP.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/0cf2bcafb2f011b8ca5a9bbcded5d011.js"></script>
            </div>
            <a href="#app_architecture"><b>Step 9</b></a>: The JSP gets the answer from the request object.
            <br>
            <a href="#app_architecture"><b>Step 10</b></a>: The JSP generates a page for the Container.
            <br>
            <a href="#app_architecture"><b>Step 11</b></a>: The Container returns the page to the User.


        </div>

    </div>

    <hr>
    <div id="Ch4" class="chapter">Chapter 4: Request and Response - Being a Servlet</div>
    <hr>
    <div class="textual-content">
        - In the <a href="#app_architecture">previous chapter</a> we looked at the Container's overall role in the
        Servlet's life. In this Chapter we look at the Servlet's life in more detail.
        <br>
        - The servlet lifecycle is pretty simple.. There is only one main state: <code>initialized</code>. If the
        servlet
        isn't initialized then it is either <i>being initialized</i> (by running it's constructor or the
        <code>init()</code> method), <i>being destroyed</i> (by running it's <code>destroy()</code>) method, or it
        simply does not exist.

        <br><br>
        <b>What do the <code>init</code>, <code>service</code>, and <code>destroy</code> methods do?</b>
        <br>
        - <b><code>init()</code></b>: The method is
        called after the servlet instance has been created (using the the default
        no-args constructor) but before the servlet can service any client requests. You can override this method in
        case you have to get a database connection, or you have to register yourself with other objects.
        <br>
        - <b><code>service()</code></b>: When the first Client request comes in, the Container starts a new thread or
        allocates
        a new thread from the pool and causes the servlet's <code>service()</code> method to be invoked. This method
        looks at the request, determines the HTTP method (GET, POST, etc.) and invokes the matching <code>doGet()</code>
        or <code>doPost()</code> methods respectively. Note that there are other methods in HTTP as well (HEAD, PUT,
        etc) and there are corresponding <code>doXXXXX()</code> methods for almost all of them. Refer the <code>HttpServlet</code>
        class below. You should not override the <code>service()</code> method. Your job is to override the <code>doGet()</code>
        or the <code>doPost()</code> methods, and let the <code>service()</code> implementation from the <code>HttpServlet</code>
        worry about calling the right one.
        <br>
        - <b><code>doPost()</code>/<code>doGet()</code></b>: The <code>service()</code> method invokes the
        <code>doGet()</code>
        or the <code>doPost()</code> based on the HTTP method (GET, POST, and so on). This is where your code begins.
        All the stuff that your app is supposed to be doing goes in here. Always override at least one of these methods.
        Whichever ones you override tells the Container what you support. If you do not override <code>doPost()</code>,
        for example, then you are telling the Container that this servlet does not support the HTTP POST request.
        <br>
        <div class="row">
            <img src="./Snaps/Ch4/Servlet_LifeCycle.PNG" class="float-left img-fluid"
                 alt="Servlet_LifeCycle"
                 width="700">
        </div>


        - The Servlet moves from the <i>does not exist</i> to the <i>initialized</i> state beginning with the
        constructor. But the constructor makes only the <i>object</i>, not the <i>Servlet</i>. When an object becomes a
        servlet,it gets all the unique privileges that come with being a servlet, like the ability to use it's <code>ServletContext</code>
        to get information from the Container.

        <br> <br>

        - So overall the process proceeds like this: (refer below diagram) Suppose my servlet is the
        <code>MyServlet</code> class. The Container
        calls <code>MyServlet</code>'s <code>init()</code> method. But if I do not
        override <code>init</code>, the one from <code>GenericServlet</code> runs. Then when a request comes in, the
        Container starts or allocates a thread and calls the <code>service()</code> method, which I do not override. So
        the <code>service</code> method from the <code>HttpServlet</code> runs. The <code>HttpServlet</code> <code>service</code>
        method then calls my overridden <code>doGet</code> or <code>doPost</code> methods. <i>So each time my
        <code>doGet</code> or <code>doPost</code> runs in a different thread.</i>
        <br>
        - The Servlet inherits the following methods:
        <div class="row">
            <img src="./Snaps/Ch4/Servlet_Inheritance.PNG" class="float-left img-fluid"
                 alt="Servlet_Inheritance"
                 width="700">
        </div>
        <br>
        - Remember that each Client request runs in a separate thread. At any given time, you will have at least as many
        runnable threads as there are client requests.
        <br>
        - You might hear things like "Each instance of the servlet..". This is incorrect. The Container runs multiple
        threads to process multiple requests to a single servlet. And every Client request generates a new pair of
        request and response object.
        <div class="row">
            <img src="./Snaps/Ch4/Threaded.PNG" class="float-left img-fluid"
                 alt="Threaded"
                 width="700">
        </div>
        <br>
        <b>What is a Request or a Response object: </b>
        <br>
        - The implementation of these interfaces is left to the vendor. All you need to know is the methods that you can
        call on these objects. The actual class does not matter because you are referring to the request and the
        response objects only by the <i>interface type</i>.
        <br>
        - Also note that these are interfaces extending interfaces.
        <div class="row">
            <img src="./Snaps/Ch4/ServletRequest_And_ServletResponse.PNG" class="float-left img-fluid"
                 alt="Servlet_Inheritance"
                 width="700">
        </div>
        <br>
        - There are 8 HTTP methods (actually 9 now). There is no mechanism in the servlet API for handling <code>doConnect</code>,
        so it is not a part of the <code>HttpServlet</code>.
        <br>
        - Recall the difference between <code>GET</code> and <code>POST</code> that we studied earlier. The key
        difference between the two was
        that <code>POST</code> has a body, whereas in the <code>GET</code> request all of the parameters are sent in the
        header. Remember that <code>GET</code>is ONLY supposed to be <i>getting</i> things from the server. it should
        not make any changes to the server. <code>POST</code> on the other hand is used to send data to the server for
        <i>update</i>.
        <br>
        - This makes <code>GET</code> an <i>idempotent</i> request: making the same <code>GET</code> request twice will
        cause no negative consequences on the server.
        <br>
        - <code>POST</code>, on the other hand, is a <i>non-idempotent</i> request. The data sent to the server could be
        used to update some state that cannot be reversed. Think a financial transaction that cannot be reversed.
        Intuitive example in book.
        Basically, you want to ensure that your app logic can handle scenario where the same request comes in more than
        once by mistake.
        <br>
        - Note that there is nothing stopping you from <i>implementing</i> the <code>GET</code> method in the <code>doGet</code>
        method as an non-idempotent method. But you would not want to do so...
        <div class="sub-heading">What determines whether a browser sends a GET or POST request:</div>
        <div>
            - Remember the POST is not the default. If you do not specify a method, by default the GET method will be
            used.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/c4c574f87a7a6aaa46631a5a7d9559bb.js"></script>
            </div>
        </div>

        <div class="sub-heading">How do you send multiple parameters using the POST request:</div>
        <div>
            - In the previous POST request that we sent in <a href="#Step3">Step 3</a>, the browser sent only one of
            the four options (light/amber/brown/dark) as the value of the parameter <code>color1</code>. But what if we
            wanted two or more parameters from the user. This is how we would do it:
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/6d7be68624a849802d8450ff82db8b01.js"></script>
            </div>
            - If in the previous case the POST request sent the values of the parameters as <code>color1=light</code>,
            in
            this example the parameters will be sent as <code>color1=light&theSize=heavy</code>. That is - the POST
            request will have both the parameters but separated by an ampersand.
            <br>
            - The Servlet class would then use the parameters in the following manner:
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/09cd12cd78f61d4a703ff0397484e00e.js"></script>
            </div>
        </div>

        <div class="sub-heading">How do you use multiple values for a single parameter:</div>
        <div>
            In the previous example, you one parameter <code>theSize</code> associated with just a single value (either
            light, medium, or heavy). However, some form inputs like checkboxes can have more than one value. That means
            a single parameter like <code>theSize</code> will could have more than one value depending on how many boxes
            the user has checked off.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/b143430a62b757498607e22deabee83f.js"></script>
            </div>
            And the corresponding Servlet class would look like this:
            <div id="usingSetAttribute" class="code-snippet">
                <script src="https://gist.github.com/rgbk21/327108fb2c388821c78d3d711e7ff2d2.js"></script>
            </div>
        </div>

        <div class="sub-heading">Besides the parameters, what else can I get from the Request object:</div>
        <div>
            - You really should look at the full API for <a
                href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html">javax.servlet.ServletRequest</a>
            and <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html">javax.servlet.http.HttpServletRequest</a>.
            <br>
            - Remember that <code>HttpServletRequest</code> class extends the <code>ServletRequest</code> class.
            <br>
            - Note the method <code>getInputStream</code>. These streams will contain only the body of the HTTP Request
            and not the headers.
            <br>
            - Note the presence of the three different methods:
            <ul>
                <li><code>getRemotePort</code>: In this case, since it is the server asking, it's the Client that is the
                    Remote. So <code>getRemotePort</code> means the <i>Client's</i> remote port. In other words, the
                    port number on the Client from which the request was sent. Remember, if you are a servlet, remote
                    means the Client.
                </li>
                <li><code>getServerPort</code>: This method asks "to which port was the request <i>originally sent</i>"
                </li>
                <li><code>getLocalPort</code>: This method asks "on which port did the request ultimately <i>end up</i>".
                    There is a difference between the above two methods because although the requests are <i>sent</i> to
                    a single port (where the <i>server</i> is listening), the server turns around and finds a different
                    local port for each thread so that the app can handle multiple clients at the same time.
                </li>
            </ul>
        </div>
        <div class="row">
            <img src="./Snaps/Ch4/HttpSerletRequestInterface.PNG" class="float-left img-fluid"
                 alt="Servlet_Inheritance"
                 width="200">
        </div>
        <div class="sub-heading">Understanding the Response Object:</div>
        <div>
            - The Response is what goes back to the Client. Typically, you use the response object to get an output
            object (usually a Writer) and you use that Stream to write the HTML (or some other type of content) that
            goes back to the Client.
            <br>
            - You call two methods on the response: <code>setContentType</code> and <code>getWriter</code>. After that
            you are simply doing I/O to write HTML (or something else) to the stream. But you can also use the
            response to set other headers, send errors, and add cookies.
        </div>
        <div class="row">
            <img src="./Snaps/Ch4/ServletResponse_Interface.PNG" class="float-left img-fluid"
                 alt="ServletResponse_Interface"
                 width="300">
        </div>

        //TODO: There is some stuff about reading from a file and writing to a <code>application/jar</code> type stream.
        <div class="row">
            <img src="./Snaps/Ch4/WritingToAStream.PNG" class="float-left img-fluid"
                 alt="WritingToAStream"
                 width="750">
        </div>
        <div class="sub-heading">What does setting the <code>setContentType</code> do:</div>
        <div>
            <a href="https://stackoverflow.com/questions/14291027/what-is-the-use-of-response-setcontenttypetext-html-in-servlet">Source</a>
            <br>
            - Content types are included in HTTP responses because the same, byte for byte sequence of values in the
            content could be interpreted in more than one way. Remember that http can transport more than just HTML (js,
            css and images are examples), and in some cases, the receiver will not know what type of object it's
            going to receive. This is the same thing as setting the MIME type. Content type is an HTTP Header that must
            be included in the HTTP Response.
            <br>
            - Remember to always call <code>setContentType</code> before you ahve called the method that gives you your
            output stream (<code>getWRiter</code> or <code>getOutputStream</code>). That will guarantee you will not run
            into conflicts between the content type and the output stream.
            <br>
            - Common MIME types are:
            <ul>
                <li>text/html</li>
                <li>application/pdf</li>
                <li>video/quicktime</li>
                <li>application/java</li>
                <li>image/jpeg</li>
                <li>application/jar</li>
                <li>application/octet-stream</li>
                <li>application/x-zip</li>
            </ul>
        </div>

        <div class="sub-heading">What is the difference between <code>ServletOutputStream</code> and
            <code>PrintWriter</code>:
        </div>
        <div>
            <code>ServletOutputStream</code>: Provides an output stream for sending binary data to the client. A
            <code>ServletOutputStream</code> object is normally retrieved via the
            <code>ServletResponse.getOutputStream()</code> method.(Source: <a
                href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletOutputStream.html">Oracle Docs</a>)
            This is an abstract class that the servlet container implements.
            <br>
            <code>PrintWriter</code>: Prints formatted representations of objects to a text-output stream. This class
            implements all of the print methods found in PrintStream. It does not contain methods for writing raw bytes,
            for which a program should use unencoded byte streams.
            Source: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html">Oracle
            Docs</a>
            <br>
            - So: to send binary data in a MIME body response, use the ServletOutputStream returned by
            getOutputStream(). To
            send character data, use the PrintWriter object returned by getWriter(). To mix binary and text data, for
            example, to create a multipart response, use a ServletOutputStream and manage the character sections
            manually.
        </div>

        <div class="sub-heading">What is a Redirect:</div>
        <div class="row">
            <img src="./Snaps/Ch4/Redirect_1.PNG" class="float-left img-fluid"
                 alt="WritingToAStream"
                 width="600">
        </div>
        <div class="row">
            <img src="./Snaps/Ch4/Redirect_2.PNG" class="float-left img-fluid"
                 alt="WritingToAStream"
                 width="600">
        </div>
        <div class="code-snippet">
            <script src="https://gist.github.com/rgbk21/a00ec19e6297cf42b2945be730ac29de.js"></script>
        </div>

        //TODO:
        <div class="row">
            <img src="./Snaps/Ch4/TODO.PNG" class="float-left img-fluid"
                 alt="WritingToAStream"
                 width="800">
        </div>

        <div class="sub-heading">What is a Request Dispatch:</div>
        <div>
            A redirect makes the Client do the work. Whereas a Request Dispatch makes something else on the server do
            the work.
            <div class="row">
                <img src="./Snaps/Ch4/RequestDispatch.PNG" class="float-left img-fluid"
                     alt="RequestDispatch"
                     width="600">
            </div>
        </div>


    </div>

    <hr>
    <div id="Ch5" class="chapter">Chapter 5: Attributes and Listeners - Being a Servlet</div>
    <hr>
    <div class="textual-content">
        <div class="sub-heading">What are init-parameters</div>
        <div>
            - Servlets can have initialization parameters. We use the <code>&ltinit-param&gt</code> element to specify
            the name-value pairs. Note that the <code>&ltinit-param&gt&lt/init-param&gt</code> should be inside the
            <code>servlet</code> element that you want to initialize with the particular value.
            <br>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/33e00eee38b895a4439b0f2b1c78c194.js"></script>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/064f4d606995c28bf84e00f044d46a7e.js"></script>
            </div>
            - When the Container initializes a Servlet, it makes a unique <code>ServletConfig</code> for the Servlet.
            The Container reads the servlet init parameters from the DD and gives them to the <code>ServletConfig</code>,
            and then passes the <code>ServletConfig</code> to the servlet's <code>init</code> method.
            <br>
            - Note that the Servlet init parameters are read only once - when the Container initializes the Servlet.
            Once the parameters are in the <code>ServletConfig</code> they won't be read again until/unless you redeploy
            the servlet.
        </div>
        <div class="sub-heading">What are the functions of a <code>ServletConfig</code></div>
        <div>
            - A servlet configuration object used by a servlet container to pass information to a servlet during
            initialization.
            <br>
            - It has the following methods:
            <br>
            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>String getInitParameter(String name)</td>
                    <td>Gets the value of the initialization parameter with the given name.</td>
                </tr>
                <tr>
                    <td>Enumeration&ltString&gt getInitParameterNames()</td>
                    <td>Returns the names of the servlet's initialization parameters as an <code>Enumeration</code> of
                        String objects, or an empty <code>Enumeration</code> if the servlet has no initialization
                        parameters.
                    </td>
                </tr>
                <tr>
                    <td>ServletContext getServletContext()</td>
                    <td>Returns a reference to the <code>ServletContext</code> in which the caller is executing. Same as
                        running <code>this.getServletContext</code></td>
                </tr>
                <tr>
                    <td>String getServletName()</td>
                    <td>Returns the name of this servlet instance.</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="sub-heading">How can a JSP get the Servlet init parameters</div>
        <div>
            - One way is to store the init parameters using the <code>request.setAttribute</code> like we saw <a
                href="#setAttributeExample">previously</a>. <code>request.setAttribute</code> was used to pass a
            name/value pair from the Controller to the JSP, where the value could be any object.
            <br>
            - The problem is that setting a request attribute works but only for the JSP to which you forwarded the
            request. The email address is something that might be used from all over the application. If you use the
            <code>init-param</code> for this purpose, you will have to configure them in the DD for <i>every</i>
            servlet, and
            then have <i>every</i> servlet make them available to the JSP. And then if the email address changes, you
            will have to make the change in the DD for <i>every</i> Servlet again.
            <br>
            - This can avoided by using a <code>&ltcontext-param&gt</code> instead of an <code>&ltinit-param&gt</code>.
        </div>

        <div class="sub-heading">What are <code>&ltcontext-param&gt</code></div>
        <div>
            - Context init parameters work just like servlet init parameters except that context parameters are
            available
            to the <i>entire</i> web-app, not just a single servlet. So that means <i>every</i> servlet and JSP in the
            app automatically has access to the context init parameters. Also, this way when the value changes, we have
            to change it in only one place.
            <br>
            - And that one place is in here..do note that the <code>&ltcontext-param&gt</code> is for the whole app and
            hence it is not nested inside an individual <code>&ltservlet&gt</code> element.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/91216f9e61e77741b1a721a63ecd56e0.js"></script>
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/7c42c96e7b0f8a067068a96bb7c329d6.js"></script>
            </div>
        </div>

        <div class="sub-heading">Differences between the servlet init param and context init params</div>
        <div>
            <div>
                - Remember that there is only one <code>ServletContext</code> for the entire web-app and all the other
                parts of the web app share it.
                <br>
                - Each Servlet in the app, however, has its own <code>ServletConfig</code>.
                <br>
                - The Web Initialization proceeds as follows:
                <ul>
                    <li>Container reads the DD and creates a name/value String pair for each
                        <code>&ltcontext-param&gt</code></li>
                    <li>Container creates a new instance of the <code>ServletContext</code></li>
                    <li>Container gives the <code>ServletContext</code> a reference to each name/value pair of the
                        context init parameters
                    </li>
                    <li>The Container makes the <code>ServletContext</code> available to each Servlet and JSP. Hence,
                        <i>every</i>
                        servlet and JSP deployed as part of a single web appp has access to the same <code>ServletContext</code>
                    </li>
                </ul>
                - If your app is distributed across multiple servers (probably in a clustered environment), your web app
                really COULD have more than one <code>ServletContext</code>. A <code>ServletContext</code> is one per
                app but only if the app is in a single JVM. In a distributed environment you will have one <code>ServletContext</code>
                per JVM. In this case, to create a "Global" parameter, you will use a Database instead.
                <br>
                - A Context-Init parameter can also be given the same name as a Servlet-Init parameter. This is
                because there is no name space conflict since you get the parameters through 2 different objects:
                ServletConfig and ServletContext.
                <br>
                - If either the context-init-param or the Servlet-init-param are changed, the change will be visible
                only after the web app is redeployed. You cannot change these values during runtime. There is no
                setInitParameter().
            </div>
            <br>
            <div class="row">
                <img src="./Snaps/Ch5/Servlet-Context.png" class="float-left img-fluid"
                     alt="Diff-servletInit-contextInit"
                     width="1400">
            </div>
            <div>
                There are 2 ways to get a <code>ServletContext</code> object:
                <ul>
                    <li><code>this.getServletConfig().getServletContext.getInitParameter(String name)</code></li>
                    <li><code>this.getServletContext.getInitParameter(String name)</code></li>
                </ul>
                - A Servlet's <code>ServletConfig</code> object always holds a reference to the
                <code>ServletContext</code> for that servlet.
                <br>
                - In a servlet, the only time you need to go through your <code>ServletConfig</code> to get to your
                <code>ServletContext</code> is if you are in a Servlet class that does not extend the
                <code>HttpServlet</code> or <code>GenericServlet</code>. For example, in a JSP the second option won't
                work and you will have to use the first one instead.
            </div>
        </div>
        <div class="sub-heading">The <code>ServletContextListener</code></div>
        <div>
            - Suppose you wanted to set up a connection to a database at the initialization of your web app. You could
            store the name of the database as a <code>&ltcontext-param&gt</code> in DD. But remember that the DD can
            store only name/value pairs, where value has to be a String. So you could store the name of the database, as
            a name/value pair. but then how would you initialize the Connection and make it available to all of your
            app? For this you need some code that listens to the creation of the <code>ServletContext</code> and runs
            some code based on the lifecycle changes of the <code>ServletContext</code> class. This is what the <code>ServletContextListener</code>
            is used for.
            <br>
            - We make a separate class that is neither a Servlet, nor a JSP. It listens to two key events in a <code>ServletContext</code>'s
            lifecycle: creation and destruction.
            <br>
            - This separate object:
            <ul>
                <li>Gets notified when the Context is initialized</li>
                <li>Gets the <code>&ltcontext-param&gt</code> from the <code>ServletContext</code></li>
                <li>Use the init parameter lookup name to make a database connection</li>
                <li>Store the database connection as an attribute, so that all parts of the web app can access it</li>
                <li>Gets notified when the Context is destroyed</li>
            </ul>
            - The goal is to use the init-parameter to create a single object that all parts of the app will share.
            <div class="code-snippet">
                Step 1) Creating the Listener Class: The ServletContextEvent has just a single method - <code>getServletContext()</code>
                that returns the <code>ServletContext</code> that changed.
                <script src="https://gist.github.com/rgbk21/fbcfb89f17cd60e97230d672c80c2a22.js"></script>
                Step 2) Creating the Attribute Class: This is just a POJ Class. It's job is to be the attribute value
                that the <code>ServletContextListener</code> instantiates and sets in the <code>ServletContext</code>,
                for the Servlet to retrieve.
                <script src="https://gist.github.com/rgbk21/bf58d8e50b74fb68350d083738d125f4.js"></script>
                Step 3) Create the Listener as shown in the comments. We never specified that the
                <code>&ltlistener&gt</code> is supposed to listen for event related to the ServletContext. The Container
                figures this out automatically by looking at the <code>BeerContextListener</code> class and seeing that
                it implements the <code>ServletContextListener</code> interface, it knows taht the Listener is supposed
                to listen for ServletContext events. A listener can implement more than one listener interface. There
                are several other types of listeners.
                <script src="https://gist.github.com/rgbk21/9381e628f1a851dd348a7cb9636a83c2.js"></script>
                Step 4) Testing it all with our Servlet Class. Remember that <code>getAttribute()</code> returns an
                object. hence, you need to cast the object into the appropriate type.
                <script src="https://gist.github.com/rgbk21/a1d4227ddb59f660d3e57029635373d2.js"></script>
            </div>

            - Here is the complete picture:
            <div class="row">
                <img src="./Snaps/Ch5/Servlet_Initialization_FullStory.png" class="float-left img-fluid"
                     alt=""
                     width="1600">
            </div>
            - And there can be different types of listeners triggering on different types of events:
            <div class="row">
                <img src="./Snaps/Ch5/Listeners.PNG" class="float-left img-fluid"
                     alt=""
                     width="600">
            </div>
            <b>//TODO</b>: Something about <code>HttpSessionBindingListener</code>
        </div>

        <div class="sub-heading">What is an attribute</div>
        <div>
            - An attribute is an object bound into one of three other Servlet API objects: <code>ServletContext</code>,
            <code>HttpServletRequest</code> (<code>ServletRequest</code>), or <code>HttpSession</code>
            <br>
            - An attribute is simply a name/value pair (where the name is a String and the value is an object) in a map
            instance variable.
            <br>
            - In reality, we do not care how it is implemented - all we really care is about the <i>scope</i> in which
            the attribute exists. In other words, <i>who</i> can see it and <i>how long</i> does it live.
        </div>

        <div class="sub-heading">What is the difference between an attribute and a parameter</div>
        <div>
            - An attribute is not a parameter: <a
                href="https://stackoverflow.com/questions/5243754/difference-between-getattribute-and-getparameter">StackOverflow
            Source</a>
            <br>
            - We use <code>request.getParameter()</code> to extract request parameters (i.e. data sent by posting a html
            form). The <code>request.getParameter()</code> always returns String value and the data comes from client.
            The exception to this is <code>ServletContext</code> and the <code>ServletConfig</code> init-parameters
            which are string parameters that are configured in web.xml and exist on the server.
            <div class="row">
                <img src="./Snaps/Ch5/Diff_betn_Attribute_And_Parameter.PNG" class="float-left img-fluid"
                     alt="Diff_betn_Attribute_And_Parameter"
                     width="700">
            </div>

            <div class="row">
                <img src="./Snaps/Ch5/All_Attributes.png" class="float-left img-fluid"
                     alt="All_Attributes"
                     width="1800">
            </div>
        </div>

        <div class="sub-heading">What is the difference between the Context, Session, and Request Scopes</div>
        <div>
            - <b>Context Attributes: </b> A <code>ServletContext</code> attribute is an object bound into a context
            through the <code>ServletContext.setAttribute()</code>
            method and which is available to ALL Servlets (thus JSP) in that context, or to other contexts via the
            <code>getContext()</code> method. By definition a context attribute exists locally in the VM where they were
            defined. So, they're unavailable on distributed applications.
            <br>
            - <b>Session Attributes: </b>Session attributes are bound to a Session, as a means to provide state to a set
            of related HTTP requests.
            Session attributes are available ONLY to those Servlets which join the session. They're also unavailable to
            different JVMs in distributed scenarios. Objects can be notified when they're bound/unbound to the Session
            implementing the <code>HttpSessionBindingListener</code> interface.
            <br>
            - <b>Request Attributes: </b>Request attributes are bound to a specific request object, and they last as far
            as the request is resolved
            or while it keeps being dispatched from Servlet to Servlet. They're used more as communication channel
            between Servlets via the
            <code>RequestDispatcher</code> Interface (since you can't add Parameters...) and by the container. Request
            attributes are very useful in web apps when you must provide setup information between information providers
            and the information presentation layer (a JSP) that is bound to a specific request and need not be available
            any longer, which usually happens with sessions without a rigorous control strategy.
            <br>
            - <a href="https://stackoverflow.com/a/15433931/8742428">StackOverflow Source</a>
            <br>
            - These 3 attribute scopes are handled by the <code>ServletContext</code>,
            <code>HttpSession</code>, and <code>ServletRequest</code> interfaces. The API methods for these attributes
            are the same in every interface:
            <ul>
                <li><code>Object getAttribute(String name)</code></li>
                <li><code>void setAttribute(String name, Object value)</code></li>
                <li><code>void removeAttribute(String name)</code></li>
                <li><code>Enumeration&ltString&gt getAttributeNames(String name)</code></li>
            </ul>
            <div class="row">
                <img src="./Snaps/Ch5/Methods_Scopes.PNG" class="float-left img-fluid"
                     alt="All_Attributes"
                     width="800">
            </div>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/6ea4c632aa3c983cafffe29be386f62f.js"></script>
            </div>
        </div>

        <div class="sub-heading">Context Scope isn't Thread-Safe. Neither is Session Scope.</div>
        <div>
            - Everyone in the app has access to the Context Attributes. That means multiple servlets. And multiple
            servlets might have multiple threads, since requests are concurrently handled, each in a separate thread.
            This happens regardless of whether the requests are coming in from the same or different Servlets.
            <br>
            - In order to make them thread-safe, you need an <a
                href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html">intrinsic lock</a> on
            the ServletContext object. Every object has an intrinsic lock associated with it. By convention, a thread
            that needs exclusive and consistent access to an object's fields has to acquire the object's intrinsic lock
            before accessing them, and then release the intrinsic lock when it's done with them. A thread is said to own
            the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns
            an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts
            to acquire the lock.
            <br>
            - This way everyone accessing the context has to first get the lock on the Context object. This ensures that
            only one thread is setting and getting the context attribute. But remember that this works only if ALL of
            the other code that manipulates the same context attribute ALSO synchronizes on the ServletContext. If even
            part of the code doesn't ask for the lock, then that code is free to hit the context attributes.
            <br>
            //TODO: Why not get a lock just on the variable being changed? Instead of getting a lock on the entire
            ServletContex?
            <br>
            //i.e. do: <code>synchronized (this.getServletContext().getAttribute("UserCount"))</code> ?
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/fa755cf00a8810b355a98a26697a087b.js"></script>
            </div>
            - Remember that Synchronization causes a lot of overhead and hurts concurrency. Make your synchronized block
            as small as possible. Get the lock, get in, get what you need, adn get the heckin heck out so that the lock
            can release and other threads can run that code.
            <br>
            - Writing Servlet code:
            <br>
            <a href="https://docstore.mik.ua/orelly/xml/jxslt/ch06_05.htm">Thread Safety Tips</a>
            <br>
            <a href="https://stackoverflow.com/questions/2551999/why-is-javax-servlet-singlethreadmodel-deprecated">Why
                is singlethreadmodel deprecated</a>
        </div>

        <div class="sub-heading">So what even is Thread-Safe</div>
        <div>
            - Only Request Scoped attributes and Local variables are Thread-Safe
            <br>
            - Everything else is subject ot multi-threaded manipulation unless you do something about it.
            <br>
            - Everything else includes:
            <ul>
                <li>Context Scoped Attributes</li>
                <li>Session Scoped Attributes</li>
                <li>Instance Variables in the Servlet</li>
                <li>Static Variables in the Servlet</li>
            </ul>
            - Note that instance variables are not thread-safe. If you have multiple clients making request to the same
            servlet, that means multiple threads are running that servlet code. And all of those threads have access to
            the servlet's instance variables. So instance variables are not thread-safe.
            <br>
            - Can you make instance variables thread-safe: No. You should avoid using instance variables in your code.
            <br>
            - Then what should you use if you need multiple instances of the Servlet to share something: It's incorrect
            to say "multiple instances of the Servlet" because there is always just ONE instance of the servlet. One
            instance. Many threads...
            <br>
            - If you want all the threads to access a value, decide which attribute state makes the most sense and store
            the value in that attribute. Chances are you can solve the problem in one of two ways:
            <ul>
                <li>Declare the variable as a local variable inside the service method, rather than as an instance
                    variable
                </li>
                <li>Use an attribute in the most appropriate scope</li>
            </ul>
        </div>

        <div class="sub-heading">What is the use of Request Attributes and Request Dispatching</div>
        <div>
            - Request attributes make sense when you want some other component of the app to take over all or a part of
            the request. The controller communicates with the model and gets back the data that the view needs in order
            to build the response. There is no reason to put the data in a Session or a Context attribute, since it
            applies <i>only</i> to this request, so we put it in the request scope.
            <br>
            - So how do we make another part of the component to take over the request - <code>RequestDispatcher</code>
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/a942d8666eccdb9916b499157798c7ec.js"></script>
            </div>
            - <code>RequestDispatcher</code>'s have only two methods:
            <ul>
                <li><code>forward(ServletRequest request, ServletResponse response)</code></li>
                <li><code>include(ServletRequest request, ServletResponse response)</code></li>
            </ul>
            - You can get a <code>RequestDispatcher</code> in two ways: from the request or from the context. Regardless
            of where you get it, you ahve to tell it the web component ot which you are forwarding the request.
            <div class="row">
                <img src="./Snaps/Ch5/RequestDispatcher.PNG" class="float-left img-fluid"
                     alt="RequestDispatcher"
                     width="800">
            </div>
        </div>
    </div>

    <hr>
    <div id="Ch6" class="chapter">Chapter 6: Session Management - Conversational State</div>
    <hr>
    <div class="textual-content">
        <div>
            Web Servers have no short term memory. As soon as they send you a response, they forget who you are. The
            next time you make a request, they do not recognize you. In other words, they do not remember what you have
            requested in the past, and they don't remember what they've sent you in response. Nothing. Sometimes, that's
            fine. But sometimes you need to keep conversational state with the client across <i>multiple requests</i>. A
            shopping cart would not work if the client had to make all his choices and check out in a single request.
        </div>
        <div class="sub-heading">How do we track the Client's requests over multiple sessions</div>
        <div>
            - The objective is to store all the choices that have been made by the Client over multiple requests. There
            are 3 ways in which this can be accomplished:
            <ul>
                <li><b>Use a stateful session enterprise java bean</b>: Make your servlet become a Client to a stateful
                    session bean, and each time a request comes in we locate that Client's stateful bean. Remember that
                    for doing this you hosting provider should have full J2EE server with an EJB Container. Tomcat is
                    just a web container, not a full J2EE container.
                </li>
                <li>
                    <b>Use a Database</b>: Have your hosting provider communicate with a database, like MySQL. Then all
                    the client's data can be written to or read from the database. The downside is that it is extremely
                    expensive to do this.
                </li>
                <li>
                    <b>Use an <code>HttpSession</code></b>: We can use an <code>HttpSession</code> to hold the
                    conversational state over multiple requests - i.e for the <i>entire session</i> with the user.
                </li>
            </ul>
        </div>

        <div class="sub-heading">How does the container know who the Client is</div>
        <div>
            - The HTTP Protocol is a Stateless Protocol. This means that the connection between the Client and the
            Container exists for a <i>single</i> request/response. The Container does not recognize that the Client
            making the second request is the same Client from a previous request. As far as the Container is concerned,
            each request is from a new Client.
            <br>
            - The Container solves this problem by assigning a unique <code>SessionID</code> to each user.
            <br>
            - On the Client's first request, the Container generates a unique session ID and gives it back to the Client
            with the response. The Client then sends back the session ID with each subsequent request. The Container
            sees the ID, finds the matching session, and associates the session with the request.
            <br>
            - Attributes bound into a session are available to any other servlets that belong to the same <code>ServletContext</code>
            and handles a request identified as being a part of the same session.
            <div class="row">
                <img src="./Snaps/Ch6/Sessions_Flowchart.png" class="float-left img-fluid"
                     alt="Sessions_Flowchart"
                     width="1600">
            </div>
        </div>

        <div class="sub-heading">How do the Client and the Container exchange the SessionID info</div>
        <div>
            - The Container uses <code>Cookie</code>s to do this.
            <br>
            - All you have to do is tell the Container that you want to create or use a Session. The Container takes
            care of the rest. The Container generates the SessionID, creates a new <code>Cookie</code> object, stuffs
            the <code>SessionID</code> into the <code>Cookie</code> object, sets the Cookie as a part of the response.
            On subsequent
            requests, the Container gets the <code>SessionID</code> from the Cookie in the request, matches the <code>SessionID</code>
            with an existing session, and associates that session with the current request.
            <br>
            - The <code>HttpSession session = request.getSession()</code> does the following:
            <br>
            <code>if(the request contains the SessionID object)</code>
            <br>
            <code> find the Session matching that ID</code>
            <br>
            <code>else if (there is no SessionID Cookie OR there is no session matching the current SessionID)</code>
            <br>
            <code> create a new session</code>

        </div>

        <div class="sub-heading">How to check if the Session already exists</div>
        <div>
            - The no-args <code>HttpSession session = request.getSession()</code> method returns a session regardless of
            whether there is a
            pre-existing session or not. You can check if it is a new session by using <code>session.isNew()</code>
            method.
            <br>
            - <code>HttpSession session = request.getSession(false)</code> will return <code>null</code> if there is no
            pre-existing session for the Client. You can use it if you have a scenario in which the servlet wants to use
            only a previously created session.
            <br>
            - There are couple of points that you were confused about that need to be clarified:
            <br>
            - You can check the cookies that are stored in the browser on Chrome - Inspect - Application - Cookies
            <br>
            Here you will see the Cookies with the name <code>JSESSION ID</code>. This is the same id as the <code>sessionId</code>.
            While testing, if you see your app behaving abnormally (session seems to be behaving weirdly), first clear
            the cookies in your browser (Ctrl + Shift + Del) and then retry. If that does not work, go into your app and
            by inspecting elements, manually delete the cookies.
            <br>
            - Note that a sessionId is assigned to you the moment you first log in into the website. In the dummy
            example
            that we had, the first page that the user was reaching was a index page. The <code>doGet</code> method was
            activated only when the user clicked a button on the index page to get the form. The point is that, line 4
            of the below code will always contain a valid session.
            <br>
            - Check this <a
                href="https://stackoverflow.com/questions/19476154/confusion-with-the-httpsession-isnew-method-behavior">SO
            Post explaining things</a>.
            <br>
            - So in order to kill that session, we first call <code>session.invalidate</code>. Remember that this will
            not set the <code>session</code> to <code>null</code> as <a
                href="https://stackoverflow.com/questions/24677949/why-session-is-not-null-after-session-invalidate-in-java">explained
            here in SO</a>. So we get the session again, as on Line 8. This time the Container does not find any
            existing sessions and the <code>session</code> variable is in fact null. When we run the code, now, the
            <code>if (session == null) </code> block is executed.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/3b7165571d0253ffe96051ce0879d268.js"></script>
            </div>
        </div>

        <div class="sub-heading">What if the Client has disabled Cookies</div>
        <div>
            - If the Client does not use Cookies, you can use URL rewriting as a backup. URL rewriting
            allows the sessionID to be added to the end of the URL (instead of being sent as a Cookie).
            <br>
            - URL rewriting kicks in only if cookies fail and you have explicitly encoded your URLs.
            <br>
            - Read up on the <code>encodeURL</code> method
            <br>
            - When a Container sees a call to <code>getSession</code>, and the Container does not have the SessionID
            associated with the Client's request, the Container knows that it must attempt to set up a new session with
            the Client. At this point the Container does not know whether the Cookies will work or not. Hence for the
            first response back to the Client, the Container tries both, Cookies <i>and</i> URL Rewriting.
        </div>

        <div class="sub-heading">What are the key <code>HttpSession</code> methods</div>
        <div>
            <div class="row">
                <img src="./Snaps/Ch6/HttpSessionMethods.PNG" class="float-left img-fluid"
                     alt="HttpSessionMethods"
                     width="800">
            </div>
        </div>


        <div class="sub-heading">How does a Container know when it is safe to destroy Sessions</div>
        <div>
            - There are 3 ways that a Session can die:
            <ul>
                <li>It times out</li>
                <li>You call <code>invalidate()</code> on the Session object</li>
                <li>The application goes down or crashes</li>
            </ul>
            <br>
            a) <b>Setting Session Timeout</b>: There are two ways to set the session timeout
            <ul>
                <li><b>Setting Session Time out for a specific session</b>: Use this if you want to change the
                    session-timout value for a particular session instance without affecting the timeout length for any
                    other sessions in the app.
                    <br>
                    <code>session.setMaxInactiveInterval(20*60)</code>
                    <br>
                    Only the session on which you call the method will be affected. Note that the argument to the method
                    is in seconds.
                </li>
                <li><b>Configuring Session Timeout in the DD:</b> This has the same effect as calling <code>setMaxInactiveInterval()</code>
                    on every session that is created.
                    <div class="code-snippet">
                        <script src="https://gist.github.com/rgbk21/9da74048e8db7b9f15708bcb3e8cce48.js"></script>
                    </div>
                </li>
            </ul>
            b) <b>Calling <code>invalidate()</code></b>: Invalidates this session then unbinds any objects bound to it.
            Like we discussed earlier, calling this method will not set the session object to <code>null</code>.
            <div class="row">
                <img src="./Snaps/Ch6/invalidate_session.PNG" class="float-left img-fluid"
                     alt="invalidate_session"
                     width="1600">
            </div>
            //TODO: Why isn't the session invalidated in the second case? I can still get and print the values of the
            attributes. Why?
        </div>

        <div class="sub-heading">Can I use the Cookie for things other than maintaining Sessions</div>
        <div>
            - Yes. Remember that the cookie is nothing more than a little piece of data (name/value) pair that is
            exchanged between the Client and the server. The Server sends the Cookie to the Client and the Client
            returns the cookie to the Server when teh Client has to make a new request to the Server.
            <br>
            - By default, a Cookie lives only as long as the session. Once the client quits his browser, the cookie
            disappears. That's how the <code>JSESSION</code> cookie works. But you can tell a cookie to stay alive even
            AFTER the browser shuts down. These types of cookies are known as <a
                href="https://en.wikipedia.org/wiki/HTTP_cookie#Persistent_cookie">Persistent Cookies</a>.
        </div>


        <div class="sub-heading"> How to use Cookies with the Servlet API</div>
        <div>
            - This is probably a convoluted example, but stick through it. First the JSP page. Note that there is no
            getCookie(String) method. You can only get Cookies in a Cookie array and then you have to loop over the
            array to
            find the one you want.
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/56d716e43b85399023fccfe04f8b4ef7.js"></script>
            </div>
            And then the Servlet class:
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/b9d064f68b6281badc5c51e2d464167d.js"></script>
            </div>
        </div>

        <div class="sub-heading">What kinds of listeners are we dealing with</div>
        <div class="row">
            <img src="./Snaps/Ch6/Listeners.PNG" class="float-left img-fluid"
                 alt="invalidate_session"
                 width="800">
        </div>

        <div class="sub-heading">What is Session Migration</div>
        <div>
            - In a clustered environment, the Container might do <i>load-balancing</i> by taking client requests and
            sending
            them out JVMs. The JVMs themselves may or may not be on the same physical boxes, that is immaterial. The
            point
            is that the web app is in multiple places. This means that each time the same Client makes a request, the
            request could end up going to a <i>different</i> instance of the same servlet.
            <br>
            - The question is: how does the Container manage the <code>ServletConfig</code>, <code>ServletContext</code>,
            and <code>HttpSession</code> objects in this case.
            <br>
            - Only <code>HttpSession</code> objects (and their attributes) move from one VM to another.
            <br>
            - There is one <code>ServletContext</code> <i>per</i> VM. There is one <code>ServletConfig</code> <i>per
            Servlet, per VM</i>. But there is only one <code>HttpSession</code> object for a given
            <code>SessionId</code>
            per web app, regardless of how many VM's the app is distributed across.
            <br>
            - The key point here is that while the other parts of the app are <i>replicated</i> on each node/VM, the
            session
            objects (along with the session attributes) are <i>moved</i>.
            <div class="row">
                <img src="./Snaps/Ch6/DistributedSessions.PNG" class="float-left img-fluid"
                     alt="DistributedSessions"
                     width="800">
            </div>
            <div class="row">
                <img src="./Snaps/Ch6/SessionMigration.png" class="float-left img-fluid"
                     alt="SessionMigration"
                     width="1600">
            </div>

            //TODO: This is followed by something related to SessionListeners.
            <br>
            <code>HttpSessionActivationListener</code>
            <br>
            <code>HttpSessionAttributeListener</code>
            <br>
            <code>HttpSessionAttributeListener</code>

        </div>
    </div>

    <hr>
    <div id="Ch7" class="chapter">Chapter 7: Using JSP - Being a JSP</div>
    <hr>
    <div class="textual-content">
        The most important point for this chapter is simply: what role does the JSP place in the final servlet class?
        In other words, <i>where</i> do the elements in the JSP end up in the source code of the generated servlet?

        <div class="sub-heading">In the end a JSP is just a Servlet</div>
        <div>
            - In the end, your JSP becomes a full-fledged servlet running in your web-app. The only difference is that
            the servlet class is written for you by the Container. The Container takes what you have written in your
            JSP, translates it into a servlet class source (.java) file, then compiles that into a java servlet class.
            After that it all behaves just like a normal servlet class, i.e the Container loads the Servlet class,
            instantiates and initializes it, makes a separate thread for each request and calls the servlet's <code>service()</code>
            method.
            <br>
            - When you deploy a web app witha JSP, the whole translation and compilation step happens only once in the
            JSP's life. Once it has been translated and compiled, it is just like any other servlet. And just like any
            other servlet, once that servlet has been loaded and initialized, the only thing that happens at request
            time is creation or allocation of a thread for the service method. So the above picture is only for the very
            first request that the container has to handle.
            <div class="row">
                <img src="./Snaps/Ch7/CompilationOfServlet.PNG" class="float-left img-fluid"
                     alt="CompilationOfServlet"
                     width="1000">
            </div>
        </div>

        <div class="sub-heading">How to import packages into JSP</div>
        <div>
            - A <i>directive</i> is a way for you to give special instructions to the Container at page translation
            time.
            <br>
            - Directives come in three flavors:
            <ul>
                <li>page</li>
                <li>include</li>
                <li>taglib</li>
            </ul>
            - For importing packages into the JSP, we will use the <i>page</i> directive.
            <br>
            - Importing a single package can be done as follows: <code>&lt%@ page import = "java.util.List" %&gt</code>.
            Notice that there is no semicolon at the end of the import statement.
            <br>
            - Importing a multiple packages can be done as follows:
            <code>&lt%@ page import = "java.util.List,java.util.Map"%&gt</code>. Note that packages are separated by
            comma and the quotes go around the entire list of packages.
        </div>

        <div class="sub-heading">3 JSP element types</div>
        <div>
            - We can now introduce 3 different JSP element types:
            <ul>
                <li>Scriptlet <code>&lt% %&gt</code> : Between these tags goes the java code that you want to write in
                    the JSP page. <br>So we can write <code>&lt% out.println(Counter.getCount()); %&gt</code>.
                </li>
                <li>Directive <code>&lt%@ %&gt</code> : used for writing import statements, among other things, in the
                    JSP. No semi-colon at the end.
                </li>
                <li>Expression <code>&lt%= &gt</code>: it automatically prints out whatever you put between the tags.
                    This is meant as a replacement for <code>out.println</code> in JSP. So, instead of writing, say,
                    <code>&lt% out.println(Counter.getCount()); %&gt</code>, we would just write
                    <code>&lt%= Counter.getCount() %&gt</code>. Note that the expression does not need a semicolon at
                    the end either. A n expression <i>cannot</i> use a method that does not have a return type, i.e has
                    <code>void</code> as return type because then there won't be anything to print.
                </li>
            </ul>
            - In case you are wondering, the object <code>out</code> in the above example is passed implicitly to your
            JSP page, just in case you want to pass it to some other object that does not have direct access to the
            output stream for the response.
        </div>

        <div class="sub-heading">What really happens to your JSP Code</div>
        <div>
            - Let's see where the different JSP elements land in the servlet's class file:
            <div class="row">
                <img src="./Snaps/Ch7/JSP2Scriptlet.PNG" class="float-left img-fluid"
                     alt="CompilationOfServlet"
                     width="1000">
            </div>
            - All scriptlet and expression code lands in a service method. That means that variables declared in a
            scriptlet are ALWAYS local variables.
            <br>
            - Also note that the code from the JSP is placed inside the <code>_jspService</code> method that takes as
            argument the <code>HttpServletRequest request</code> object. Hence you wan write your JSP assuming that it
            is going to be a part of a servlet. This is also an example of "implicit" object. Something that we see in
            the next paragraph.
        </div>

        <div class="sub-heading">How do we declare instance variables in a JSP</div>
        <div>
            - There is another JSP element known as a <i>declaration</i>: for example
            <code>&lt%! int count = 0;%&gt</code>.
            <br>
            - Note that this requires a semicolon at the end. JSP <i>declarations</i> are for declaring members of the
            generated servlet class. This means, both, <i>variables</i> and <i>methods</i>. In other words, anything
            between the <code>&lt%! %&gt</code> tag is added to the class <i>outside</i> the service method. That means
            that you can declare, both, static variables (what?) and methods.
            <div class="row">
                <img src="./Snaps/Ch7/JSP2Servlet_Decalrations.PNG" class="float-left img-fluid"
                     alt="JSP2Servlet_Decalrations"
                     width="800">
            </div>
        </div>

        <div class="sub-heading">What implicit objects are passed to the JSP</div>
        <div>
            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>API</th>
                    <th>Implicit Object</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>JspWriter</td>
                    <td>out</td>
                </tr>
                <tr>
                    <td>HttpServletRequest</td>
                    <td>request</td>
                </tr>
                <tr>
                    <td>HttpServletResponse</td>
                    <td>response</td>
                </tr>
                <tr>
                    <td>HttpSession</td>
                    <td>session</td>
                </tr>
                <tr>
                    <td>ServletContext</td>
                    <td>application</td>
                </tr>
                <tr>
                    <td>ServletConfig</td>
                    <td>config</td>
                </tr>
                <tr>
                    <td>Throwable</td>
                    <td>exception</td>
                </tr>
                <tr>
                    <td>PageContext</td>
                    <td>pageContext</td>
                </tr>
                <tr>
                    <td>Object</td>
                    <td>page</td>
                </tr>
                </tbody>
            </table>
            - We were already familiar with the 3 scopes: request, session, and application. This introduces another
            scope known as the pageContext.
            <br>
            - A <code>pageContext</code> encapsulates the other implicit objects. This way if you give some other helper
            object a reference to the PageContext, the helper can use that reference to get all the OTHER implicit
            object
            and attributes from all the scopes.
        </div>

        <div class="sub-heading">Everything in one place</div>
        <div>
            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>JSP Element</th>
                    <th>Usage</th>
                    <th>What is it used for</th>
                    <th>Usage Example</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Scriptlet</td>
                    <td><code>&lt% ;%&gt</code></td>
                    <td>Used to write Java Code</td>
                    <td><code>&lt% out.println(Counter.getCount()); %&gt</code></td>
                </tr>
                <tr>
                    <td>Directive</td>
                    <td><code>&lt%@ %&gt</code></td>
                    <td>Used for writing import statements</td>
                    <td><code>&lt%@ page import = "java.util.List" %&gt</code></td>
                </tr>
                <tr>
                    <td>Expression</td>
                    <td><code>&lt%= %&gt</code></td>
                    <td>Printing out stuff</td>
                    <td><code>&lt%= Counter.getCount() %&gt</code></td>
                </tr>
                <tr>
                    <td>Declaration</td>
                    <td><code>&lt%! ;%&gt</code></td>
                    <td>Declaring methods and instance variables in the JSP</td>
                    <td><code>&lt%! int count = 0;%&gt</code></td>
                </tr>
                <tr>
                    <td>ExpressionLanguages</td>
                    <td><code> ${ }</code></td>
                    <td>Invokes Java Code</td>
                    <td><code>${applicationScope.mail}</code></td>
                </tr>
                <tr>
                    <td>Actions</td>
                    <td><code>&ltjsp: /&gt</code>, <code>&ltc: /&gt</code></td>
                    <td>They are 2 types: <code>standarad</code> and <code>other</code></td>
                    <td><code></code></td>
                </tr>
                </tbody>
            </table>

            <table class="table table-bordered table-sm">
                <thead>
                <tr>
                    <th>Scope</th>
                    <th>In a Servlet</th>
                    <th>In a JSP (using implicit objects)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Application/Context</td>
                    <td><code>getServletContext.setAttribute("foo", barObject)</code></td>
                    <td><code>application.setAttribute("foo", barObject)</code></td>
                </tr>
                <tr>
                    <td>Request</td>
                    <td><code>request.setAttribute("foo", barObject)</code></td>
                    <td><code>request.setAttribute("foo", barObject)</code></td>
                </tr>
                <tr>
                    <td>Session</td>
                    <td><code>request.getSession().setAttribute("foo", barObject)</code></td>
                    <td><code>session.setAttribute("foo", barObject)</code></td>
                </tr>
                <tr>
                    <td>Page</td>
                    <td><code>Does not apply</code></td>
                    <td><code>pageContext.setAttribute("foo", barObject)</code></td>
                </tr>
                </tbody>
            </table>


            - Comments can be added either using:
            <ul>
                <li><code>//Your comment </code>: in a scriptlet or a declaration. However, outside of this the string
                    "//" would just be parsed like normal HTML comment and you would see your comment printed on the
                    page
                </li>
                <li><code>&lt!-- HTML Comment --&gt</code>: Use this if you want the comments to stay as a part of the
                    HTML response to the Client
                </li>
                <li><code>&lt%-- JSP Comment --%&gt</code>: Comments will be hidden. They are stripped off when the JSP
                    is converted into Java.
                </li>
            </ul>
        </div>

        <div class="sub-heading">Now that you know how to write java code in JSP, never do it</div>
        <div>
            - Java code in JSP is considered hard to change and maintain.
            <br>
            - Instead we make use of Expression Language or <b>EL</b>. The purpose of EL is to offer a simeple way to
            <i>invoke</i> Java code - but the code itself belongs <i>somewhere else</i>. That means in a regular old
            Java class that's either a JavaBean, a class with static methods, or something called a Taghandler.
            <br>
            - In other words you do not write method code into your JSP. You write the Java methods somewhere else and
            call it using EL.
            <br>
            - You can use <code>&ltscripting-invalid&gt true &lt/scripting-invalid&gt</code> to disable scripting
            elements for ALL JSPs. There is a specific format for this. Refer text.
        </div>

        //TODO: Complete the exercises and the Coffee Cram questions from this Chapter.
    </div>

    <hr>
    <div id="Ch8" class="chapter">Chapter 8: Scriptless JSP - Script-free pages</div>
    <hr>
    <div class="textual-content">

    </div>

</div>


</body>
</html>
