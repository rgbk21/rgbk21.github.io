<!DOCTYPE html>
<html lang="en">
<head>

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
          integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
          crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
          integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
          crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
          integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
          crossorigin="anonymous"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9QJ5D3X353"></script>
  <script>
      window.dataLayer = window.dataLayer || [];

      function gtag() {
          dataLayer.push(arguments);
      }

      gtag('js', new Date());

      gtag('config', 'G-9QJ5D3X353');
  </script>
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;1,400&display=swap"
        rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../../globalStyles.css">
  <meta name="keywords" content="Java, Floats, Overflow, Unboxing, Autoboxing">
  <meta name="author" content="Raj Gaurav Ballabh Kumar">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Applying Java - Notes</title>
</head>

<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">

  <div class="navbar-header">
    <a href="../../index.html" class="navbar-brand"> rgbk21</a>
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"><span
    class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="nav navbar-nav">
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
           aria-expanded="false">
          Projects
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="../../Projects/TwitterCritNodes/TwitterCritNodes_1.html">Identifying
            Critical Nodes on Twitter</a>
          <a class="dropdown-item" href="../../Projects/isRelatedTo/isRelatedTo.html">isRelatedTo</a>
          <div class="dropdown-divider"></div>
        </div>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
           aria-expanded="false">
          HTML Projects
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="../../WordleCheater/index.html">Wordle Cheater</a>
          <a class="dropdown-item" href="../../Pig_Game/index.html">2-Player Pig Game</a>
          <a class="dropdown-item" href="../../ImageGallery/ImageGallery.html">Image Gallery</a>
          <a class="dropdown-item" href="../../RGB_Guesser_Game/RGB.html">RGB Guesser Game</a>
          <a class="dropdown-item" href="../../ToDoList/todo.html">To-Do List</a>
          <div class="dropdown-divider"></div>
        </div>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
           aria-expanded="false">
          Notes
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="../../Lectures/COMS_631/COMS_631_index.html">COMS 631</a>
          <a class="dropdown-item" href="../../Lectures/COMS_535/COMS_535_index.html">COMS 535</a>
          <a class="dropdown-item" href="../../Lectures/EffectiveJava/EffectiveJava.html">Effective Java</a>
          <a class="dropdown-item" href="../../Lectures/DI/DI.html">Dependency Injection</a>
          <div class="dropdown-divider"></div>
        </div>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
           aria-expanded="false">
          Code
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="../../Code/ThingsToRemember/ThingsToRemember.html">Things To Remember</a>
          <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes.html">Java Notes</a>
          <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes_2.html">Java Notes 2</a>
          <a class="dropdown-item" href="../../Code/LeetCode/LeetCode.html">LeetCode Notes</a>
          <a class="dropdown-item" href="../../Code/Applying_Java_Notes/ApplyingJava_Notes.html">ApplyingJava Notes</a>
          <a class="dropdown-item" href="../../Code/JavaScript/JavaScript.html">JavaScript Notes</a>
          <a class="dropdown-item" href="../../Code/HTML_CSS/HTML_CSS_Basics.html">HTML & CSS Notes</a>
          <a class="dropdown-item" href="../../Code/SQL/SQL.html">SQL Notes</a>
          <a class="dropdown-item" href="../../Code/Spring/Spring.html">Spring Notes</a>
          <a class="dropdown-item" href="../../Code/Kafka/Kafka.html">Kafka Notes</a>
          <a class="dropdown-item" href="../../Code/Angular/Angular.html">Angular</a>
          <a class="dropdown-item" href="../../Code/Hibernate/Hibernate.html">Hibernate</a>
          <div class="dropdown-divider"></div>
        </div>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
           aria-expanded="false">
          In Another Life
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="../../InAnotherLife/Chapter1/Chapter1.html">Chapter 1</a>
          <a class="dropdown-item" href="../../InAnotherLife/Chapter2/Chapter2.html">Chapter 2</a>
          <a class="dropdown-item" href="../../InAnotherLife/Chapter3/Chapter3.html">Chapter 3</a>
          <div class="dropdown-divider"></div>
        </div>
      </li>
    </ul>


    <ul class="navbar-nav ml-auto">
      <li class="nav-item active"><a class="nav-link" href="https://github.com/rgbk21">GitHub</a></li>
      <li class="nav-item active"><a class="nav-link"
                                     href="https://www.linkedin.com/in/raj-gaurav-ballabh-kumar-97002058/">LinkedIn</a>
      </li>
      <li class="nav-item active"><a class="nav-link" href="https://www.instagram.com/wobblyframes/">Instagram</a>
      </li>
      <li class="nav-item active"><a class="nav-link"
                                     href="https://www.facebook.com/SomeRandomThoughts">Facebook</a></li>
    </ul>

  </div>
</nav>

<div class="container">

  <button id='load-all-gists' type="button" class="btn btn-outline-primary">Show all Gists!</button>

  <div>
    This page mainly contains my notes from: <br>
    a) Java: The Complete Reference <br>
    b) <a href="#head-first">HeadFirst: Servlets and JSP</a>
    <div>
      Index:
      <br>
      <a href="#Ch1">Chapter 1: Why use Servlets and JSPs</a>
      <br>
      <a href="#Ch2">Chapter 2: Web App Architecture</a>
      <br>
      <a href="#Ch3">Chapter 3: Mini MVC Tutorial</a>
      <br>
      <a href="#Ch4">Chapter 4: Request and Response - Being a Servlet</a>
      <br>
      <a href="#Ch5">Chapter 5: Attributes and Listeners - Being a Servlet</a>
      <br>
      <a href="#Ch6">Chapter 6: Session Management - Conversational State</a>
      <br>
      <a href="#Ch7">Chapter 7: Using JSP - Being a JSP</a>
      <br>
      <a href="#Ch8">Chapter 8: Scriptless JSP - Script-free pages</a>
      <br>
    </div>
    c) <a href="#BudiKurniawan">Servlet and JSP : A Tutorial Kurniawan, Budi</a>
  </div>

  <hr>
  <div class="chapter">Chapter 34: Java Beans</div>
  <hr>
  <div class="textual-content">

    <div class="sub-heading">What is a Java Bean</div>
    <div class="textual-content">
      - A <i>Java Bean</i> is a software content that has been designed to be reusable in a variety of different
      environments. There is no restriction in the capability (in terms of complexity) of a Java Bean. A bean may
      perform a simple function or a complicated function.
      <br>
      - At a basic level, <a
      href="https://stackoverflow.com/questions/21866571/difference-between-javabean-and-spring-bean">JavaBeans
      are simply Java classes</a> which adhere to certain coding conventions.
      Specifically, classes that have:
      <ul>
        <li><code>public</code> default (no argument) constructors</li>
        <li>allow access to their properties using accessor (getter and setter) methods</li>
        <li>implement <code>java.io.Serializable</code></li>
        <li>all JavaBean instance variables should be private</li>
      </ul>
    </div>
    <div class="sub-heading">What is the difference between a Java Bean and a POJO</div>
    <div class="textual-content">
      - A JavaBean follows <a
      href="https://stackoverflow.com/questions/1394265/what-is-the-difference-between-a-javabean-and-a-pojo">certain
      conventions</a>. Getter/setter naming, having a public default constructor, being
      serializable etc. See <a href="https://docstore.mik.ua/orelly/java-ent/jnut/ch06_02.htm">JavaBeans
      Conventions</a> for more details.
      <br>
      - A POJO (plain-old-Java-object) isn't rigorously defined. It's a Java object that doesn't have a
      requirement
      to implement a particular interface or derive from a particular base class, or make use of particular
      annotations in order to be compatible with a given framework, and can be any arbitrary (often relatively
      simple) Java object.
      <br>
      - All JavaBeans are POJOs but not all POJOs are JavaBeans.
    </div>
    <div class="sub-heading">What is the difference between a Java Bean and a Spring Bean</div>
    <div class="textual-content">
      - A Spring bean is basically an object managed by Spring. More specifically, it is an object that is
      instantiated, configured and otherwise managed by a Spring Framework container. Spring beans are defined in
      Spring configuration files (or, more recently, with annotations), instantiated by Spring containers, and
      then injected into applications.
      <br>
      - Note that Spring beans need not always be JavaBeans. Spring beans might not implement the
      <code>java.io.Serializable</code> interface, can have arguments in their constructors, etc.
      This is the very basic difference between JavaBeans and Spring beans.
      <br>
      - <a href="http://www.shaunabram.com/beans-vs-pojos/">The reason Spring managed objects are referred to as
      beans</a> is because in the very early versions, Spring was
      intended only for use with JavaBeans. That is no longer the case of course: Spring can manage just about any
      object, even if it doesn’t have JavaBean type characteristics such as default constructors or mutator
      methods (getters and setters). None the less, the term ‘Spring beans’ has stuck.
      Can Spring beans be POJOs? Yes, and they usually are (although they don’t have to be – e.g. Spring can be
      used with ‘heavyweight’ Java objects, such as EJBs).
      Can Spring beans be JavaBeans? As I have said, yes and again they often are but don’t have to be.
    </div>
    <div class="sub-heading"><a
      href="https://stackoverflow.com/questions/3461199/what-is-the-advantage-of-using-java-beans">Advantages
      of a Bean</a></div>
    <div class="textual-content">
      A JavaBean on its own is not terribly interesting, it's just a Java class that conforms to some standards.
      However, conformance with this standard is one of the pillars on which the Java EE
      framework is built and it comes up in quite a few places. FYI, there are a few different types of EJB listed
      below:
      <ul>
        <li><b>Entity Beans</b>:</li>
        <div>You might want to read/write objects to/from an underlying database. You could use JDBC/SQL to do
          this but you could also use a persistance framework. The Java EE spec includes a spec for
          persistance whereby you declare your class to be an "entity bean" and have Java automatically
          generate database tables and logic to map between entries in your database and objects in your
          program. The actual implementation is provided by a lower level library such as Eclipselink,
          Toplink, Hibernate etc. but the Java API abstracts away any differences between them.
          <br>
          Session beans represent logic while entity beans represented persistent objects. <a
            href="https://stackoverflow.com/a/13501659/8742428">These days entity
            beans aren't used anymore in favour to JPA entities.</a>
        </div>
        <li><b>Stateful Session Beans</b></li>
        <div>
          Imagine that you want to create an instance of a Java class which exists on separate JVM. The JVMs
          might be running on the same physical machine but equally, may be on separate machines communicating
          over a network. Using a Java EE application server, you can create a class which can be instantiated
          by clients of the app server. These clients can instantiate a class which will act just like a
          normal object but any methods that are invoked on the object get executed on the server with the
          results being passed back to the caller. It's basically an object oriented form of remote procedure
          calls.
        </div>
        <li><b>Stateless Session Beans</b></li>
        <div>
          This is a minor variation on stateful session beans. With stateful beans, if the server has 1000
          clients then it will potentially have to create 1000 instances of the bean and remember which
          instance belongs to which client. With stateless beans, the server creates a pool of beans and
          doesn't bother to remember which client owns which bean. When a client invokes a method, the server
          picks a bean from the pool and uses it, returning it to the pool on completion. You use stateful
          session beans when you want the server to remember details about each client, you will use stateless
          beans when you don't need to remember client specific details. Note that the stateless beans may
          well have state, it's just that this state won't be of interest to the client.
        </div>
        <li><b>Singleton Beans</b></li>
        <div>
          //TODO..?
        </div>
      </ul>
    </div>
    <div class="sub-heading">Introspection</div>
    <div class="textual-content">
      Introspection is the automatic process of analyzing a bean's design patterns to reveal the bean's
      properties, events, and methods. This process controls the publishing and discovery of bean operations and
      properties.
      <br>
      There are two ways in which the developer of a Bean can indicate which of its properties, events, and
      methods should be exposed. With the first method, simple naming conventions are used. These allow the
      introspection mechanisms to infer information about a Bean. In the second way, an additional class that
      extends the <code>BeanInfo</code> interface is provided that explicitly supplies this information.
      <br>
      The introspection mechanism finds all of the public methods of a Bean. Protected and private methods are not
      presented.
    </div>
    <div class="sub-heading">Design Pattern for Properties</div>
    <div class="textual-content">
      A <i>property</i> is a subset of a Bean’s state. The values assigned to the properties determine the
      behavior and
      appearance of that component. A property is set through a setter method. A property is obtained by a getter
      method. <a href="https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html">There are two
      types of properties:</a>
      <ul>
        <li><b>Simple</b>:
          A simple property has a single value. It can be identified by the following design patterns, where
          <code>N</code> is the name of the property and <code>T</code> is its type:
          <br>
          <code>public T getN()</code>
          <br>
          <code>public void setN(T arg)</code>
          <br>
          A read/write property has both of these methods to access its values. A read-only property has only
          a get method. A write-only property has only a set method.
        </li>
        <li><b>Indexed</b>:
          An indexed property consists of multiple values. It can be identified by the following design
          patterns, where <code>N</code> is the name of the property and <code>T</code> is its type:
          <br>
          <code>public T getN(int index);</code>
          <br>
          <code>public void setN(int index, T value);</code>
          <br>
          <code>public T[] getN();</code>
          <br>
          <code>public void setN(T values[]);</code>
          <br>
        </li>
      </ul>
    </div>
    <div class="sub-heading">Design Pattern for Events</div>
    <div>
      Beans use the delegation event model that was discussed earlier in this book. Beans can generate events and
      send them to other objects. These can be identified by the following design patterns, where <code>T</code>
      is the type of the event:
      <br>
      <code>public void addTListener(TListener eventListener)</code>
      <br>
      <code>public void addTListener(TListener eventListener) throws java.util.TooManyListenersException</code>
      <br>
      <code>public void removeTListener(TListener eventListener)</code>
      <br>
      These methods are used to add or remove a listener for the specified event. The version of
      <code>addTListener()</code> that does not throw an exception can be used to <i>multicast</i> an event, which
      means that more than one listener can register for the event notification. The version that throws <code>TooManyListenersException</code>
      <i>unicasts</i> the event, which means that the number of listeners can be restricted to one. In either
      case, <code>removeTListener()</code> is used to remove the listener.
      <br>
      //TODO: Example code of how to actually use a listener to listen for an event and take action based on it.
    </div>
  </div>

  <hr>
  <div class="chapter">Chapter 35: Introducing Servlets</div>
  <hr>

  <div class="textual-content">
    <div class="sub-heading">The javax.servlet Package</div>
    <div>
      The javax.servlet package contains a number of interfaces and classes that establish the framework in which
      servlets operate.
      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Interface</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Servlet</td>
          <td>Declares the life cycle methods for a Servlet</td>
        </tr>
        <tr>
          <td>ServletConfig</td>
          <td>Allows Servlets to get intiialization parameters</td>
        </tr>
        <tr>
          <td>ServletContext</td>
          <td>Enables servlets to log events and access information about their environment</td>
        </tr>
        <tr>
          <td>ServletRequest</td>
          <td>Used to read data froma Client Request</td>
        </tr>
        <tr>
          <td>Servlet Response</td>
          <td>Used to write data to a Client Response</td>
        </tr>
        </tbody>
      </table>

      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Class</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>GenericServlet</td>
          <td>Implements the <code>Servlet</code> and the <code>ServletConfig</code> interfaces</td>
        </tr>
        <tr>
          <td>ServletInputStream</td>
          <td>Encapsulates an input stream for reading requests from a client</td>
        </tr>
        <tr>
          <td>ServletOutputStream</td>
          <td>Encapsulates an output stream for writing response to a Client</td>
        </tr>
        <tr>
          <td>ServletException</td>
          <td>Indicates a Servlet error occurred</td>
        </tr>
        <tr>
          <td>UnavailableException</td>
          <td>Indicates a Servlet is Unavailable</td>
        </tr>
        </tbody>
      </table>
    </div>

    <div class="sub-heading">The Servlet Interface</div>
    <div>
      - Defines methods that all servlets must implement.
      <br>
      - A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests
      from Web clients, usually across HTTP, the HyperText Transfer Protocol.
      <br>
      - To implement this interface, you can write a generic servlet that extends <code>javax.servlet.GenericServlet</code>
      or an
      HTTP servlet that extends <code>javax.servlet.http.HttpServlet</code>.
      <br>
      - This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from
      the server. These are known as life-cycle methods and are called in the following sequence:
      <br>
      1) The servlet is constructed, then initialized with the init method.
      <br>
      2) Any calls from clients to the service method are handled.
      <br>
      3) The servlet is taken out of service, then destroyed with the destroy method, then garbage collected and
      finalized.
      <br>
      - In addition to the life-cycle methods, this interface provides the <code>getServletConfig</code> method,
      which the
      servlet can use to get any startup information, and the <code>getServletInfo</code> method, which allows the
      servlet to
      return basic information about itself, such as author, version, and copyright.
    </div>
    <br>

    <table class="table table-bordered table-sm">
      <thead>
      <tr>
        <th>Method</th>
        <th>Description</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>void init(ServletConfig sc) throws ServletException</td>
        <td>Called when the Servlet is initialized. Initialization parameters for the Servlet can be obtained
          from the sc. A ServletExce[tion should be thrown if the Servlet cannot be intiialized
        </td>
      </tr>
      <tr>
        <td>void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</td>
        <td>Called to process a request from the Client. The request from the clint can be read from req, the
          response to the client can be written to res. An exception is generated if if a servlet or IO
          problem occurs.
        </td>
      </tr>
      <tr>
        <td>void destroy()</td>
        <td>Called when the Servlet is unloaded from the memory</td>
      </tr>
      <tr>
        <td>String getServletInfo()</td>
        <td>Returns a String describing the Servlet</td>
      </tr>
      <tr>
        <td>ServletConfig getServletConfig()</td>
        <td>Returns a ServletConfig object that contains any initialization parameters</td>
      </tr>
      </tbody>
    </table>

    <div class="sub-heading">The ServletConfig Interface</div>
    <div>
      - A servlet configuration object used by a servlet container to pass information to a servlet during
      initialization.

    </div>

    <div class="sub-heading">The ServletContext Interface</div>
    <div>
      - The <code>ServletContext</code> object is contained within the <code>ServletConfig</code> object, which
      the Web server provides the servlet when the servlet is initialized.
      <br>
      - This interface defines a set of methods that a servlet uses to communicate with its servlet container, for
      example, to get
      the MIME type of a file, dispatch requests, or write to a log file.
      <br>
      - There is one context per "web application" per Java Virtual Machine. (A "web application" is a collection
      of
      servlets and content installed under a specific subset of the server's URL namespace such as /catalog and
      possibly installed via a .war file.
    </div>

    <div class="sub-heading">The ServletRequest Interface</div>
    <div>
      - Defines an object to provide client request information to a servlet.
      <br>
      - The servlet container creates a ServletRequest object and passes it as an argument to the servlet's
      service method.
      <br>
      - A ServletRequest object provides data including parameter name and values, attributes, and an input
      stream.
      Interfaces that extend <code>ServletRequest</code> can provide additional protocol-specific data (for
      example, HTTP data
      is provided by <code>HttpServletRequest</code>.
    </div>

    <div class="sub-heading">The ServletResponse Interface</div>
    <div>
      - Defines an object to assist a servlet in sending a response to the client.
      <br>
      - The servlet container creates a <code>ServletResponse</code> object and passes it as an argument to the
      servlet's service method.
      <br>
      - To send binary data in a MIME body response, use the <code>ServletOutputStream</code> returned by <code>getOutputStream()</code>.
      To send character data, use the <code>PrintWriter</code> object returned by <code>getWriter()</code>. To mix
      binary and text data, for example, to create a multipart response, use a <code>ServletOutputStream</code>
      and manage the character sections manually.
    </div>

    <div class="sub-heading">The GenericServlet Class</div>
    <div>
      - Defines a generic, protocol-independent servlet. To write an HTTP servlet for use on the Web, extend
      <code>HttpServlet</code> instead.
      <br>
      - <code>GenericServlet</code> implements the <code>Servlet</code> and <code>ServletConfig</code> interfaces.
      .
    </div>

    <div class="sub-heading">The javax.servlet.http Package</div>
    <div>
      - The preceding examples have used the classes and interfaces defined in javax.servlet. However, when
      working with HTTP, you will normally use the interfaces and classes in <code>javax.servlet.http</code>.
      <br>
      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Interface</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>HttpServletRequest</td>
          <td>Extends the <code>ServletRequest</code> interface to enable servlets to read data from the HTTP
            Request
          </td>
        </tr>
        <tr>
          <td>HttpServletResponse</td>
          <td>Extends the <code>ServletResponse</code> interface to enable servlets to write data to an HTTP
            response
          </td>
        </tr>
        <tr>
          <td>HttpSession</td>
          <td>Provides a way to identify a user across more than one page request or visit to a Web site and
            to store information about that user.
          </td>
        </tr>
        </tbody>
      </table>

      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Class</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Cookie</td>
          <td>Allows state information to be stored ona Client machine
          </td>
        </tr>
        <tr>
          <td>HttpServlet</td>
          <td>Provides methods to handle HTTP requests and responses.
          </td>
        </tr>
        </tbody>
      </table>
    </div>

    <div class="sub-heading">The HttpServletRequest Interface</div>
    <div>
      - Extends the <code>ServletRequest</code> interface to provide request information for HTTP servlets.
      <br>
      - The servlet container creates an <code>HttpServletRequest</code> object and passes it as an argument to
      the servlet's service methods (doGet, doPost, etc).
      <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html">Java EE Link to
      the methods</a>
    </div>

    <div class="sub-heading">The HttpServletResponse Interface</div>
    <div>
      - Extends the <code>ServletResponse</code> interface to provide HTTP-specific functionality in sending a
      response. For example, it has methods to access HTTP headers and cookies.
      <br>
      - The servlet container creates an <code>HttpServletResponse</code> object and passes it as an argument to
      the servlet's service methods (doGet, doPost, etc).
      <br>
      - Several constants are defined that correspond to the different status codes that can be assigned to a HTTP
      Response.
      <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html">Java EE Link to
      the methods</a>
    </div>

    <div class="sub-heading">The HttpSession Interface</div>
    <div>
      - Provides a way to identify a user across more than one page request or visit to a Web site and to store
      information about that user.
      <br>
      - The servlet container uses this interface to create a session between an HTTP client and an HTTP server.
      The session persists for a specified time period, across more than one connection or page request from the
      user. A session usually corresponds to one user, who may visit a site many times. The server can maintain a
      session in many ways such as using cookies or rewriting URLs.
      <br>
      - This interface allows servlets to:
      <ul>
        <li>View and manipulate information about a session, such as the session identifier, creation time, and
          last accessed time
        </li>
        <li>Bind objects to sessions, allowing user information to persist across multiple user connections</li>
      </ul>
      - //<b>TODO:</b>
      <br>
      - When an application stores an object in or removes an object from a session, the session checks whether
      the object implements <code>HttpSessionBindingListener</code>. If it does, the servlet notifies the object
      that it has
      been bound to or unbound from the session. Notifications are sent after the binding methods complete. For
      session that are invalidated or expire, notifications are sent after the session has been invalidated or
      expired.
      <br>
      - When container migrates a session between VMs in a distributed container setting, all session attributes
      implementing the <code>HttpSessionActivationListener</code> interface are notified.
      <br>
      - A servlet should be able to handle cases in which the client does not choose to join a session, such as
      when cookies are intentionally turned off. Until the client joins the session, <code>isNew</code> returns
      true. If the client chooses not to join the session, <code>getSession</code> will return a different session
      on each request, and <code>isNew</code> will always return true.
      <br>
      - Session information is scoped only to the current web application (<code>ServletContext</code>), so
      information stored in one context will not be directly visible in another.
      <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html">Java EE Link to
      the methods</a>
    </div>

    <div class="sub-heading">The Cookie Class</div>
    <div>
      - The Cookie class encapsulates a cookie. A cookie is stored on a client and contains state information.
      <br>
      - Cookies are valuable for tracking user activities. For example, assume that a user visits an online store.
      A cookie can save the user's name, address, and other information. The user does not need to enter this data
      each time he or she visits the store.
      <br>
      - A servlet can write a cookie to a user's machine via the <code>addCookie()</code> method of the <code>HttpServletResponse</code>
      interface. The data for that cookie is then included in the header of the HTTP response that is sent to the
      browser. The names and values of cookies are stored on the user's machine.
      <br>
      - Some of the information that can be saved for each cookie includes the following:
      <ul>
        <li>The name of the cookie</li>
        <li>The value of the cookie</li>
        <li>The expiration date of the cookie</li>
        <li>The domain and path of the cookie</li>
      </ul>
      - The expiration date determines when this cookie is deleted from the user's machine. If an expiration date
      is not explicitly assigned to a cookie, it is deleted when the current browser session ends.
      <br>
      - The domain and path of the cookie determine when it is included in the header of an HTTP request. If the
      user enters a URL whose domain and path match these values, the cookie is then supplied to the web server.
      Otherwise, it is not.
      <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html">Java EE Link to
      the methods</a>
    </div>

    <div class="sub-heading">The HttpServlet Class</div>
    <div>
      - The <code>HttpServlet</code> class extends <code>GenericServlet</code>. It is commonly used when
      developing servlets that receive and process HTTP requests.
      <br>
      - Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site. A subclass
      of <code>HttpServlet</code> must override at least one method, usually one of these:
      <ul>
        <li><code>doGet</code>, if the servlet supports HTTP GET requests</li>
        <li><code>doPost</code>, for HTTP POST requests</li>
        <li><code>doPut</code>, for HTTP PUT requests</li>
        <li><code>doDelete</code>, for HTTP DELETE requests</li>
        <li><code>init</code> and <code>destroy</code>, to manage resources that are held for the life of the
          servlet
        </li>
        <li><code>getServletInfo</code>, which the servlet uses to provide information about itself</li>
      </ul>
      - There's almost no reason to override the <code>service</code> method. service handles standard HTTP
      requests by dispatching them to the handler methods for each HTTP request type (the doXXX methods listed
      above).
      Likewise, there's almost no reason to override the <code>doOptions</code> and <code>doTrace</code> methods.
      <br>
      - Servlets typically run on multi-threaded servers, so be aware that a servlet must handle concurrent
      requests and be careful to synchronize access to shared resources. Shared resources include in-memory data
      such as instance or class variables and external objects such as files, database connections, and network
      connections.
      <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">Java EE Link to
      the methods</a>
    </div>

    <div class="sub-heading">Using Cookies</div>
    <div>
      //TODO: There is an example in the book that you have to code
    </div>

    <div class="sub-heading">Session Tracking</div>
    <div>
      - HTTP is a stateless protocol. Each request is independent of the previous one. However, in some
      applications, it is necessary to save state information so that information can be collected from several
      interactions between a browser and a server. Sessions provide such a mechanism.
      <br>
      - A session can be created via the <code>getSession()</code> method of <code>HttpServletRequest</code>. An
      <code>HttpSession</code> object is returned. This object can store a set of bindings that associate names
      with objects. The <code>setAttribute()</code>,
      <code>getAttribute()</code>, <code>getAttributeNames()</code>, and <code>removeAttribute()</code> methods of
      <code>HttpSession</code> manage these bindings. Session state is shared by all servlets that are associated
      with a client.
    </div>

    <div class="row">
      <img src="./Snaps/Notatbility.png" class="center-block img-fluid"
           alt="Step1"
           width=1811>
    </div>


  </div>
  <hr>
  <div id="head-first">
    These are my notes from the book - Head First: Servlets and JSP
  </div>

  <hr>
  <div id="Ch1" class="chapter">Chapter 1: Why use Servlets and JSPs</div>
  <hr>
  <div class="textual-content">
    - To prevent deployment problems that come with building stand alone apps, we instead deploy our apps to the
    browser.
    <div class="row">
      <img src="./Snaps/Servers_And_Clients.PNG" class="center-block img-fluid" alt="Servers_And_Clients"
           width="500">
    </div>
    <br>

    <div class="sub-heading">Terminology</div>

    <p class="inline-heading">Web Server</p>:
    A web browser lets a user request a resource. The web server receives the request, finds the resource,
    and
    then sends it back to the user. A resource can be anything - HTML page, image, PDF File. If the
    requested
    resource is not found, the server replies with a <code>404-Not Found</code> error code.
    A web server can refer to either the physical machine (hardware) or the web server application
    (software). <br>
    <p class="inline-heading">Web Client</p>:
    Both the human and the browser application (Mozilla, Chrome) being used are referred to as the Web
    Client. A
    web browser can communicate with the web server. It can interpret the HTML code that is sent as a part
    of
    the server's response and render that web page. Hence a Web Client (browser) lets the user request
    something
    from the server and shows the user the result of that request. <br>
    <p class="inline-heading">HTML</p>: When a server answers a request, the server usually sends some type of
    content for the
    browser to display. This content is written in HTML. Two important tags in HTML are:
    <code>form</code> and <code>input</code> <br>
    <div class="code-block">
      <div class="expand-code-snip-btn border border-primary rounded">
        <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
      </div>
      <div class="code-snippet">
        <script src="https://gist.github.com/rgbk21/7ccd6f864eb2faf71f645955dfe6c4d2.js"></script>
      </div>
    </div>
    <p class="inline-heading">HTTP</p>: Most of the conversations held on the web between clients and servers are
    held using HTTP
    Protocol, which allows for simple request-response type conversations. The client sends an
    <code>HTTP Request</code> and the Server responds with a <code>HTTP Response</code>.
    HTTP runs on top of TCP/IP. The structure of and HTTP conversation is a simple Request/Response.
    <br>

    <div class="sub-heading">Key elements of the request stream</div>
    <li>HTTP Method Name(the action to be performed): The method name tells the server the kind of
      request that is being made, and how the rest of the message will be formatted. The
      <code>HTTP</code> protocol has several methods, but we mostly use <code>GET</code> and
      <code>POST</code>
      methods.
      <ul>
        <li><code>GET</code>: Gets a resource (HTML page, image, file,..) from the server and sends
          it back to the Client. You can also send some data (from the Client to the Server) with
          a <code>GET</code> request, but
          this is not recommended. Firstly, because the number of characters that are sent via a
          <code>GET</code> request are limited and secondly all the data sent in a
          <code>GET</code> request is visible in the URL. The "?" separates the path and the
          parameters. Together, the entire String is the request that is the URL that is sent with
          the request.
          <div class="row">
            <img src="./Snaps/GET_REQUEST.PNG" class="center-block img-fluid" alt="GET_REQUEST"
                 width="600">
          </div>
        </li>
        <li><code>POST</code>: With POST, you can request something and at the same time send form
          data to the server. For eg., if the user has completed a long form, you want this data
          to be stored into a database. In this case you would use a <code>POST</code> method. The
          data to be sent back to the server is known as the "payload" or the "message body".
          <div class="row">
            <img src="./Snaps/POST_REQUEST.PNG" class="center-block img-fluid"
                 alt="POST_REQUEST"
                 width="600">
          </div>
        </li>
      </ul>
    </li>
    <li>The page to access (a URL)</li>
    <li>Form parameters (like arguments to a method). These are sometimes also called "query strings"
    </li>


    <div class="sub-heading">Key elements of the response</div>
    <li>A status code (for whether the request was successful)</li>
    <li>Content-type (text, picture, HTML). Also known as MIME type</li>
    <li>The actual content</li>
    <div>
      <img src="./Snaps/HTTP_RESPONSE.PNG" class="center-block img-fluid" alt="HTTP_RESPONSE"
           width="600">
    </div>
    - An HTTP response can contain HTML. HTTP adds a Header to the response generated by the server. This
    Header information helps the client process the response. Inside this response can be a
    <code>&lt;html&gt;&lt;/html&gt;</code> that the client then renders as the HTML page that we finally see.
    <br>

    <div class="sub-heading">All the pieces in one page</div>
    <div class="row">
      <img src="./Snaps/All-The-Pieces.PNG" class="center-block img-fluid" alt="All-The-Pieces"
           width="500">
    </div>


    <div class="sub-heading">What is a URL</div>
    <div>
      - Note the part labeled as <i>Resource</i>. Resource is the name of the content being requested. This could
      be an HTML page, a servlet, an image, pdf, or anything else. <i>If this optional part of the URL is left
      out, most web servers will look for <code>index.html</code> by default.</i>
      <img src="./Snaps/Whta_Is_URL.PNG" class="center-block img-fluid" alt="What_Is_URL"
           width="600">
    </div>

    <div class="sub-heading">What is a TCP Port</div>
    <div>
      - A TCP port is a 16-bit number that uniquely identifies the software that is running
      on the server hardware. They are NOT physical ports on a system. They are just numbers representing an
      applications. As per the standard, the HTTP Server Software runs on Port 80. Without port numbers, the
      Server would have no way of telling which application/software a Client wants to connect to. <br>
      - Think of a port as a logical connection to a particular piece of software that is running on the server
      hardware. <br>
      - There are a bunch of other ports that are pre-defined to connect to specific services. The TCP ports from
      0 to 1023 are reserved for well-known services. Don't use these ports for your own custom programs.
    </div>

    <div class="sub-heading">Two things the Server won't do on its own</div>
    <div>
      <li>Dynamic Content: The Web Server Application serves only static pages, but a separate "helper"
        application that the web server can communicate with can build non-static, just-in-time web
        pages.
        Just-in-time web pages do not exist before the request comes in. Once the request comes in, the
        helper app "writes" the HTML and the web server sends the page back to the Client as if it were
        a static web page.
      </li>
      <li>Saving data on the Server: A Web Server cannot process form data. To process that form data, either to
        save it to a file or database or even just to use it to generate the response page, you need another
        app. When the web server sees a
        request for a helper app, it assumes that all of the parameters are meant for the Helper app. Hence the
        web server hands over the parameters and gives the app a way to generate a response to the client.
      </li>
    </div>

    <div class="sub-heading">What is a Servlet? And what is JSP?</div>
    <div>
      - The Helper App in Java is known as a Servlet. So a Servlet is just some Java code. But when the web
      server
      calls the helper Servlet, it expects HTML code in return. This is done by using using the <code>PrintWriter.println()</code>
      method. The HTML code that is to be returned to the web server is included as a <code>String</code> type
      argument in the <code>println()</code> method. As you can hope, stuffing properly formatted HTML tags
      into
      the <code>println()</code>is not a viable solution. For eg. you will have to manually escape every quote
      character (") because Java treats them as end of string character. And HTML happens to use a ton of
      quotes
      to specify the attribute values and what not.
      <br>
      - To solve this problem, JSPs were introduced. This allows us to add Java code to HTML instead of
      writing HTML code in a Java class. The JSP page contains java variables that calls the main Java code and
      creates the completed HTML page as a JIT web page. <br>
      - Read more about <a href="https://stackoverflow.com/questions/7213541/what-is-java-servlet">what a servlet
      is on SO here</a>. A servlet is simply a class which responds to a particular type of network request - most
      commonly an HTTP request. Basically servlets are usually used to implement web applications - but there are
      also various frameworks which operate on top of servlets (e.g. Struts) to give a higher-level abstraction
      than the "here's an HTTP request, write to this HTTP response" level which servlets provide.
      Servlets run in a servlet container which handles the networking side (e.g. parsing an HTTP request,
      connection handling etc). One of the best-known open source servlet containers is Tomcat.
      <br>
    </div>
  </div>

  <hr>
  <div id="Ch2" class="chapter">Chapter 2: Web App Architecture</div>
  <hr>
  <div class="textual-content">

    <div class="sub-heading">What is a Container</div>
    <div>
      - Servlets don't have a <code>main()</code> method. They are under the control of another Java application
      known as the <code>Container</code>.
      <br>
      - Apache is you web server application. Tomcat is your Container. <br>
      - When your web server application gets a
      request for a <code>Servlet</code> (as opposed to, say, a plain static HTML page) the server hands the
      request not to the servlet itself, but to the <code>Container</code> in which the servlet is <i>deployed</i>.
      <br>
      - It's the Container that gives the Servlet the HTTP Request and Response, and it's the Container that calls
      the servlet's methods like <code>doGet()</code> and <code>doPost()</code>.
      <div class="row">
        <img src="Snaps/Ch2/ContainerDescription.png" class="center-block img-fluid"
             alt="ContainerDescription"
             width="500">
      </div>
    </div>


    <div class="sub-heading">What does the Container give you?</div>
    <div>
      <li><p class="inline-heading">Communication Support</p>: The Container(Tomcat) provides an easy way for your
        Servlets to talk
        to your Web
        Server. You don't have to build a ServerSocket, listen on a port, create Streams, etc. The Container
        knows the protocol between the Web Server and itself, so that your Servlet does not have to worry
        about, say, the API between the Apache Web Server and your own web application code.
      </li>
      <li><p class="inline-heading">Lifecycle Management:</p> The Container controls the life and death of you
        servlets. It takes
        control of loading the classes, instantiating and initializing the servlets, invoking the servlets
        methods, and making servlets instances available for garbage collection. With the Container in
        control, you do not have to worry about the resource management.
      </li>
      <li>
        <p class="inline-heading">Multithreading Support:</p> The Container automatically creates a new Java
        thread for every
        servlet request that it receives. When the Servlet's done running the HTTP <code>service()</code>
        method for that Client's request, the thread completes (dies). But you are still responsible for
        Thread safety and other synchronization issues. It's just that the work involved in creating and
        deleting threads is reduced.
      </li>
      <li>
        <p class="inline-heading">Declarative Security:</p> XML Deployment Descriptors allow you to configure
        Security without
        having to hard-code it into any of your servlets or other classes.
      </li>
      <li><p class="inline-heading">JSP Support: </p>
        Container also takes care of translating the JSP code into real Java.
      </li>
    </div>


    <div id="HowTheContainerHandlesRequest" class="sub-heading">How the Container handles a request</div>
    <div>

      <p class="inline-heading">Step 1: </p> User clicks on a link that has a URL to a servlet instead of a static
      web page
      <div class="row">
        <img src="Snaps/Ch2/Step-1.png" class="center-block img-fluid"
             alt="Step1"
             width="500">
      </div>

      <p class="inline-heading">Step 2: </p> The Container "sees" that the request is for a Servlet, so the
      container creates two objects:
      <code>HttpServletRequest</code> and
      <code>HttpServletResponse</code>
      <div class="row">
        <img src="Snaps/Ch2/Step-2.png" class="center-block img-fluid"
             alt="Step2"
             width="500">
      </div>

      <p class="inline-heading">Step 3: </p> The Container finds the correct Servlet based on the URL in the
      request, creates or allocates a thread for that request, and calls the servlet's
      <code>service(HttpServletRequest req, HttpServletResponse resp)</code> method, passing the request and
      response objects as arguments .
      <div class="row">
        <img src="Snaps/Ch2/Step-3.png" class="center-block img-fluid"
             alt="Step3"
             width="500">
      </div>

      <p class="inline-heading">Step 4: </p> Depending on the type of
      the request, the <code>service()</code> methods calls either the <code>doGet()</code> or
      <code>doPost()</code> methods. For this example, we assume that the request was a HTTP GET method. So the
      <code>service()</code> method calls the servlet's
      <code>doGet(HttpServletRequest req, HttpServletResponse resp)</code> method passing the request and the
      response objects as arguments.
      <div class="row">
        <img src="Snaps/Ch2/Step-4.png" class="center-block img-fluid"
             alt="Step4"
             width="500">
      </div>

      <p class="inline-heading">Step 5: </p> The <code>doGet()</code> method generates the dynamic page and stuffs
      the page into the
      response object. Remember that the Container still has a reference to the Response object.
      <div class="row">
        <img src="Snaps/Ch2/Step-5.png" class="center-block img-fluid"
             alt="Step5"
             width="500">
      </div>

      <p class="inline-heading">Step 6: </p> The thread completes, so the thread either dies or returns to a
      Container-managed thread pool. The container converts the response object into an HTTP Response,
      sends it back to the client, and then deletes the request and the response object.
      <div class="row">
        <img src="Snaps/Ch2/Step-6.png" class="center-block img-fluid"
             alt="Step6"
             width="500">
      </div>
    </div>

    <div class="sub-heading">What makes a Servlet a Servlet</div>
    <div>
      - Note that a Servlet class (in the below example image <code>Ch2Servlet</code>) does not have a <code>main()</code>
      method. It only has a <code>doGet()</code> method. In the below example, we are basically overriding the
      <code>doGet</code> method of the <code>HttpServlet</code> class.
      <div class="row">
        <img src="Snaps/Ch2/AServletIsAServlet.png" class="float-left img-fluid"
             alt="Servlet?"
             width="600">
      </div>
      - <code>HttpServlet</code> is an <code>abstract</code> class that to be subclassed to create an HTTP servlet
      suitable for a Web site. A subclass of HttpServlet must override at least one method, usually one of these:
      <br>
      <li><code>doGet</code>, if the servlet supports HTTP GET requests</li>
      <li><code>doPost</code>, for HTTP POST requests</li>
      <li><code>doPut</code>, for HTTP PUT requests</li>
      <li><code>doDelete</code>, for HTTP DELETE requests</li>
      <li><code>init</code> and <code>destroy</code>, to manage resources that are held for the life of the
        servlet
      </li>
      <li><code>getServletInfo</code>, which the servlet uses to provide information about itself</li>
      - There's almost no reason to override the <code>service</code> method. <code>service</code> handles
      standard HTTP requests by dispatching them to the handler methods for each HTTP request type (the doXXX
      methods listed above). <br>
      - <a href="http://csc.columbusstate.edu/woolbright/java/Servlets.html">Source for the below text</a>. <br>
      - Servlet API classes reside in <code>javax.servlet</code> and <code>javax.servlet.http</code>. <br>
      - These packages are distributed with Tomcat. Tomcat is a open source servlet container and webserver. <br>
      - The javax.servlet package contains three interfaces: <br>
      a) Servlet - init(), service(), destroy() <br>
      b) ServletRequest <br>
      c) ServletResponse <br>
      - The <code>javax.servlet.http</code> package supplies interfaces that make it easy to build servlets that
      support HTTP requests and responses. Two important interfaces in <code>javax.servlet.http</code> are
      <code>HttpServletRequest</code> and <code>HttpServletResponse</code>. <br>
      - The <code>HttpServlet</code> class extends <code>GenericServlet</code> and is used to develop servlets
      that handle HTTP requests.
    </div>


    <div class="sub-heading">When a Client clicks on a URL containing a Servlet in Step 1, how does the Container
      know which Servlet
      to call?
    </div>
    <div>
      - //TODO: I no longer understand what is going on over here.Why do we need three names. Whats is the
      difference between the second and the third option? <a
      href="https://stackoverflow.com/questions/20073905/why-do-we-need-a-servlet-name">Maybe this SO Link has
      the answer</a>. <br>
      - Consider a compiled Servlet class that is present in the following directory:
      <code>classes/registration/SignUpServlet.class</code> <br>
      - The Servlet can be called using any of the following 3 names:
      <li>File Path Name (XXXX.class name): This (classes/registration/SignUpServlet.class) is the ACTUAL name of
        the .class file that is stored on the server and denotes it's actual path in the directory.
      </li>

      <li>Public URL Name: The name encoded into the HTML so that when the user clicks a link that is supposed
        to go to that servlet, this public URL is sent to the Server in the HTTP Request.
      </li>
      <li>Deployment Name: It is a secret internal name (not known to the Client) that is given to the .class
        file. This <i>can</i> be the same as the File Path Name, but can be something completely different
        as well.
      </li>
      - Thus we can <i>map</i> the Public URL to a Deployment name and have that Deployment name refer to a .class
      file.
      <br>
      - Why do we do this:
      <ul>
        <li>Flexibility: We can change the path of the .class file without breaking the path of every file that
          referenced this class file
        </li>
        <li>Security: We do not want the Client to know the internal directory structure of the Server.</li>
      </ul>
    </div>

    <div class="sub-heading">How do we map URLs to Servlets: Deployment Descriptors</div>
    <div>
      - When you deploy your servlet into your web Container, you will create an XML document called the
      <code>Deployment Descriptor</code> to tell the container how to run your Servlets and JSPs.
      <br>
      - We use two XML elements to map URLs to Servlets - one to map the Client-known <i>Public URL Name</i> to
      our own <i>internal deployment name</i>, and the other to map our own <i>internal deployment name</i> to the
      fully-qualified <i>class-name</i>.
      <br>
      //TODO:Where is the DD file stored in the IntelliJ project that we created? I am pretty sure it is just the
      <code>web.xml</code> file in your project.
      <br>
      - The two DD elements for URL Mappings are:
      <ul>
        <li><code>&ltservlet&gt</code>: maps internal name to fully-qualified class name</li>
        <li><code>&ltservlet-mapping&gt</code>: maps internal name to public URL name</li>
      </ul>
      - DD also helps us to customize other aspects of our web application like adding security roles, error
      pages, tag libraries. All this can be done without changing the source code.
      <div class="row">
        <img src="Snaps/Ch2/DeploymetnDescriptor.png" class="center-block img-fluid"
             alt="DeploymentDescriptor"
             width="650">
      </div>
      - Note that the <code>&ltservlet-class&gt</code> tag still contains only the class name and not the complete
      path of the the .class file. This is because the Container has a specific place that it will look for all
      Servlets for which you have specified a mapping in the DD. <br>
      - There is a lot of other stuff that you can do using the <code>web.xml</code> file. Refer <a
      href="https://docs.oracle.com/cd/E13222_01/wls/docs81/webapp/web_xml.html">this Oracle link</a> to see
      which elements can be defined using your deployment descriptor.
    </div>


    <div class="sub-heading">What is MVC: Model-View-Controller</div>
    <div>
      - The essence of MVC is that you separate the business logic from the presentation, but put something in <i>between</i>
      them so that the business logic can stand on its own as a reusable Java class, and doesn't have to know
      anything about the view. In other words, the business logic should never go into the Servlet. Because the
      Servlet contains the JSP page, it means that the business logic is tied to the JSP page. We cannot re-use
      the business logic for some other kind of view, like a GUI. The business logic should always be in a
      standalone Java class that can be reused.
      <br>
      - This is how the code looks without using MVC:
      <div class="row">
        <img src="./Snaps/Ch2/Without-MVC.png" class="center-block img-fluid"
             alt="MVC"
             width="1000">
      </div>

      - Model-View-Controller takes the business logic out of the Servlet and puts it in a "Model" - a reusable
      plain old Java class. The Model is a combination of the business data and the methods that operate on the
      data.

      <div class="row">
        <img src="Snaps/Ch2/MVC.png" class="center-block img-fluid"
             alt="MVC"
             width="650">
      </div>
      - Thus for each Servlet, there will be a new business logic class that will be the <code>Model</code>, a JSP
      page that will be the <code>View</code>, and the original Servlet, bereft of any logic or HTML, that will
      form
      the <code>Controller</code> part of the puzzle.
      <div class="row">
        <img src="Snaps/Ch2/MVC-IN-Action.png" class="center-block img-fluid"
             alt="MVC"
             width="650">
      </div>
      - But now the problem is that there are a gazillion little Servlets, and all they are doing is updating the
      Model and then displaying the View. Lot of code duplication apparently...
    </div>

    <div class="sub-heading">Overview of separation of concerns</div>
    <div class="row">
      <img src="Snaps/Ch2/Table.png" class="center-block img-fluid"
           alt="Table"
           width="650">
    </div>


    <div class="sub-heading">How does J2EE fit into all of this</div>
    <div>
      The Java 2 Enterprise Edition is kind of a super-spec - it incorporates other specifications, including the
      Servlets 2.4 Spec and the JSP 2.0 spec. That's for the Web Container. But the J2EE 1.4 spec also includes
      the Enterprise JavaBean 2.1 specification, for the EJB Container. In other words, the web container is for
      the <i>web</i> components (servlets and JSPs) whereas the EJB Container is for the <i>business</i>
      components.
      <br>
      - A fully-compliant J2EE server must have <i>both</i> a web Container and an EJB Container (plus other
      things including a JNDI and JMS implementation). Tomcat is just a web Container!(?). It is still compliant
      with the portions of J2EE spec that address the web container. Tomcat is a web container, not a full J2EE
      application server, because Tomcat does not have an EJB Container. <br>
      - As shown in the below figure, a J2EE application server consists of both a web container and an EJB
      Container. Tomcat is a web Container but not a full J2EE Application server.
      <img src="Snaps/Ch2/J2EE_Application_Server.png" class="center-block img-fluid"
           alt="J2EE Application Server"
           width="650">
    </div>
  </div>


  <hr>
  <div id="Ch3" class="chapter">Chapter 3: Mini MVC Tutorial</div>
  <hr>

  <div class="textual-content">
    - The process for creating a <a
    href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-ee-application.html#3f8fcb52">Enterprise
    Application in IntelliJ can be found here</a>.

    <div class="sub-heading" id="app_architecture">Architecture of the Web App</div>
    <div>
      <div class="row">
        <img src="Snaps/Ch3/MyBeerApp-Architecture.png" class="center-block img-fluid"
             alt="MyBeerApp-Architecture"
             width="750">
      </div>
    </div>

    <div class="sub-heading">Creating the Development Environment</div>
    <div>
      <p>
        -<code>index.jsp</code> is the file that contains the first page that the user sees when they login into
        the <code>http://localhost:8080/BeerV2_war_exploded/</code>. Changing the name of <code>index.jsp</code>
        to some other name causes the app to stop working for some reason.
        <br>
        - The <code>web.xml</code> is the Deployment Descriptor that we looked at in the previous chapter. br
        - When it's time to deploy our app, we will copy a portion of this into wherever our particular
        Container wants the pieces to go.
      </p>
      <div class="row">
        <img src="./Snaps/Ch3/Development-Environment.png" class="center-block img-fluid"
             alt="Development-Environment"
             width="1000">
      </div>
    </div>

    <div class="sub-heading">Tomcat log when app was deployed successfully</div>
    <div>
      - This is an example of Tomcat Log generated when the Web-App was deployed successfully.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/d37b5c60853094b332ce7a976dc94161.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">Creating the Deployment Environment:</div>
    <div>
      - Deploying an app requires both container-specific rules and requirements of the Servlets and JSP
      Specifications. Everything below the <i>Beer-v1</i> directory is the same regardless of your container. Only
      the folder structure above that that is marked as <i>Tomcat-specific</i> will differ. <br>
      - Note that the <i>Beer-v1</i> directory represents the <i>context root</i> which Tomcat uses when resolving
      URLs.
      <div class="row">
        <img src="./Snaps/Ch3/Deployment-Environment.png" class="center-block img-fluid"
             alt="Deployment-Environment"
             width="1100">
      </div>
    </div>

    <div class="sub-heading">Building the App</div>
    <div>

      <a href="#app_architecture"><p class="inline-heading">Step 1</p></a>: The Client makes a request for the
      form.html page
      <br>


      <a href="#app_architecture"><p class="inline-heading">Step 2</p></a>: The Container retrieves the form.html
      page
      <br>


      <a href="#app_architecture"><p class="inline-heading">Step 3</p></a>: The Container returns the page to the
      browser where the user
      answers the question on the form and Clicks Submit
      <div class="row">
        <img src="Snaps/Ch3/Form.png" class="center-block img-fluid"
             alt="Form"
             width="400">
      </div>
      - Clicking the SUBMIT button causes the HTML form to send a <code>POST</code> request to the server. This
      request is sent to the <code>SelectBeer.do</code> file (Line 20). Remember that there is no actual class
      named such. It's mapped to an internal Servlet name using the Deployment Descriptors.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div id="Step3" class="code-snippet">
          <script src="https://gist.github.com/rgbk21/455e078ee0d33fe25ef7e6e215deb3c5.js"></script>
        </div>
      </div>
      - Note the URL to which the POST request is being sent to
      <code>POST /BeerRecommender_war_exploded/SelectBeer.do</code>. In the HTML, the <code>/BeerRecommender_war_exploded/</code>
      isn't part of the path in the HTML, it just says:
      <code>&lt;form method="POST" action="SelectBeer.do"&gt;</code>
      But the browser prepends the <code>/BeerRecommender_war_exploded/</code> on to the request because that's
      where the client request is coming from. In other words, the <code>SelectBeer.do</code> is relative to the
      root of the web app <code>/BeerRecommender_war_exploded</code>
      <div class="row">
        <img src="./Snaps/Ch3/Request_URL.png" class="center-block img-fluid"
             alt="Request URL"
             width="500">
      </div>
      <div class="row">
        <img src="Snaps/Ch3/POST_Request_Headers.png" class="center-block img-fluid"
             alt="Form"
             width="1690">
      </div>

      <a href="#app_architecture"><p class="inline-heading">Step 4</p></a>: The browser sends the request data to
      the Container.
      Now the Container has to figure out which is the actual Class to which the <code>SelectBeer.do</code> maps.
      <br>
      - For this, the Container looks in the <code>web.xml</code> file (Deployment Descriptor). The container
      searches the DD and finds a <code>&lt;servlet-mapping&gt;</code> with a <code>&lt;url-pattern&gt;</code>
      that matches <code>/SelectBeer.do</code> where the <code> / </code> represents the context root of the web
      app, and <code>SelectBeer.do</code> is the logical name of the resource. <br>
      - The container sees that the <code>&lt;servlet-name&gt;</code> for this <code>&lt;url-pattern&gt;</code> is
      'Ch3 Beer'. But that isn't the name of the actual servlet class file. To a container a servlet is something
      that is named in the DD under the <code>&lt;servlet&gt;</code> tag. The 'name' of the servlet is simply
      the name used in the DD so that other parts of the DD can map to it. <br>
      - So now the container looks inside the <code>&lt;servlet&gt;</code> tags for something with the
      <code>&lt;servlet-name&gt;</code> 'Ch3 Beer'. <br>
      - The Container uses the <code>&lt;servlet-class&gt;</code> in the <code>&lt;servlet&gt;</code> tag to know
      which servlet class is responsible for handling this request. If the servlet has not been initialised, the
      class is laoded and the servlet is initialized. <br>
      - The Container then starts a new thread to handle the request, and passes the request to the thread
      (to the servlet's <code>service()</code> method).
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/c932fc1d0153401e578ea9037ed0b428.js"></script>
        </div>
      </div>

      <a href="#app_architecture"><p class="inline-heading">Step 5</p></a>: The Container finds the correct
      Servlet and passes the
      request to the Servlet. This class
      acts as the Controller, calling the Model <code>BeerExpert</code> for the business logic, and the View
      <code>result.jsp</code> for the response.

      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div id="setAttributeExample" class="code-snippet">
          <script src="https://gist.github.com/rgbk21/94dbb35d88a6d04c4f1f44c75f1e8d18.js"></script>
        </div>
      </div>

      <br>
      <a href="#app_architecture"><p class="inline-heading">Step 6</p></a>: The Servlet calls the BeerExpert class
      for help.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/f2f3e7794dd719fc9f752776ed97e16b.js"></script>
        </div>
      </div>

      <a href="#app_architecture"><p class="inline-heading">Step 7</p></a>: The BeerExpert class returns an answer
      that the Servlet class
      adds to the request
      object.
      <br>
      The Container provides a mechanism called "Request Dispatching" that allows one container-manged component
      to call another container-managed component. This is what we use here - the Servlet gets the info from the
      model, saves it in the request object, then dipatches the request to the JSP.
      <br>
      <a href="#app_architecture"><p class="inline-heading">Step 8</p></a>: The Servlet forwards the request to
      the JSP.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/0cf2bcafb2f011b8ca5a9bbcded5d011.js"></script>
        </div>
      </div>
      <a href="#app_architecture"><p class="inline-heading">Step 9</p></a>: The JSP gets the answer from the
      request object.
      <br>
      <a href="#app_architecture"><p class="inline-heading">Step 10</p></a>: The JSP generates a page for the
      Container.
      <br>
      <a href="#app_architecture"><p class="inline-heading">Step 11</p></a>: The Container returns the page to the
      User.


    </div>

  </div>

  <hr>
  <div id="Ch4" class="chapter">Chapter 4: Request and Response - Being a Servlet</div>
  <hr>
  <div class="textual-content">
    - In the previous chapter we looked at <a href="#HowTheContainerHandlesRequest">the Container's overall role</a>
    in the Servlet's life. The container creates the request and the response objects, creates or allocates a new
    thread for the servlet, and calls the servlet's <code>service()</code> method, passing the request and response
    objects references as arguments.
    In this Chapter we look at the Servlet's life in more detail.
    <br>
    - The servlet lifecycle is pretty simple.. There is only one main state: <code>initialized</code>. If the
    servlet isn't initialized then it is either <i>being initialized</i> (by running it's constructor or the
    <code>init()</code> method), <i>being destroyed</i> (by running it's <code>destroy()</code>) method, or it
    simply does not exist. <br>
    - A state diagram for the servlet would look something like this:
    <div class="row">
      <img src="./Snaps/Ch4/Servlet_State_Diagram.PNG" class="center-block img-fluid"
           alt="Servlet state diagram"
           width="30">
    </div>

    <div class="sub-heading">What do the <code>init</code>, <code>service</code>, and <code>destroy</code> methods
      do?
    </div>
    - <p class="inline-heading"><code>init()</code></p>: The method is
    called after the servlet instance has been created (using the the default
    no-args constructor) but before the servlet can service any client requests. You can override this method in
    case you have to get a database connection, or you have to register yourself with other objects.
    <br>
    - <p class="inline-heading"><code>service()</code></p>: When the first Client request comes in, the Container
    starts a new thread or allocates
    a new thread from the pool and causes the servlet's <code>service()</code> method to be invoked. This method
    looks at the request, determines the HTTP method (GET, POST, etc.) and invokes the matching <code>doGet()</code>
    or <code>doPost()</code> methods respectively. Note that there are other methods in HTTP as well (HEAD, PUT,
    etc) and there are corresponding <code>doXXXXX()</code> methods for almost all of them. Refer the <code>HttpServlet</code>
    class below. You should not override the <code>service()</code> method. Your job is to override the <code>doGet()</code>
    or the <code>doPost()</code> methods, and let the <code>service()</code> implementation from the <code>HttpServlet</code>
    worry about calling the right one.
    <br>
    - <p class="inline-heading"><code>doPost()</code>/<code>doGet()</code></p>: The <code>service()</code> method
    invokes the <code>doGet()</code>
    or the <code>doPost()</code> based on the HTTP method (GET, POST, and so on). This is where your code begins.
    All the stuff that your app is supposed to be doing goes in here. Always override at least one of these methods.
    Whichever ones you override tells the Container what you support. If you do not override <code>doPost()</code>,
    for example, then you are telling the Container that this servlet does not support the HTTP POST request.
    <br>
    - <p class="inline-heading"><code>destroy()</code></p>: Called by the Servlet Container to take the Servlet out
    of service. This method is only called once all threads within the servlet's service method have exited or after
    a timeout period has passed. After the container calls this method, it will not call the <code>service()</code>
    method again on the Servlet.

    <div class="row">
      <img src="./Snaps/Ch4/Servlet_LifeCycle.PNG" class="center-block img-fluid"
           alt="Servlet_LifeCycle"
           width="600">
    </div>

    - The Servlet moves from the <i>does not exist</i> to the <i>initialized</i> state beginning with the
    constructor. But the constructor makes only the <i>object</i>, not the <i>Servlet</i>. When an object becomes a
    servlet, it gets all the unique privileges that come with being a servlet, like the ability to use it's <code>ServletContext</code>
    to get information from the Container. <br>


    <div class="sub-heading">Methods inherited by the Servlet that you create</div>
    - So overall the process proceeds like this: (refer below diagram) Suppose my servlet is the
    <code>MyServlet</code> class. The Container
    calls <code>MyServlet</code>'s <code>init()</code> method. But if I do not
    override <code>init</code>, the one from <code>GenericServlet</code> runs. Then when a request comes in, the
    Container starts or allocates a thread and calls the <code>service()</code> method, which I do not override. So
    the <code>service</code> method from the <code>HttpServlet</code> runs. The <code>HttpServlet</code> <code>service</code>
    method then calls my overridden <code>doGet</code> or <code>doPost</code> methods. <i>So each time my
    <code>doGet</code> or <code>doPost</code> runs, it's in a different thread.</i>
    <br>
    - The Servlet inherits the following methods:
    <div class="row">
      <img src="./Snaps/Ch4/Servlet_Inheritance.PNG" class="center-block img-fluid"
           alt="Servlet_Inheritance"
           width="600">
    </div>

    <div class="sub-heading">Each request runs in a separate thread</div>
    <div>
      - Remember that each Client request runs in a separate thread. At any given time, you will have at least as
      many
      runnable threads as there are client requests. <br>
      - You might hear things like "Each instance of the servlet..". This is incorrect. There aren't multiple <i>instances</i>
      of any servlet class (except SingleThreadModel, but that is a bad design pattern). The Container runs
      multiple
      <i>threads</i> to process multiple requests to a single servlet. And every Client request generates a new
      pair
      of request and response object.
      <div class="row">
        <img src="./Snaps/Ch4/Threaded.PNG" class="center-block img-fluid"
             alt="Threaded"
             width="600">
      </div>

    </div>

    <div class="sub-heading">What happens if the <i>same</i> client makes multiple request? Is it one thread per
      <i>client</i> or one thread per <i>request</i>?
    </div>
    <div>
      - It is one thread per request. The Container doesn't care who makes the request. Every incoming request
      means a new thread/stack. <br>
      <p class="inline-heading">thread-per-request vs thread-per-connection</p>: Per request means when an HTTP
      request is made, a thread is created or retrieved from a pool to serve it. One thread serves the whole
      request. Thread per connection would be the same thing except the thread is used for an entire connection,
      which could be multiple requests and could also have a lot of dead time in between requests. Servlet
      containers are thread per request. <a
      href="https://stackoverflow.com/questions/7457190/how-are-threads-allocated-to-handle-servlet-request">Source
      on SO</a>. <br>
      <p class="inline-heading">Should I spawn new threads in a JAVA EE Container</p>: If you're in a full Java
      EE container, threads may be managed for you in a way that makes it a bad idea to spawn your own.
      <a href="https://stackoverflow.com/a/8328113/8742428">Source on SO</a>. Also there are now Concurrency Utils
      that enable you to achieve this so that you do not have to do this manually.
      <a href="https://stackoverflow.com/questions/533783/why-is-spawning-threads-in-java-ee-container-discouraged">Source
        on SO</a>. <br>
      <p class="inline-heading">HttpServlet is in a different package from GenericServlet. How many servlet
        packages
        are there?</p> Everything related to servlets is in either <code>javax.servlet</code> or
      <code>javax.servlet.http</code>. It's easy to tell the difference because things that have to do with HTTP
      are in the <code>javax.servlet.http</code> package whereas the generic servlet classes and interfaces are in
      <code>javax.servlet</code>.
    </div>


    <div class="sub-heading">What does 'being a servlet' buy you?</div>
    <div>
      - Remember that the constructor just creates an object, not a <i>servlet</i>. To be a servlet, the object
      needs to be granted
      <i>servletness</i>. This is the task of the <code>init()</code> method. The <code>init()</code> method is
      called just once during the entire life of the servlet. <br>
      - A servlet allows you to access the following: <br>
      <p class="inline-heading">ServletConfig</p>: This controls the deploy-time values you've
      configured for the servlet (one per servlet). Things that your servlet might want to access that you do not
      want to hard code, like maybe a database name. <code>ServletConfig</code> parameters won't change for as
      long as this servlet is deployed and running. To change them, you will have to re-deploy the servlet. This
      is also used to access <code>ServletContext</code>. The parameters are configured in the Deployment
      Descriptor. <br>
      <p class="inline-heading">ServletContext</p>:There is only one <code>ServletContext</code> per web app, NOT
      one per servlet. These are used to access web app parameters that are also configured in the Deployment
      Descriptor.
    </div>


    <div class="sub-heading">What is a Request or a Response object?</div>
    <div>
      - The <code>HttpServletRequest</code> methods are about HTTP things like cookies, headers, and sessions.
      <code>HttpServletRequest</code> interface adds the methods that relate to the HTTP protocol. Same thing with
      the <code>HttpServletResponse</code> as well. <br>
      - <a
      href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html">ServletRequest</a>:
      A ServletRequest object provides data including parameter name and values,
      attributes, and an input stream. Interfaces that extend ServletRequest can provide additional
      protocol-specific data (for example, HTTP data is provided by <code>HttpServletRequest</code>). <br>
      - <a
      href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html">ServletResponse</a>:
      Defines an object to assist a servlet in sending a response to the client. The servlet container creates a
      ServletResponse object and passes it as an argument to the servlet's service method. <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html">HttpServletRequest</a>:
      Extends the <code>ServletRequest</code> interface to provide request information for HTTP servlets.
      The servlet container creates an HttpServletRequest object and passes it as an argument to the servlet's
      service methods (doGet, doPost, etc). <br>
      - <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html">HttpServletResponse</a>:
      Extends the <code>ServletResponse</code> interface to provide HTTP-specific functionality in sending a
      response. For example, it has methods to access HTTP headers and cookies.
      The servlet container creates an HttpServletResponse object and passes it as an argument to the servlet's
      service methods (doGet, doPost, etc). <br>
      - Remember that <code>HttpServletRequest</code> and <code>HttpServletResponse</code> are interfaces as well.
      The implementation of these interfaces is left to the vendor. All you need to know is the methods that you
      can call on these objects. The actual class does not matter because you are referring to the request and the
      response objects only by the <i>interface type</i>.
      <br>
      <div class="row">
        <img src="./Snaps/Ch4/ServletRequest_And_ServletResponse.PNG" class="center-block img-fluid"
             alt="Servlet_Inheritance"
             width="600">
      </div>

    </div>

    <br>
    - There are 8 HTTP methods (actually 9 now). There is no mechanism in the servlet API for handling <code>doConnect</code>,
    so it is not a part of the <code>HttpServlet</code>.
    <br>
    - Recall the difference between <code>GET</code> and <code>POST</code> that we studied earlier. The key
    difference between the two was
    that <code>POST</code> has a body, whereas in the <code>GET</code> request all of the parameters are sent in the
    header. Remember that <code>GET</code>is ONLY supposed to be <i>getting</i> things from the server. it should
    not make any changes to the server. <code>POST</code> on the other hand is used to send data to the server for
    <i>update</i>.
    <br>
    - This makes <code>GET</code> an <i>idempotent</i> request: making the same <code>GET</code> request twice will
    cause no negative consequences on the server.
    <br>
    - <code>POST</code>, on the other hand, is a <i>non-idempotent</i> request. The data sent to the server could be
    used to update some state that cannot be reversed. Think a financial transaction that cannot be reversed.
    Intuitive example in book.
    Basically, you want to ensure that your app logic can handle scenario where the same request comes in more than
    once by mistake.
    <br>
    - Note that there is nothing stopping you from <i>implementing</i> the <code>GET</code> method in the <code>doGet</code>
    method as an non-idempotent method. But you would not want to do so...
    <div class="sub-heading">What determines whether a browser sends a GET or POST request:</div>
    <div>
      - Remember the POST is not the default. If you do not specify a method, by default the GET method will be
      used.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/c4c574f87a7a6aaa46631a5a7d9559bb.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">How do you send multiple parameters using the POST request</div>
    <div>
      - In the previous POST request that we sent in <a href="#Step3">Step 3</a>, the browser sent only one of
      the four options (light/amber/brown/dark) as the value of the parameter <code>color1</code>. But what if we
      wanted two or more parameters from the user. This is how we would do it:
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/6d7be68624a849802d8450ff82db8b01.js"></script>
        </div>
      </div>
      - If in the previous case the POST request sent the values of the parameters as <code>color1=light</code>,
      in
      this example the parameters will be sent as <code>color1=light&theSize=heavy</code>. That is - the POST
      request will have both the parameters but separated by an ampersand.
      <br>
      - The Servlet class would then use the parameters in the following manner:
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/09cd12cd78f61d4a703ff0397484e00e.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">How do you use multiple values for a single parameter</div>
    <div>
      - Excellent explanation of checkboxes <a
      href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#using_checkbox_inputs">on
      MDN here</a>. A lot of good stuff there. Read the entire page. Basically each of the input of type checkbox
      should be given the same <i>name</i> attribute. <br>
      - In the previous example, you had one parameter <code>theSize</code> associated with just a single value
      (either light, medium, or heavy). However, some form inputs like checkboxes can have more than one value.
      That means a single parameter like <code>theSize</code> will could have more than one value depending on how
      many boxes the user has checked off. <br>
      - This is what the form looks like:
      <img src="./Snaps/Ch4/FrontEnd-Form.PNG" class="center-block img-fluid"
           alt="Multiple values for Checkbox"
           width="300">

      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/b143430a62b757498607e22deabee83f.js"></script>
        </div>
      </div>

      And the corresponding Servlet class would look like this:
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div id="usingSetAttribute" class="code-snippet">
          <script src="https://gist.github.com/rgbk21/327108fb2c388821c78d3d711e7ff2d2.js"></script>
        </div>
      </div>
      - The form data in the POST request will look like this when multiple checkboxes are selected: <br>
      <code>userName=&userEmailId=&beer_color_user_likes=light&user-newsletter=on&user-beer-sizes=12&user-beer-sizes=14</code>
      <br>
      - Assume on the front-end we selected the 12oz and 14oz checkboxes. In the below image you can see that <i>beer_sizes</i>
      in the servlet code contains the <i>value</i> associated with the checkboxes of 12oz and 14oz options. <br>
      <img src="./Snaps/Ch4/Multiple_Values_For_CheckBox.PNG" class="center-block img-fluid"
           alt="Multiple values for Checkbox"
           width="1840">
    </div>

    <div class="sub-heading">Besides the parameters, what else can I get from the Request object:</div>
    <div>
      - You really should look at the full API for <a
      href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html">javax.servlet.ServletRequest</a>
      and <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html">javax.servlet.http.HttpServletRequest</a>.

      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/2d8523049c4e793411f03e21311db7fe.js"></script>
        </div>
      </div>

      <br>
      - //TODO: Read up on the methods <a
      href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getInputStream--"><code>getInputStream</code></a>
      and <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getReader--"><code>getReader</code></a>.
      If one is called, then the other can't be called or something like that.
      <br>
      - Note the presence of the three different methods:
      <li>
        <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletRequest.html#getRemotePort--"><code>getRemotePort</code></a>:
        In this case, since it is the server asking, it's the Client that is the
        Remote. So <code>getRemotePort</code> means the <i>Client's</i> remote port. In other words, the
        port number on the Client from which the request was sent. Remember, if you are a servlet, remote
        means the Client.
      </li>
      <li>
        <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletRequest.html#getServerPort--"><code>getServerPort</code></a>:
        This method asks "to which port was the request <i>originally sent</i>"
      </li>
      <li>
        <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletRequest.html#getLocalPort--"><code>getLocalPort</code></a>:
        This method asks "on which port did the request ultimately <i>end up</i>".
        There is a difference between the above two methods because although the requests are <i>sent</i> to
        a single port (where the <i>server</i> is listening), the server turns around and finds a different
        local port for each thread so that the app can handle multiple clients at the same time.
      </li>
    </div>


    <div class="sub-heading">Understanding the Response Object</div>
    <div>
      - The Response is what goes back to the Client. Typically, you use the response object to get an output
      object (usually a Writer) and you use that Stream to write the HTML (or some other type of content) that
      goes back to the Client.
      <br>
      - You call two methods on the response: <code>setContentType</code> and <code>getWriter</code>. After that
      you are simply doing I/O to write HTML (or something else) to the stream. But you can also use the
      response to set other headers, send errors, and add cookies.
      <div class="row">
        <img src="./Snaps/Ch4/ServletResponse_Interface.PNG" class="center-block img-fluid"
             alt="ServletResponse_Interface"
             width="300">
      </div>
    </div>


    <div class="sub-heading">How do I send a application/jar type content in response instead of a normal HTML page
    </div>
    <div>
      - Instead of sending an HTML page, the response contains the bytes representing the JAR. You <i>read</i> the
      bytes of the jar file, and then <i>write</i> them to the response's output stream. For this we make use of
      the <a
      href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContext.html#getResourceAsStream-java.lang.String-"><code>getResourceAsStream</code></a>
      method. Note that there is another method called <code>getResourceAsStream</code> in the <code>Class</code>
      class
      <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream-java.lang.String-">as
        shown here on Java docs</a>. Both are different from each other. <br>
      - <a href="https://stackoverflow.com/questions/2797162/getresourceasstream-is-always-returning-null">This SO
      Link </a> goes into detail about ways to troubleshoot <code>getResourceAsStream</code> causing a NPE. There
      are a lot of linked questions on the page as well that should be helpful. <br>
      - <a
      href="https://stackoverflow.com/questions/2161054/where-to-place-and-how-to-read-configuration-resource-files-in-servlet-based-app">Answer
      by BalusC explaining different ways that you can access a file from your code</a>. Do you understand what a
      'classpath' actually means now?
      <br>
      - Note the path where we placed the file:
      <div class="row">
        <img src="Snaps/Ch4/Application-JAR.PNG" class="center-block img-fluid"
             alt="ServletResponse_Interface"
             width="1500">
      </div>
      - This is what the servlet code looks like.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/c17828336b9b97a71b135d0b7662835c.js"></script>
        </div>
      </div>

      - We added a new mapping in the web.xml. And linked the servlet in the JSP file like this. <br>
      - Note the '/' inside the <code>url-pattern</code>. Without that, we get an error saying invalid url.
      <div class="row">
        <img src="Snaps/Ch4/Application-JAR-JSP.PNG" class="center-block img-fluid"
             alt="ServletResponse_Interface"
             width="1500">
      </div>
    </div>


    <div class="sub-heading">What does setting the <code>setContentType</code> do</div>
    <div>
      <a href="https://stackoverflow.com/questions/14291027/what-is-the-use-of-response-setcontenttypetext-html-in-servlet">Source</a>
      <br>
      - Content types are included in HTTP responses because the same, byte for byte sequence of values in the
      content could be interpreted in more than one way. Remember that http can transport more than just HTML (js,
      css and images are examples), and in some cases, the receiver will not know what type of object it's
      going to receive. This is the same thing as setting the MIME type. Content type is an HTTP Header that must
      be included in the HTTP Response.
      <br>
      - Remember to always call <code>setContentType</code> before you have called the method that gives you your
      output stream (<code>getWriter</code> or <code>getOutputStream</code>). That will guarantee you will not run
      into conflicts between the content type and the output stream.
      <br>
      - Common MIME types are:
      <ul>
        <li>text/html</li>
        <li>application/pdf</li>
        <li>video/quicktime</li>
        <li>application/java</li>
        <li>image/jpeg</li>
        <li>application/jar</li>
        <li>application/octet-stream</li>
        <li>application/x-zip</li>
      </ul>
    </div>

    <div class="sub-heading">What is the difference between <code>ServletOutputStream</code> and
      <code>PrintWriter</code>:
    </div>
    <div>
      - There are two ways in which you can write to a <i>response</i> object in a servlet. <br>
      - You can either use the <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletResponse.html#getWriter--"><code>getWriter()</code></a>
      or you can use the <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletResponse.html#getOutputStream--"><code>getOutputStream()</code></a>
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/292ac100f60064eb83bcd954594a01d4.js"></script>
        </div>
      </div>

      - So: to send binary data in a MIME body response, use the ServletOutputStream returned by
      getOutputStream(). To
      send character data, use the PrintWriter object returned by getWriter(). To mix binary and text data, for
      example, to create a multipart response, use a ServletOutputStream and manage the character sections
      manually.
    </div>


    <div class="sub-heading">What is the difference between <code>setHeader</code> and <code>addHeader</code>
      methods
    </div>
    <div>
      - <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html#setHeader-java.lang.String-java.lang.String-"><code>setHeader</code></a>:
      Sets a response header with the given name and value. If the header had already
      been set, the new value overwrites the previous one. The containsHeader method can be used to test for the
      presence of a header before setting its value. <br>
      - <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html#addHeader-java.lang.String-java.lang.String-"><code>addHeader</code></a>:
      Adds an additional value to the response header. Added value being the the current given name and value.
      This method allows response headers to have multiple values. <br>
      - Along the same lines you have <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html#addIntHeader-java.lang.String-int-"><code>addIntHeader</code></a>
      and <a
      href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletResponse.html#setIntHeader-java.lang.String-int-"><code>setIntHeader</code></a>.
    </div>


    <div class="sub-heading">How can you make someone else handle the response</div>
    <div>
      - You can choose to have something else handle the response for your request. You can either <i>redirect</i>
      the request to a completely different URL. Or you
      can dispatch the request to some other component in your web app (usually a jsp). <br>
      - We will look at both the methods in the following examples.
    </div>


    <div class="sub-heading">Using a Redirect</div>
    <div>
      - This is a high-level explanation of how this works:
      <div class="row">
        <img src="./Snaps/Ch4/Redirect_1.PNG" class="center-block img-fluid"
             alt="Redirect"
             width="600">
      </div>
      <div class="row">
        <img src="./Snaps/Ch4/Redirect_2.PNG" class="center-block img-fluid"
             alt="Redirect"
             width="600">
      </div>
      - So things are going to get a bit murky now. <br>
      - You need to specify a URL to redirect to. And you do it using
      <code>response.sendRedirect("/yourRedirectUrl")</code> <br>
      - The URL can be specified in different ways, by which I mean, you can either give the full path of the URL
      (like "https://www.google.com"), or you can give the Relative URL. <br>
      - Now the relative URL can be specified in two ways. Either the URL can or cannot start with a forward slash
      <code>/</code> character. <br>
      - Imagine the client originally typed in
      <code>https://www.ws.com/myApp/cool/bar.do</code>. The request comes in into the servlet mapped to <code>bar.do</code>,
      and the servlet calls <code>sendRedirect()</code> with a RELATIVE URL that does NOT start with a '/':
      <code>sendRedirect("foo/stuff.html")</code>. The container will then build the full URL relative to the
      original request URL:
      <code>https://www.ws.com/myApp/cool/foo/stuff.html</code>. Hence if you don't start with a '/', then the
      request path is prepended to the front of <code>foo/stuff.html</code> <br>
      - But if the argument to the <code>sendRequest()</code> DOES start with a '/' as in
      <code>sendRedirect("/foo/stuff.html")</code>, the container will build the complete URL relative to the WEB
      CONTAINER ITSELF, instead of the original URL of the request. So the new URL will be:
      <code>https://www.ws.com/foo/stuff.html</code>. <i>foo</i> is treated as a separate webapp from the
      <i>myApp</i> webapp in the previous case. Hence, in this case, the forward slash at the beginning means
      "relative to the root of this web container". <br>

      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/9f67157174f03634676c9d9ad718a8d2.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">What is a <code>302 Found</code> redirect</div>
    <div>
      - <a href="https://stackoverflow.com/a/45691209/8742428">Source on SO here</a>. <br>
      - A response with <code>302</code> is a common way of performing URL redirection. Along with the
      <code>302</code> status code, the response should include a Location header with a different URI. Such
      header will be parsed by the user agent and then perform the redirection:
      <div class="row">
        <img src="./Snaps/Ch4/Redirection.png" class="center-block img-fluid"
             alt="302 Redirection Protocol"
             width="600">
      </div>
      - The RFC defines <code>302 Found</code> as follows: The 302 (Found) status code indicates that the target
      resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the
      client ought to continue to use the effective request URI for future requests.
      The server SHOULD generate a <code>Location</code> header field in the response containing a URI reference
      for the different URI. The user agent MAY use the <code>Location</code> field value for automatic
      redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the
      different URI(s).
      Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent
      request. If this behavior is undesired, the <code>307 (Temporary Redirect)</code> status code can be used
      instead. <br>
      - On our page, the 302 behavior looks something like this:
      <div class="row">
        <img src="./Snaps/Ch4/Redirect-On-My-App.png" class="center-block img-fluid"
             alt="302 Redirection Protocol"
             width="1500">
      </div>
    </div>

    <div class="sub-heading">How do we set a different status code - like 301 for example</div>
    <div>
      - Refer <a href="https://stackoverflow.com/a/9034285/8742428">this answer on SO</a>. <br>
      - Remember that you can set the headers manually as well. This is how we are achieving this.

      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/c517804ddc506ef464d8b87c23bc73e2.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">How to put JSP files in a separate folder</div>
    <div>
      - So far in the examples that we have seen, all the the jsp files were present outside the
      <code>WEB-INF</code> folder. The problem with this is that, because the files are outside the
      <code>WEB-INF</code> folder, we can directly access them by going to the URL directly. What I mean is, we
      could directly type in
      <code>http://localhost:8080/BeerRecommender_war_exploded/beer-form.html</code> in the address bar, and that
      would take us to the form. No need to click on anything or to go through actual links. Now this is fine for
      the form, but becomes a problem when we navigate to the <code>result.jsp</code> page directly by typing in
      the address. It leads to 500 error because the <i>request</i> object is not populated yet. <br>
      - So we want a structure that looks something like the below one:
      <div class="row">
        <img src="./Snaps/Ch4/FolderStructureOfJSPFiles.png" class="center-block img-fluid"
             alt="Basic Structure of JSP Files"
             width="600">
      </div>
      - Remember, any file under the <code>WEB-INF</code> folder is a protected resource. It will have to be
      accessed by calling <code>/WEB-INF/</code> from a <code>ServletContext</code>. <a
      href="https://stackoverflow.com/q/14361330/8742428">Source on
      SO</a>. <br>
      - So how do we do this? <a href="https://stackoverflow.com/a/20771190/8742428">Read this SO answer here</a>.
      The left image is currently the scenario 1 in the answer. We want it to change to scenario 3. <br>
    </div>

    <div class="sub-heading">Why do I have to prepend the path in JSPs with
      <code>${pageContext.request.contextPath}</code></div>
    <div>
      - <a
      href="https://stackoverflow.com/questions/5850336/what-does-this-expression-language-pagecontext-request-contextpath-exactly-do">Read
      on SO here</a>.
      <br>
      -
    </div>

    <div class="sub-heading">What is a Request Dispatch</div>
    <div>
      - A redirect makes the Client do the work. Whereas a Request Dispatch makes something else on the server do
      the work. <br>
      - <a
      href="https://stackoverflow.com/questions/2047122/requestdispatcher-forward-vs-httpservletresponse-sendredirect">Read
      about the differences between the two on SO here</a>.
      <div class="row">
        <img src="./Snaps/Ch4/RequestDispatch.PNG" class="center-block img-fluid"
             alt="RequestDispatch"
             width="600">
      </div>
    </div>


    <div class="sub-heading">What is the Post-Redirect-Get Pattern</div>
    <div>
      - <a href="https://stackoverflow.com/a/2048640/8742428">Excellent answer by BalusC on SO here</a>. <br>
      - //TODO: Write Code Example.
    </div>
  </div>

  <hr>
  <div id="Ch5" class="chapter">Chapter 5: Attributes and Listeners - Being a Servlet</div>
  <hr>
  <div class="textual-content">
    <div class="sub-heading">How to pass init params to specific servlets? What are <code>init-param</code>s in the
      <code>ServletConfig</code>?
    </div>
    <div>
      - Servlets can have initialization parameters. We use the <code>&ltinit-param&gt</code> element to specify
      the name-value pairs. Note that the <code>&ltinit-param&gt&lt/init-param&gt</code> should be inside the
      <code>servlet</code> element that you want to initialize with the particular value.
      <br>
      - When the Container initializes a Servlet, it makes a unique <code>ServletConfig</code> for the Servlet.
      The Container reads the servlet init parameters from the DD and gives them to the <code>ServletConfig</code>,
      and then passes the <code>ServletConfig</code> to the servlet's <code>init</code> method.
      <br>
      - Note that the Servlet init parameters are read only once - when the Container initializes the Servlet.
      Once the parameters are in the <code>ServletConfig</code> they won't be read again until/unless you redeploy
      the servlet.
      <!--            <div class="code-snippet">-->
      <!--                <script src="https://gist.github.com/rgbk21/33e00eee38b895a4439b0f2b1c78c194.js"></script>-->
      <!--            </div>-->
      <!--            <div class="code-snippet">-->
      <!--                <script src="https://gist.github.com/rgbk21/064f4d606995c28bf84e00f044d46a7e.js"></script>-->
      <!--            </div>-->


      <div class="row">
        <img src="./Snaps/Ch5/HighLevelExplanationOfInitParams.PNG" class="center-block img-fluid"
             alt="Servlet state diagram"
             width="700">
      </div>

      <div class="row">
        <img src="./Snaps/Ch5/init-params-code.PNG" class="center-block img-fluid"
             alt="Servlet state diagram"
             width="1843">
      </div>
      - The problem with the above approach is that, if now suppose we have to use the same <i>emailId</i>
      parameter in another servlet, we will have to copy the same value to the another servlet as well. Hence we
      also need to define a way in which we can access the same parameter across all servlets.
    </div>


    <div class="sub-heading">How to make parameters available to entire web app including JSPs? What are <code>context-param</code>s
      in <code>ServletContext</code>?
    </div>
    <div>
      - <i>Context</i> init params work just like <i>servlet</i> init parameters, except that context parameters
      are available to the entire web app, and not just a single servlet. That means any servlet or JSP can
      automatically access the context init parameters. <br>
      <div class="row">
        <img src="./Snaps/Ch5/Context-Init-Params.PNG" class="center-block img-fluid"
             alt="Servlet state diagram"
             width="1843">
      </div>
    </div>


    <div class="sub-heading">Difference between the Servlet-Init parameters and the Context-Init parameters</div>
    <div>
      - Both of them make use of the same method to access the parameters, but the methods are called on different
      objects. <br>
      - For accessing servlet-init/ServletConfig params :
      <code>getServletConfig().getInitParameter("emailId");</code> <br>
      - For accessing context-init/ServletContext params: <code>getServletContext().getInitParameter("adminEmailId"))</code>
      <br>
      - Both of these methods are from the <code>GenericServlet</code> class that is inherited by the <code>HttpServlet</code>
      which in turn is inherited by your Servlet class. <br>
      - <code>ServletConfig</code> is one per <i>servlet</i>, whereas <code>ServletContext</code> is one per <i>webapp</i>.
      i.e. every servlet and JSP deployed as part of a single webapp has access to that same
      <code>ServletContext</code>. But <i>every</i> servlet has <i>it's own</i> <code>ServletConfig</code>. <br>
      - A servlet-init parameter and a context-init parameter can have the same name. Remember, they are being
      read from completely different objects. Hence there is no issue of shadowing/name space conflict.

      <div class="row">
        <img src="./Snaps/Ch5/Servlet-Context.png" class="center-block img-fluid"
             alt="Diff-servletInit-contextInit"
             width="1400">
      </div>

    </div>


    <div class="sub-heading">What are the methods in the <code>ServletConfig</code> class</div>
    <div>
      - <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletConfig.html"><code>ServletConfig</code></a>
      is a servlet configuration object used by a servlet container to pass information to a servlet during
      initialization.
      <br>
      - It has the following methods:
      <br>
      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Method</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>String getInitParameter(String name)</td>
          <td>Gets the value of the initialization parameter with the given name.</td>
        </tr>
        <tr>
          <td>Enumeration&ltString&gt getInitParameterNames()</td>
          <td>Returns the names of the servlet's initialization parameters as an <code>Enumeration</code> of
            String objects, or an empty <code>Enumeration</code> if the servlet has no initialization
            parameters.
          </td>
        </tr>
        <tr>
          <td>ServletContext getServletContext()</td>
          <td>Returns a reference to the <code>ServletContext</code> in which the caller is executing. Same as
            running <code>this.getServletContext</code></td>
        </tr>
        <tr>
          <td>String getServletName()</td>
          <td>Returns the name of this servlet instance.</td>
        </tr>
        </tbody>
      </table>
    </div>


    <div class="sub-heading">How can I use a Listener to read values from the web.xml and use it to add
      objects into the ServletContext for the entire webapp to read?
    </div>
    <div>
      - <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html">ServletContextListener
      docs</a>.
      <br>
      - The problem with using the context-init parameters is that you are only allowed values that are of type
      String. What if you wanted to do something more involved - like adding an object to your webapp that any
      servlet/JSP could access? Here we make use of a Listener that reads the value of the context init param from
      the DD, and using that string value, creates a new object and adds it to the <code>ServletContext</code>
      using <code>setAttribute</code> that is then passed to your web app. Any servlet/jsp can then get that
      <i>attribute</i> from the <code>ServletContext</code> object using <code>getAttribute</code>. <br>
      - This is what you came up with:
      <div class="row">
        <img src="./Snaps/Ch5/Listener-Code-Snippet.png" class="center-block img-fluid"
             alt="Listener Code Snippet"
             width="1426">
      </div>
      - Here is the complete picture:
      <div class="row">
        <img src="./Snaps/Ch5/Servlet_Initialization_FullStory.png" class="center-block img-fluid"
             alt=""
             width="1600">
      </div>
      - Note that THE code is mainly using the <code>ServletContextListener</code>. Both
      <code>contextInitialized</code> and <code>contextDestroyed</code> methods are overridden. I think it is
      mainly being used for logging purposes, to kind of try and understand what kind of branch the code is taking
      (I guess!). Nothing is being read from the <code>ServletContextEvent</code>.
    </div>

    <div class="sub-heading">The <code>HttpSessionListener</code> interface</div>
    <div>
      - This is the only other EventListener being used in THE code. <br>
      - <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpSessionListener.html">HttpSessionListener docs</a>.
      <br>
    </div>

    <div class="sub-heading">Different types of Listeners</div>
    <div>
      - There can be different types of listeners triggering on different types of events:
      <div class="row">
        <img src="./Snaps/Ch5/Listeners.PNG" class="float-left img-fluid"
             alt=""
             width="600">
      </div>
    </div>

    <div class="sub-heading">What is an attribute</div>
    <div>
      - An attribute is an object bound into one of three other Servlet API objects: <code>ServletContext</code>,
      <code>HttpServletRequest</code> (<code>ServletRequest</code>), or <code>HttpSession</code>
      <br>
      - An attribute is simply a name/value pair (where the name is a String and the value is an object) in a map
      instance variable.
      <br>
      - In reality, we do not care how it is implemented - all we really care is about the <i>scope</i> in which
      the attribute exists. In other words, <i>who</i> can see it and <i>how long</i> does it live.
    </div>

    <div class="sub-heading">What is the difference between an attribute and a parameter</div>
    <div>
      - An attribute is not a parameter: <a
      href="https://stackoverflow.com/questions/5243754/difference-between-getattribute-and-getparameter">StackOverflow
      Source</a>
      <br>
      - We use <code>request.getParameter()</code> to extract request parameters (i.e. data sent by posting a html
      form). The <code>request.getParameter()</code> always returns String value and the data comes from client.
      The exception to this is <code>ServletContext</code> and the <code>ServletConfig</code> init-parameters
      which are string parameters that are configured in web.xml and exist on the server.
      <div class="row">
        <img src="./Snaps/Ch5/Diff_betn_Attribute_And_Parameter.PNG" class="float-left img-fluid"
             alt="Diff_betn_Attribute_And_Parameter"
             width="700">
      </div>

      <div class="row">
        <img src="./Snaps/Ch5/All_Attributes.png" class="float-left img-fluid"
             alt="All_Attributes"
             width="1800">
      </div>
    </div>

    <div class="sub-heading">What is the difference between the Context, Session, and Request Scopes</div>
    <div>
      - <b>Context Attributes: </b> A <code>ServletContext</code> attribute is an object bound into a context
      through the <code>ServletContext.setAttribute()</code>
      method and which is available to ALL Servlets (thus JSP) in that context, or to other contexts via the
      <code>getContext()</code> method. By definition a context attribute exists locally in the VM where they were
      defined. So, they're unavailable on distributed applications.
      <br>
      - <b>Session Attributes: </b>Session attributes are bound to a Session, as a means to provide state to a set
      of related HTTP requests.
      Session attributes are available ONLY to those Servlets which join the session. They're also unavailable to
      different JVMs in distributed scenarios. Objects can be notified when they're bound/unbound to the Session
      implementing the <code>HttpSessionBindingListener</code> interface.
      <br>
      - <b>Request Attributes: </b>Request attributes are bound to a specific request object, and they last as far
      as the request is resolved
      or while it keeps being dispatched from Servlet to Servlet. They're used more as communication channel
      between Servlets via the
      <code>RequestDispatcher</code> Interface (since you can't add Parameters...) and by the container. Request
      attributes are very useful in web apps when you must provide setup information between information providers
      and the information presentation layer (a JSP) that is bound to a specific request and need not be available
      any longer, which usually happens with sessions without a rigorous control strategy.
      <br>
      - <a href="https://stackoverflow.com/a/15433931/8742428">StackOverflow Source</a>
      <br>
      - These 3 attribute scopes are handled by the <code>ServletContext</code>,
      <code>HttpSession</code>, and <code>ServletRequest</code> interfaces. The API methods for these attributes
      are the same in every interface:
      <ul>
        <li><code>Object getAttribute(String name)</code></li>
        <li><code>void setAttribute(String name, Object value)</code></li>
        <li><code>void removeAttribute(String name)</code></li>
        <li><code>Enumeration&ltString&gt getAttributeNames(String name)</code></li>
      </ul>
      <div class="row">
        <img src="./Snaps/Ch5/Methods_Scopes.PNG" class="float-left img-fluid"
             alt="All_Attributes"
             width="800">
      </div>
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/6ea4c632aa3c983cafffe29be386f62f.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">Context Scope isn't Thread-Safe. Neither is Session Scope.</div>
    <div>
      - Everyone in the app has access to the Context Attributes. That means multiple servlets. And multiple
      servlets might have multiple threads, since requests are concurrently handled, each in a separate thread.
      This happens regardless of whether the requests are coming in from the same or different Servlets.
      <br>
      - In order to make them thread-safe, you need an <a
      href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html">intrinsic lock</a> on
      the ServletContext object. Every object has an intrinsic lock associated with it. By convention, a thread
      that needs exclusive and consistent access to an object's fields has to acquire the object's intrinsic lock
      before accessing them, and then release the intrinsic lock when it's done with them. A thread is said to own
      the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns
      an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts
      to acquire the lock.
      <br>
      - This way everyone accessing the context has to first get the lock on the Context object. This ensures that
      only one thread is setting and getting the context attribute. But remember that this works only if ALL of
      the other code that manipulates the same context attribute ALSO synchronizes on the ServletContext. If even
      part of the code doesn't ask for the lock, then that code is free to hit the context attributes.
      <br>
      //TODO: Why not get a lock just on the variable being changed? Instead of getting a lock on the entire
      ServletContex?
      <br>
      //i.e. do: <code>synchronized (this.getServletContext().getAttribute("UserCount"))</code> ?
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/fa755cf00a8810b355a98a26697a087b.js"></script>
        </div>
      </div>
      - Remember that Synchronization causes a lot of overhead and hurts concurrency. Make your synchronized block
      as small as possible. Get the lock, get in, get what you need, adn get the heckin heck out so that the lock
      can release and other threads can run that code.
      <br>
      - Writing Servlet code:
      <br>
      <a href="https://docstore.mik.ua/orelly/xml/jxslt/ch06_05.htm">Thread Safety Tips</a>
      <br>
      <a href="https://stackoverflow.com/questions/2551999/why-is-javax-servlet-singlethreadmodel-deprecated">Why
        is singlethreadmodel deprecated</a>
    </div>

    <div class="sub-heading">So what even is Thread-Safe</div>
    <div>
      - Only Request Scoped attributes and Local variables are Thread-Safe
      <br>
      - Everything else is subject ot multi-threaded manipulation unless you do something about it.
      <br>
      - Everything else includes:
      <ul>
        <li>Context Scoped Attributes</li>
        <li>Session Scoped Attributes</li>
        <li>Instance Variables in the Servlet</li>
        <li>Static Variables in the Servlet</li>
      </ul>
      - Note that instance variables are not thread-safe. If you have multiple clients making request to the same
      servlet, that means multiple threads are running that servlet code. And all of those threads have access to
      the servlet's instance variables. So instance variables are not thread-safe.
      <br>
      - Can you make instance variables thread-safe: No. You should avoid using instance variables in your code.
      <br>
      - Then what should you use if you need multiple instances of the Servlet to share something: It's incorrect
      to say "multiple instances of the Servlet" because there is always just ONE instance of the servlet. One
      instance. Many threads...
      <br>
      - If you want all the threads to access a value, decide which attribute state makes the most sense and store
      the value in that attribute. Chances are you can solve the problem in one of two ways:
      <ul>
        <li>Declare the variable as a local variable inside the service method, rather than as an instance
          variable
        </li>
        <li>Use an attribute in the most appropriate scope</li>
      </ul>
    </div>

    <div class="sub-heading">What is the use of Request Attributes and Request Dispatching</div>
    <div>
      - Request attributes make sense when you want some other component of the app to take over all or a part of
      the request. The controller communicates with the model and gets back the data that the view needs in order
      to build the response. There is no reason to put the data in a Session or a Context attribute, since it
      applies <i>only</i> to this request, so we put it in the request scope.
      <br>
      - So how do we make another part of the component to take over the request - <code>RequestDispatcher</code>
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/a942d8666eccdb9916b499157798c7ec.js"></script>
        </div>
      </div>
      - <code>RequestDispatcher</code>'s have only two methods:
      <ul>
        <li><code>forward(ServletRequest request, ServletResponse response)</code></li>
        <li><code>include(ServletRequest request, ServletResponse response)</code></li>
      </ul>
      - You can get a <code>RequestDispatcher</code> in two ways: from the request or from the context. Regardless
      of where you get it, you ahve to tell it the web component ot which you are forwarding the request.
      <div class="row">
        <img src="./Snaps/Ch5/RequestDispatcher.PNG" class="float-left img-fluid"
             alt="RequestDispatcher"
             width="800">
      </div>
    </div>
  </div>

  <hr>
  <div id="Ch6" class="chapter">Chapter 6: Session Management - Conversational State</div>
  <hr>
  <div class="textual-content">
    <div>
      Web Servers have no short term memory. As soon as they send you a response, they forget who you are. The
      next time you make a request, they do not recognize you. In other words, they do not remember what you have
      requested in the past, and they don't remember what they've sent you in response. Nothing. Sometimes, that's
      fine. But sometimes you need to keep conversational state with the client across <i>multiple requests</i>. A
      shopping cart would not work if the client had to make all his choices and check out in a single request.
    </div>
    <div class="sub-heading">How do we track the Client's requests over multiple sessions</div>
    <div>
      - The objective is to store all the choices that have been made by the Client over multiple requests. There
      are 3 ways in which this can be accomplished:
      <ul>
        <li><b>Use a stateful session enterprise java bean</b>: Make your servlet become a Client to a stateful
          session bean, and each time a request comes in we locate that Client's stateful bean. Remember that
          for doing this you hosting provider should have full J2EE server with an EJB Container. Tomcat is
          just a web container, not a full J2EE container.
        </li>
        <li>
          <b>Use a Database</b>: Have your hosting provider communicate with a database, like MySQL. Then all
          the client's data can be written to or read from the database. The downside is that it is extremely
          expensive to do this.
        </li>
        <li>
          <b>Use an <code>HttpSession</code></b>: We can use an <code>HttpSession</code> to hold the
          conversational state over multiple requests - i.e for the <i>entire session</i> with the user.
        </li>
      </ul>
    </div>

    <div class="sub-heading">How does the container know who the Client is</div>
    <div>
      - The HTTP Protocol is a Stateless Protocol. This means that the connection between the Client and the
      Container exists for a <i>single</i> request/response. The Container does not recognize that the Client
      making the second request is the same Client from a previous request. As far as the Container is concerned,
      each request is from a new Client.
      <br>
      - The Container solves this problem by assigning a unique <code>SessionID</code> to each user.
      <br>
      - On the Client's first request, the Container generates a unique session ID and gives it back to the Client
      with the response. The Client then sends back the session ID with each subsequent request. The Container
      sees the ID, finds the matching session, and associates the session with the request.
      <br>
      - Attributes bound into a session are available to any other servlets that belong to the same <code>ServletContext</code>
      and handles a request identified as being a part of the same session.
      <div class="row">
        <img src="./Snaps/Ch6/Sessions_Flowchart.png" class="float-left img-fluid"
             alt="Sessions_Flowchart"
             width="1600">
      </div>
    </div>

    <div class="sub-heading">How do the Client and the Container exchange the SessionID info</div>
    <div>
      - The Container uses <code>Cookie</code>s to do this.
      <br>
      - All you have to do is tell the Container that you want to create or use a Session. The Container takes
      care of the rest. The Container generates the SessionID, creates a new <code>Cookie</code> object, stuffs
      the <code>SessionID</code> into the <code>Cookie</code> object, sets the Cookie as a part of the response.
      On subsequent
      requests, the Container gets the <code>SessionID</code> from the Cookie in the request, matches the <code>SessionID</code>
      with an existing session, and associates that session with the current request.
      <br>
      - The <code>HttpSession session = request.getSession()</code> does the following:
      <br>
      <code>if(the request contains the SessionID object)</code>
      <br>
      <code> find the Session matching that ID</code>
      <br>
      <code>else if (there is no SessionID Cookie OR there is no session matching the current SessionID)</code>
      <br>
      <code> create a new session</code>

    </div>

    <div class="sub-heading">How to check if the Session already exists</div>
    <div>
      - The no-args <code>HttpSession session = request.getSession()</code> method returns a session regardless of
      whether there is a
      pre-existing session or not. You can check if it is a new session by using <code>session.isNew()</code>
      method.
      <br>
      - <code>HttpSession session = request.getSession(false)</code> will return <code>null</code> if there is no
      pre-existing session for the Client. You can use it if you have a scenario in which the servlet wants to use
      only a previously created session.
      <br>
      - There are couple of points that you were confused about that need to be clarified:
      <br>
      - You can check the cookies that are stored in the browser on Chrome - Inspect - Application - Cookies
      <br>
      Here you will see the Cookies with the name <code>JSESSION ID</code>. This is the same id as the <code>sessionId</code>.
      While testing, if you see your app behaving abnormally (session seems to be behaving weirdly), first clear
      the cookies in your browser (Ctrl + Shift + Del) and then retry. If that does not work, go into your app and
      by inspecting elements, manually delete the cookies.
      <br>
      - Note that a sessionId is assigned to you the moment you first log in into the website. In the dummy
      example
      that we had, the first page that the user was reaching was a index page. The <code>doGet</code> method was
      activated only when the user clicked a button on the index page to get the form. The point is that, line 4
      of the below code will always contain a valid session.
      <br>
      - Check this <a
      href="https://stackoverflow.com/questions/19476154/confusion-with-the-httpsession-isnew-method-behavior">SO
      Post explaining things</a>.
      <br>
      - So in order to kill that session, we first call <code>session.invalidate</code>. Remember that this will
      not set the <code>session</code> to <code>null</code> as <a
      href="https://stackoverflow.com/questions/24677949/why-session-is-not-null-after-session-invalidate-in-java">explained
      here in SO</a>. So we get the session again, as on Line 8. This time the Container does not find any
      existing sessions and the <code>session</code> variable is in fact null. When we run the code, now, the
      <code>if (session == null) </code> block is executed.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/3b7165571d0253ffe96051ce0879d268.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">What if the Client has disabled Cookies</div>
    <div>
      - If the Client does not use Cookies, you can use URL rewriting as a backup. URL rewriting
      allows the sessionID to be added to the end of the URL (instead of being sent as a Cookie).
      <br>
      - URL rewriting kicks in only if cookies fail and you have explicitly encoded your URLs.
      <br>
      - Read up on the <code>encodeURL</code> method
      <br>
      - When a Container sees a call to <code>getSession</code>, and the Container does not have the SessionID
      associated with the Client's request, the Container knows that it must attempt to set up a new session with
      the Client. At this point the Container does not know whether the Cookies will work or not. Hence for the
      first response back to the Client, the Container tries both, Cookies <i>and</i> URL Rewriting.
    </div>

    <div class="sub-heading">What are the key <code>HttpSession</code> methods</div>
    <div>
      <div class="row">
        <img src="./Snaps/Ch6/HttpSessionMethods.PNG" class="float-left img-fluid"
             alt="HttpSessionMethods"
             width="800">
      </div>
    </div>


    <div class="sub-heading">How does a Container know when it is safe to destroy Sessions</div>
    <div>
      - There are 3 ways that a Session can die:
      <ul>
        <li>It times out</li>
        <li>You call <code>invalidate()</code> on the Session object</li>
        <li>The application goes down or crashes</li>
      </ul>
      <br>
      a) <b>Setting Session Timeout</b>: There are two ways to set the session timeout
      <ul>
        <li><b>Setting Session Time out for a specific session</b>: Use this if you want to change the
          session-timout value for a particular session instance without affecting the timeout length for any
          other sessions in the app.
          <br>
          <code>session.setMaxInactiveInterval(20*60)</code>
          <br>
          Only the session on which you call the method will be affected. Note that the argument to the method
          is in seconds.
        </li>
        <li><b>Configuring Session Timeout in the DD:</b> This has the same effect as calling <code>setMaxInactiveInterval()</code>
          on every session that is created.
          <div class="code-block">
            <div class="expand-code-snip-btn border border-primary rounded">
              <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
            </div>
            <div class="code-snippet">
              <script src="https://gist.github.com/rgbk21/9da74048e8db7b9f15708bcb3e8cce48.js"></script>
            </div>
          </div>
        </li>
      </ul>
      b) <b>Calling <code>invalidate()</code></b>: Invalidates this session then unbinds any objects bound to it.
      Like we discussed earlier, calling this method will not set the session object to <code>null</code>.
      <div class="row">
        <img src="./Snaps/Ch6/invalidate_session.PNG" class="float-left img-fluid"
             alt="invalidate_session"
             width="1600">
      </div>
      //TODO: Why isn't the session invalidated in the second case? I can still get and print the values of the
      attributes. Why?
    </div>

    <div class="sub-heading">Can I use the Cookie for things other than maintaining Sessions</div>
    <div>
      - Yes. Remember that the cookie is nothing more than a little piece of data (name/value) pair that is
      exchanged between the Client and the server. The Server sends the Cookie to the Client and the Client
      returns the cookie to the Server when teh Client has to make a new request to the Server.
      <br>
      - By default, a Cookie lives only as long as the session. Once the client quits his browser, the cookie
      disappears. That's how the <code>JSESSION</code> cookie works. But you can tell a cookie to stay alive even
      AFTER the browser shuts down. These types of cookies are known as <a
      href="https://en.wikipedia.org/wiki/HTTP_cookie#Persistent_cookie">Persistent Cookies</a>.
    </div>


    <div class="sub-heading"> How to use Cookies with the Servlet API</div>
    <div>
      - This is probably a convoluted example, but stick through it. First the JSP page. Note that there is no
      getCookie(String) method. You can only get Cookies in a Cookie array and then you have to loop over the
      array to
      find the one you want.
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/56d716e43b85399023fccfe04f8b4ef7.js"></script>
        </div>
      </div>
      And then the Servlet class:
      <div class="code-block">
        <div class="expand-code-snip-btn border border-primary rounded">
          <span class="btn btn-link">Expand Gist <img src="imgs/chevron-expand.svg" alt="Expand Code Snippet"></span>
        </div>
        <div class="code-snippet">
          <script src="https://gist.github.com/rgbk21/b9d064f68b6281badc5c51e2d464167d.js"></script>
        </div>
      </div>
    </div>

    <div class="sub-heading">What kinds of listeners are we dealing with</div>
    <div class="row">
      <img src="./Snaps/Ch6/Listeners.PNG" class="float-left img-fluid"
           alt="invalidate_session"
           width="800">
    </div>

    <div class="sub-heading">What is Session Migration</div>
    <div>
      - In a clustered environment, the Container might do <i>load-balancing</i> by taking client requests and
      sending
      them out JVMs. The JVMs themselves may or may not be on the same physical boxes, that is immaterial. The
      point
      is that the web app is in multiple places. This means that each time the same Client makes a request, the
      request could end up going to a <i>different</i> instance of the same servlet.
      <br>
      - The question is: how does the Container manage the <code>ServletConfig</code>, <code>ServletContext</code>,
      and <code>HttpSession</code> objects in this case.
      <br>
      - Only <code>HttpSession</code> objects (and their attributes) move from one VM to another.
      <br>
      - There is one <code>ServletContext</code> <i>per</i> VM. There is one <code>ServletConfig</code> <i>per
      Servlet, per VM</i>. But there is only one <code>HttpSession</code> object for a given
      <code>SessionId</code>
      per web app, regardless of how many VM's the app is distributed across.
      <br>
      - The key point here is that while the other parts of the app are <i>replicated</i> on each node/VM, the
      session
      objects (along with the session attributes) are <i>moved</i>.
      <div class="row">
        <img src="./Snaps/Ch6/DistributedSessions.PNG" class="float-left img-fluid"
             alt="DistributedSessions"
             width="800">
      </div>
      <div class="row">
        <img src="./Snaps/Ch6/SessionMigration.png" class="float-left img-fluid"
             alt="SessionMigration"
             width="1600">
      </div>

      //TODO: This is followed by something related to SessionListeners.
      <br>
      <code>HttpSessionActivationListener</code>
      <br>
      <code>HttpSessionAttributeListener</code>
      <br>
      <code>HttpSessionAttributeListener</code>

    </div>
  </div>

  <hr>
  <div id="Ch7" class="chapter">Chapter 7: Using JSP - Being a JSP</div>
  <hr>
  <div class="textual-content">
    The most important point for this chapter is simply: what role does the JSP place in the final servlet class?
    In other words, <i>where</i> do the elements in the JSP end up in the source code of the generated servlet?

    <div class="sub-heading">In the end a JSP is just a Servlet</div>
    <div>
      - In the end, your JSP becomes a full-fledged servlet running in your web-app. The only difference is that
      the servlet class is written for you by the Container. The Container takes what you have written in your
      JSP, translates it into a servlet class source (.java) file, then compiles that into a java servlet class.
      After that it all behaves just like a normal servlet class, i.e the Container loads the Servlet class,
      instantiates and initializes it, makes a separate thread for each request and calls the servlet's <code>service()</code>
      method.
      <br>
      - When you deploy a web app witha JSP, the whole translation and compilation step happens only once in the
      JSP's life. Once it has been translated and compiled, it is just like any other servlet. And just like any
      other servlet, once that servlet has been loaded and initialized, the only thing that happens at request
      time is creation or allocation of a thread for the service method. So the above picture is only for the very
      first request that the container has to handle.
      <div class="row">
        <img src="./Snaps/Ch7/CompilationOfServlet.PNG" class="float-left img-fluid"
             alt="CompilationOfServlet"
             width="1000">
      </div>
    </div>

    <div class="sub-heading">How to import packages into JSP</div>
    <div>
      - A <i>directive</i> is a way for you to give special instructions to the Container at page translation
      time.
      <br>
      - Directives come in three flavors:
      <ul>
        <li>page</li>
        <li>include</li>
        <li>taglib</li>
      </ul>
      - For importing packages into the JSP, we will use the <i>page</i> directive.
      <br>
      - Importing a single package can be done as follows: <code>&lt%@ page import = "java.util.List" %&gt</code>.
      Notice that there is no semicolon at the end of the import statement.
      <br>
      - Importing a multiple packages can be done as follows:
      <code>&lt%@ page import = "java.util.List,java.util.Map"%&gt</code>. Note that packages are separated by
      comma and the quotes go around the entire list of packages.
    </div>

    <div class="sub-heading">3 JSP element types</div>
    <div>
      - We can now introduce 3 different JSP element types:
      <ul>
        <li>Scriptlet <code>&lt% %&gt</code> : Between these tags goes the java code that you want to write in
          the JSP page. <br>So we can write <code>&lt% out.println(Counter.getCount()); %&gt</code>.
        </li>
        <li>Directive <code>&lt%@ %&gt</code> : used for writing import statements, among other things, in the
          JSP. No semi-colon at the end.
        </li>
        <li>Expression <code>&lt%= &gt</code>: it automatically prints out whatever you put between the tags.
          This is meant as a replacement for <code>out.println</code> in JSP. So, instead of writing, say,
          <code>&lt% out.println(Counter.getCount()); %&gt</code>, we would just write
          <code>&lt%= Counter.getCount() %&gt</code>. Note that the expression does not need a semicolon at
          the end either. A n expression <i>cannot</i> use a method that does not have a return type, i.e has
          <code>void</code> as return type because then there won't be anything to print.
        </li>
      </ul>
      - In case you are wondering, the object <code>out</code> in the above example is passed implicitly to your
      JSP page, just in case you want to pass it to some other object that does not have direct access to the
      output stream for the response.
    </div>

    <div class="sub-heading">What really happens to your JSP Code</div>
    <div>
      - Let's see where the different JSP elements land in the servlet's class file:
      <div class="row">
        <img src="./Snaps/Ch7/JSP2Scriptlet.PNG" class="float-left img-fluid"
             alt="CompilationOfServlet"
             width="1000">
      </div>
      - All scriptlet and expression code lands in a service method. That means that variables declared in a
      scriptlet are ALWAYS local variables.
      <br>
      - Also note that the code from the JSP is placed inside the <code>_jspService</code> method that takes as
      argument the <code>HttpServletRequest request</code> object. Hence you wan write your JSP assuming that it
      is going to be a part of a servlet. This is also an example of "implicit" object. Something that we see in
      the next paragraph.
    </div>

    <div class="sub-heading">How do we declare instance variables in a JSP</div>
    <div>
      - There is another JSP element known as a <i>declaration</i>: for example
      <code>&lt%! int count = 0;%&gt</code>.
      <br>
      - Note that this requires a semicolon at the end. JSP <i>declarations</i> are for declaring members of the
      generated servlet class. This means, both, <i>variables</i> and <i>methods</i>. In other words, anything
      between the <code>&lt%! %&gt</code> tag is added to the class <i>outside</i> the service method. That means
      that you can declare, both, static variables (what?) and methods.
      <div class="row">
        <img src="./Snaps/Ch7/JSP2Servlet_Decalrations.PNG" class="float-left img-fluid"
             alt="JSP2Servlet_Decalrations"
             width="800">
      </div>
    </div>

    <div class="sub-heading">What implicit objects are passed to the JSP</div>
    <div>
      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>API</th>
          <th>Implicit Object</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>JspWriter</td>
          <td>out</td>
        </tr>
        <tr>
          <td>HttpServletRequest</td>
          <td>request</td>
        </tr>
        <tr>
          <td>HttpServletResponse</td>
          <td>response</td>
        </tr>
        <tr>
          <td>HttpSession</td>
          <td>session</td>
        </tr>
        <tr>
          <td>ServletContext</td>
          <td>application</td>
        </tr>
        <tr>
          <td>ServletConfig</td>
          <td>config</td>
        </tr>
        <tr>
          <td>Throwable</td>
          <td>exception</td>
        </tr>
        <tr>
          <td>PageContext</td>
          <td>pageContext</td>
        </tr>
        <tr>
          <td>Object</td>
          <td>page</td>
        </tr>
        </tbody>
      </table>
      - We were already familiar with the 3 scopes: request, session, and application. This introduces another
      scope known as the pageContext.
      <br>
      - A <code>pageContext</code> encapsulates the other implicit objects. This way if you give some other helper
      object a reference to the PageContext, the helper can use that reference to get all the OTHER implicit
      object
      and attributes from all the scopes.
    </div>

    <div class="sub-heading">Everything in one place</div>
    <div>
      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>JSP Element</th>
          <th>Usage</th>
          <th>What is it used for</th>
          <th>Usage Example</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Scriptlet</td>
          <td><code>&lt% ;%&gt</code></td>
          <td>Used to write Java Code</td>
          <td><code>&lt% out.println(Counter.getCount()); %&gt</code></td>
        </tr>
        <tr>
          <td>Directive</td>
          <td><code>&lt%@ %&gt</code></td>
          <td>Used for writing import statements</td>
          <td><code>&lt%@ page import = "java.util.List" %&gt</code></td>
        </tr>
        <tr>
          <td>Expression</td>
          <td><code>&lt%= %&gt</code></td>
          <td>Printing out stuff</td>
          <td><code>&lt%= Counter.getCount() %&gt</code></td>
        </tr>
        <tr>
          <td>Declaration</td>
          <td><code>&lt%! ;%&gt</code></td>
          <td>Declaring methods and instance variables in the JSP</td>
          <td><code>&lt%! int count = 0;%&gt</code></td>
        </tr>
        <tr>
          <td>ExpressionLanguages</td>
          <td><code> ${ }</code></td>
          <td>Invokes Java Code</td>
          <td><code>${applicationScope.mail}</code></td>
        </tr>
        <tr>
          <td>Actions</td>
          <td><code>&ltjsp: /&gt</code>, <code>&ltc: /&gt</code></td>
          <td>They are 2 types: <code>standarad</code> and <code>other</code></td>
          <td><code></code></td>
        </tr>
        </tbody>
      </table>

      <table class="table table-bordered table-sm">
        <thead>
        <tr>
          <th>Scope</th>
          <th>In a Servlet</th>
          <th>In a JSP (using implicit objects)</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Application/Context</td>
          <td><code>getServletContext.setAttribute("foo", barObject)</code></td>
          <td><code>application.setAttribute("foo", barObject)</code></td>
        </tr>
        <tr>
          <td>Request</td>
          <td><code>request.setAttribute("foo", barObject)</code></td>
          <td><code>request.setAttribute("foo", barObject)</code></td>
        </tr>
        <tr>
          <td>Session</td>
          <td><code>request.getSession().setAttribute("foo", barObject)</code></td>
          <td><code>session.setAttribute("foo", barObject)</code></td>
        </tr>
        <tr>
          <td>Page</td>
          <td><code>Does not apply</code></td>
          <td><code>pageContext.setAttribute("foo", barObject)</code></td>
        </tr>
        </tbody>
      </table>


      - Comments can be added either using:
      <ul>
        <li><code>//Your comment </code>: in a scriptlet or a declaration. However, outside of this the string
          "//" would just be parsed like normal HTML comment and you would see your comment printed on the
          page
        </li>
        <li><code>&lt!-- HTML Comment --&gt</code>: Use this if you want the comments to stay as a part of the
          HTML response to the Client
        </li>
        <li><code>&lt%-- JSP Comment --%&gt</code>: Comments will be hidden. They are stripped off when the JSP
          is converted into Java.
        </li>
      </ul>
    </div>

    <div class="sub-heading">Now that you know how to write java code in JSP, never do it</div>
    <div>
      - Java code in JSP is considered hard to change and maintain.
      <br>
      - Instead we make use of Expression Language or <b>EL</b>. The purpose of EL is to offer a simeple way to
      <i>invoke</i> Java code - but the code itself belongs <i>somewhere else</i>. That means in a regular old
      Java class that's either a JavaBean, a class with static methods, or something called a Taghandler.
      <br>
      - In other words you do not write method code into your JSP. You write the Java methods somewhere else and
      call it using EL.
      <br>
      - You can use <code>&ltscripting-invalid&gt true &lt/scripting-invalid&gt</code> to disable scripting
      elements for ALL JSPs. There is a specific format for this. Refer text.
    </div>

    //TODO: Complete the exercises and the Coffee Cram questions from this Chapter.
  </div>

  <hr>
  <div id="Ch8" class="chapter">Chapter 8: Scriptless JSP - Script-free pages</div>
  <hr>
  <div class="textual-content">

  </div>


  <hr>
  <div id="BudiKurniawan" class="chapter">Servlet and JSP : A Tutorial Kurniawan, Budi</div>
  <hr>
  <div class="textual-content">
    Interesting Links:<a href="#BudiKurniawan_InterestingLinks">Interesting Links</a>
    Chapter 0:<a href="#BudiKurniawan_Chapter0">Introduction</a>
    Chapter 0:<a href="#BudiKurniawan_Chapter1">Servlets</a>
  </div>

  <hr>
  <div id="BudiKurniawan_InterestingLinks" class="chapter">Interesting Links</div>
  <hr>

  <div class="textual-content">
    <div class="sub-heading">Interesting Links</div>
    <div>
      - <a href="https://web.dev/howbrowserswork/">How Browsers Work</a> <br>
      - <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling">Proxy, reverse proxy, and HTTP Tunneling</a> <br>
    </div>
  </div>

  <hr>
  <div id="BudiKurniawan_Chapter0" class="chapter">Chapter 0: Introduction</div>
  <hr>

  <div class="textual-content">
    <div class="sub-heading">Introduction</div>
    <div>
      - Java Servlet technology, or Servlet for short, is the underlying technology for developing web applications in Java. Sun Microsystems released it in 1996 to compete with
      the Common Gateway Interface (CGI), the then standard for generating dynamic content on the web. The main problem with the CGI was the fact that it spawned a new process for
      every HTTP request. This made it difficult to write scalable CGI programs because creating a process took a lot of CPU cycles. A servlet, on the other hand, is much faster
      than a CGI program because a servlet stays in memory after serving its first request, waiting for subsequent requests. <br>
      - Servlets are Java classes that run on a servlet container. A servlet container or servlet engine is like a web server but has the ability to generate dynamic
      contents, not only serve static resources.
    </div>

    <div class="sub-heading">Servlet/JSP Application Architecture</div>
    <div>
      - A servlet is a Java program. A servlet application consists of one or more servlets. A JSP page is translated and compiled into a servlet. <br>
      - A servlet application runs inside a servlet container and cannot run on its own. A servlet container passes requests from the user to the servlet application and responses
      from the servlet application back to the user. Most servlet applications include at least several JSP pages. As such, it's more appropriate to use the term "servlet/JSP
      application" to refer to a Java web application than to leave JSP out. <br>
      <div class="image-block">
        <div class="expand-screenshot-image-btn border border-primary rounded">
          <span class="btn btn-link">Show Image <img src="imgs/chevron-expand.svg" alt="Show Image Button"></span>
        </div>
        <div class="screenshot-image">
          <img src="imgs/BudiKurniawan/Chapter0/Servlet_JSP_Application_Architecture.png"
               class="center-block img-fluid"
               width="400"
               alt="Servlet_JSP_Application_Architecture">
        </div>
      </div>
      - The web server and the web client communicate in a language they both are fluent in: the Hypertext Transfer Protocol (HTTP). Because of this, a web server is also called an
      HTTP server. <br>
      - A servlet/JSP container is a special web server that can process servlets as well as serve static contents. In the past, people were more comfortable running a servlet/JSP
      container as a module of an HTTP server such as the Apache HTTP Server because an HTTP server was considered more robust than a servlet/JSP container. In this scenario the
      servlet/JSP container would be tasked with generating dynamic contents and the HTTP server with serving static resources. Today servlet/JSP containers are considered mature
      and widely deployed without an HTTP server. Apache Tomcat and Jetty are the most popular servlet/JSP containers and are free and open-source. <br>
      - Servlet and JSP are two of a multitude of technologies defined in the Java Enterprise Edition (EE). Other Java EE technologies include Java Message Service (JMS),
      Enterprise JavaBeans (EJB), JavaServer Faces (JSF), and Java Persistence. The complete list of technologies in the Java EE version 6 (the current version) can be found
      <a href="https://www.oracle.com/java/technologies/java-ee-8.html">here</a>. <br>
      - To run a Java EE application, you need a Java EE container, such as GlassFish, JBoss, Oracle WebLogic, and IBM WebSphere. You can deploy a servlet/JSP application in a Java
      EE container, but a servlet/JSP container is sufficient and is more lightweight than a Java EE container. Tomcat and Jetty are not Java EE containers, so they cannot run EJB
      or JMS.
    </div>

    <div class="sub-heading">The Hypertext Transfer Protocol (HTTP)</div>
    <div>
      - The HTTP protocol enables web servers and browsers to exchange data over the Internet or an intranet. In HTTP, it is always the client that initiates a connection, a server
      is never in a position to contact a client. To locate a resource, an Internet user clicks a link that contains a Uniform Resource Locator (URL) or enter one in the Location
      box of the browser. For instance, this is a URL: <code>http://google.com/index.html</code>. The first part of the URLs is http, which identifies the protocol. Not all
      URLs use HTTP. For instance, these two URLs are valid even though they are not HTTP-based URLs: <code>mailto:joe@example.com</code>,
      <code>ftp://marketing@ftp.example.org</code>. <br>
      - In general, a URL has this format: <code>protocol://[host.]domain[:port][/context][/resource][?query string]</code> or
      <code>protocol://IP address[:port][/context][/resource][?query string]</code>. The parts in square brackets are optional. <br>
      - Both of these are valid URLs: http://yahoo.ca or http://192.168.1.9. You can find the IP address by doing <code>ping google.com</code>. For an IPv6 address, you need to
      wrap it inside a square bracket as <a href="https://superuser.com/a/367788">explained here</a>. Note that you need to have IPv6 working on your OS, and every device in the
      path to the destination (including proxy servers if you use one). <br>
      - Also note this <a href="https://superuser.com/questions/422689/attempting-to-access-site-by-ip-or-using-ssh-l-gives-server-404">as explained here</a>: An IP address is not
      necessarily unique to a specific Web site.
      For many years Web providers have been using the HTTP 1.1 Host header to distinguish web sites and serve multiple web sites from a single IP address. Your web browser sends a
      Host header to the Web server telling it the domain name of the site you requested, and the server responds with the correct page. If you give an IP address only, the server
      has no way to determine which site (among the possibly many behind the IP address) you want. In this situation some sites return a generic page, and some return an error code
      to the browser. <br>
      - The host part may be present and identify a totally different location on the Internet or an intranet. For instance, http://yahoo.com (no host) brings you to a different
      location than http://mail.yahoo.com (with a host). Over the years www has been the most popular host name and become the default. Normally, http://www.domainName is mapped to
      http://domainName. <br>
      - 80 is the default port of HTTP. Therefore, if a web server runs on port 80, you don't need the port number to reach the server. 443 is the default port for HTTPS.
      Sometimes, however, a web server doesn't run on port 80 and you need to type the port number. For example, Tomcat by default runs on port 8080, so you need to supply the port
      number: <code>http://localhost:8080</code>.
      <code>localhost</code> is a reserved name typically used to refer to the local computer, i.e. the same computer the web browser is running on. <br>
      - We also have absolute and relative URLs. In your browser's address bar, a URL doesn't have any context, so you must provide a full (or absolute) URL, like the ones we saw
      above. You don't need to include the protocol (the browser uses HTTP by default) or the port (which is only required when the targeted Web server is using some unusual port),
      but all the other parts of the URL are necessary. But when a URL is used within a document, such as in an HTML page, things are a bit different. Because the browser already
      has the document's own URL, it can use this information to fill in the missing parts of any URL available inside that document. We can differentiate between an absolute URL
      and a relative URL by looking only at the path part of the URL. If the path part of the URL starts with the <code> / </code> character, the browser will fetch that resource
      from the top root of the server, without reference to the context given by the current document. This is the most common use case for an absolute URL within an HTML document.
      The browser will use the same protocol and the same domain name as the one used to load the document hosting that URL. <a
      href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL#absolute_urls_vs_relative_urls">Look at examples here on MDN</a>. <br>
      - The context part in a URL refers to the application name, but this is also optional. A web server can run multiple contexts (applications) and one of them can be configured
      to be the default context. To request a resource in the default context, you skip the context part in a URL. A context can have one or more default resources (ordinarily
      index.html or index.htm or default.htm). A URL without a resource name is considered to identify a default resource. Of course, if more than one default resource exists in a
      context, the one with the highest priority will always be returned when a client does not specify a resource name. <br>
      - After a resource name comes one or more query string. A query string is a key/value pair that can be passed to the server to be processed.
    </div>


    <div class="sub-heading">HTTP Request</div>
    <div>
      - An HTTP request consists of three components: <br>
      a) Method-Uniform Resource Identifier (URI)-Protocol/Version <br>
      b) Request headers <br>
      c) Entity body <br>
      - This is what a sample HTTP request looks like:
      <div class="image-block">
        <div class="expand-screenshot-image-btn border border-primary rounded">
          <span class="btn btn-link">Show Image <img src="imgs/chevron-expand.svg" alt="Show Image Button"></span>
        </div>
        <div class="screenshot-image">
          <img src="imgs/BudiKurniawan/Chapter0/HTTP_Request.png"
               class="center-block img-fluid"
               width="500"
               alt="HTTP_Request">
        </div>
      </div>
      - The Method-Uniform Resource Identifier (URI)-Protocol/Version appears as the first line of the request. Here POST is the request method, /examples/default.jsp the URI, and
      HTTP/1.1 the Protocol/Version section. An HTTP request can use one of the many request methods specified in the HTTP standards. HTTP 1.1 supports seven request types: GET,
      POST, HEAD, OPTIONS, PUT, DELETE, and TRACE. The URI specifies an Internet resource. It is usually interpreted as being relative to the server’s root directory. Thus, it
      should always begin with a forward slash <code> / </code>. <br>
      - In an HTTP request, the request header contains useful information about the client environment and the entity body of the request. For instance, it may contain the
      language the browser is set for, the length of the entity body, and so on. Each header is separated by a carriage return/linefeed (CRLF) sequence. Between the headers and the
      entity body is a blank line (CRLF) that is important to the HTTP request format. The CRLF tells the HTTP server where the entity body begins. In some Internet programming
      books, this CRLF is considered the fourth component of an HTTP request. In the previous HTTP request, the entity body is simply the following line:
      <i>lastName=Blanks&firstName=Mike</i>
    </div>

    <div class="sub-heading">HTTP Response</div>
    <div>
      - Similar to an HTTP request, an HTTP response also consists of three parts: <br>
      a) Protocol-Status code-Description <br>
      b) Response headers <br>
      c) Entity body <br>
      <div class="image-block">
        <div class="expand-screenshot-image-btn border border-primary rounded">
          <span class="btn btn-link">Show Image <img src="imgs/chevron-expand.svg" alt="Show Image Button"></span>
        </div>
        <div class="screenshot-image">
          <img src="imgs/BudiKurniawan/Chapter0/HTTP_Response.png"
               class="center-block img-fluid"
               width="350"
               alt="HTTP_Request">
        </div>
      </div>

      - The first line of the response header is similar to the first line of the request header. It tells you that the protocol used is HTTP version 1.1, and that the request
      succeeded (200 is the success code). The response headers contain useful information similar to the headers in an HTTP request. The entity body of the response is the HTML
      content of the response itself. The headers and the entity body are separated by a sequence of CRLFs.


    </div>


  </div>


  <hr>
  <div id="BudiKurniawan_Chapter1" class="chapter">Chapter 1: Servlets</div>
  <hr>

  <div class="textual-content">
    <div class="sub-heading"></div>
    <div>

    </div>
  </div>

</div>

<script src="../../script.js"></script>
</body>
</html>
