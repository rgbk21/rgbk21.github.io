<!DOCTYPE html>
<html lang="en">
<head>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9QJ5D3X353"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'G-9QJ5D3X353');
    </script>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../../globalStyles.css">
    <meta name="author" content="Raj Gaurav Ballabh Kumar">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS Notes</title>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">

    <div class="navbar-header">
        <a href="../../index.html" class="navbar-brand"> rgbk21</a>
    </div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"><span
            class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="nav navbar-nav">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Projects/TwitterCritNodes/TwitterCritNodes_1.html">Identifying
                        Critical Nodes on Twitter</a>
                    <a class="dropdown-item" href="../../Projects/isRelatedTo/isRelatedTo.html">isRelatedTo</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    HTML Projects
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../ImageGallery/ImageGallery.html">Image Gallery</a>
                    <a class="dropdown-item" href="../../Pig_Game/index.html">Pig Game</a>
                    <a class="dropdown-item" href="../../RGB_Guesser_Game/RGB.html">RGB Guesser Game</a>
                    <a class="dropdown-item" href="../../ToDoList/todo.html">To-Do List</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Notes
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../COMS_631/COMS_631_index.html">COMS 631</a>
                    <a class="dropdown-item" href="../COMS_535/COMS_535_index.html">COMS 535</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    Code
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../Code/ThingsToRemember/ThingsToRemember.html">Things To
                        Remember</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes.html">Java Notes</a>
                    <a class="dropdown-item" href="../../Code/Java_Notes/JavaNotes_2.html">Java Notes 2</a>
                    <a class="dropdown-item" href="../../Code/Applying_Java_Notes/ApplyingJava_Notes.html">ApplyingJava
                        Notes</a>
                    <a class="dropdown-item" href="../../Code/JavaScript/JavaScript.html">JavaScript Notes</a>
                    <a class="dropdown-item" href="../../Code/SQL/SQL.html">SQL Notes</a>
                    <a class="dropdown-item" href="../../Code/Spring/Spring.html">Spring Notes</a>
                    <a class="dropdown-item" href="../../Code/Kafka/Kafka.html">Kafka Notes</a>
                    <a class="dropdown-item" href="../../Code/Angular/Angular.html">Angular</a>
                    <a class="dropdown-item" href="../../Code/Hibernate/Hibernate.html">Hibernate</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                   aria-expanded="false">
                    In Another Life
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="../../InAnotherLife/Chapter1.html">Chapter 1</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>

        </ul>


        <ul class="navbar-nav ml-auto">
            <li class="nav-item active"><a class="nav-link" href="https://github.com/rgbk21">GitHub</a></li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.linkedin.com/in/raj-gaurav-ballabh-kumar-97002058/">LinkedIn</a>
            </li>
            <li class="nav-item active"><a class="nav-link" href="https://www.instagram.com/wobblyframes/">Instagram</a>
            </li>
            <li class="nav-item active"><a class="nav-link"
                                           href="https://www.facebook.com/SomeRandomThoughts">Facebook</a></li>
        </ul>

    </div>
</nav>

<div class="container">

    <button id='load-all-gists' type="button" class="btn btn-outline-primary">Show all Gists!</button>

    <div>
        This page contains my notes from CORS in Action book by Monsur Hossain <br>
    </div>

    <br>
    Index:
    <br>
    Chapter 1: <a href="#Chapter1">The Core of CORS</a> <br>
    Chapter 2: <a href="#Chapter2">Making CORS Requests</a> <br>
    Chapter 3: <a href="#Chapter3">Handling CORS Requests</a> <br>
    Chapter 4: <a href="#Chapter4">Handling PreFlight Requests</a> <br>

    <hr>
    <div id="Chapter1" class="chapter">Chapter 1: The Core of CORS</div>
    <hr>

    <div class="textual-content">

        <div class="sub-heading">What is CORS</div>
        <div>
            - In CORS, the server-side component configures which types of cross-origin requests are allowed and the client-side component controls how cross-origin requests are
            made. <br>
            - Browsers have a <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#definition_of_an_origin">same-origin policy</a>, which means that a
            browser can only make requests to servers that have the same <i>origin</i>. CORS allows us to side-step this
            requirement by allowing cross-origin requests. This might seem antithetical, but the reasoning is that CORS puts the servers firmly in charge of who can make requests
            and what types of requests are allowed. This gives servers the choice to open up its API to all clients, open it up to a small number of clients, or prevent access to
            all clients. <br>
            - On a higher level, this is how the flow of CORS proceeds: <br>
            a) The CORS request is initiated by the JavaScript client code <br>
            b) The browser includes additional HTTP headers on the request before sending the request to the server <br>
            c) The server includes HTTP headers in the response that indicate whether the request is allowed <br>
            d) If the request is allowed, the browser sends the response to the client code <br>
            - If the headers returned by the server don't exist or aren't what the browser expects then the response is rejected and the client can't view the response.
        </div>

        <div class="sub-heading">Sending a CORS Request</div>
        <div>
            - Before we send a CORS request, we need to make sure that the browser actually supports a CORS request. This can be validated by checking the
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials"><code>XMLHttpRequest.withCredentials</code></a> property of the XHR object.
            <br>
            - The <code>XMLHttpRequest.withCredentials</code> property is a Boolean that indicates whether or not cross-site Access-Control requests should be made using
            credentials such as cookies, authorization headers or TLS client certificates. Setting <code>withCredentials</code> has no effect on same-site requests. <br>
            - In addition, this flag is also used to indicate when cookies are to be ignored in the response. The default is false. <br>
            - Note: <code>XMLHttpRequest</code> from a different domain cannot set cookie values for their own domain unless <code>withCredentials</code> is set to true before
            making the request regardless of Access-Control- header values. The third-party cookies obtained by setting <code>withCredentials</code> to true
            will still honor same-origin policy and hence can not be accessed by the requesting script through <code>document.cookie</code> or from response headers. <br>
            <img src="images/Ch1/HTTP_Request_Respone_Headers.png"
                 width="1200"
                 class="center-block img-fluid"
                 alt="Request_Response_CORS">
            - Note that in your Spring Code Controller setup, you cannot use <code> * </code> for <code>origins</code>, meaning this is an invalid use of the annotation:
            <code>@CrossOrigin(origins = "*", allowedHeaders = "*", allowCredentials = "true")</code> which produces the following error when you try to compile the Spring Code:
            java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value "*" since that cannot be set on the
            "Access-Control-Allow-Origin" response header. To allow credentials to a set of origins, list them explicitly or consider using "allowedOriginPatterns" instead. <br>
        </div>

        <div class="sub-heading">Why use CORS</div>
        <div>
            - CORS gives servers the flexibility to configure cross-origin access in a variety of ways. The server can specify various features: <br>
            a) Which domains are allowed to make requests <br>
            b) Which HTTP methods are allowed to make requests (eg. <code>GET/PUT/POST/DELETE</code>) <br>
            c) Which headers are allowed on the HTTP request <br>
            d) Whether or not requests may include cookie data <br>
            e) Which response headers the client can read
        </div>
    </div>

    <hr>
    <div id="Chapter2" class="chapter">Chapter 2: Making CORS Requests</div>
    <hr>

    <div class="textual-content">
        - A CORS request consists of two sides: the client making the request and the server receiving the request. On the client side, the developer writes the JS code to send the
        request to the server. The server responds to the request by setting CORS-specific headers to indicate that the cross-origin request is allowed. Without both the client's
        and the server's participation, the CORS request will fail.

        <div class="sub-heading">How to process a cross-origin request</div>
        <div>
            - There are 3 parts to making a HTTP request: <br>
            a) <p class="inline-heading">Set up the request parameters</p>: <br>
            - It starts by defining the HTTP method to use and the URL to which the request has to be sent to. In case of a cross-origin request, the full URL of the resource needs
            to be specified. There is no other special information required to delineate the request as a cross-origin request. The browser does the work of parsing the URL and
            determining if the request is a same-origin or a cross-origin request. <br>
            - If the browser supports CORS, then it's <code>XMLHttpRequest</code> is going to have a field named: <code>withCredentials</code>. You can check this on the browser by
            running <code>let xhr = new XMLHttpRequest(); xhr.withCredentials</code>. This should not print <code>undefined</code>. Ideally, it should be <code>false</code>, as
            specified in the documentation on MDN <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">here</a>. If you were going to make a
            CORS request, you would have to set it to <code>true</code> before sending the request. <br>
            - The <code>setRequestHeader</code> method lets you add HTTP headers to the request. This method includes the header request and the header value, and includes the
            header on the request. For example, this is how you would add a header named <i>X-Requested-With</i> to the request:
            <code>xhr.setRequestHeader('X-Requested-With', 'CORS In Action)</code> <br>
            - <p class="inline-heading">NOTE</p>: there are some headers that are set by the browser, that can't be set by the user. The browser sets a header named <i>Origin</i>
            on the cross-origin requests.
            If you try to override this header in your code, the browser will ignore your value. This is a security measure that helps prevent the user code from overriding trusted
            header values. The server can trust these values because it knows that the user hasn't accidentally (or maliciously) tainted the values of these headers. (If you could
            change the value of this header you could pretend to be from a domain that might not be allowed access to a certain API). <br>
            - There are several headers that cannot be set by a <code>setRequestHeader</code> method: Accept-Charset, Accept-Encoding, Access-Control-Request-Headers,
            Access-ControlRequest-Method, Connection, Content-Length, Cookie, Cookie2, Date, DNT, Expect, Host, Keep-Alive, Origin, Referer, TE, Trailer, Transfer-Encoding,
            Upgrade, User-Agent, Via, and any headers starting with 'Proxy-' or 'Sec-'. These headers have special meaning and can only be set by the browser. There is no
            error if the code tries to set the header. The value is just ignored. <br>
            - <p class="inline-heading">NOTE</p>: The server has to give its permission for the client to include custom request headers in a cross-origin request. This behavior is
            unique to a cross-origin
            request. Same-origin requests can include any custom headers in the request. But for a cross-origin request, if the server doesn't whitelist the request headers, the
            request WILL fail. <br>
            - Even after the request has been sent, there are a couple of ways to cancel the request. You can either call the <code>abort</code> method which will cause the
            currently executing request to be immediately cancelled. Another option is to set the <code>timeout</code> value in the request. This specifies the number of
            milliseconds a request can take before being forced to terminate. The default value is 0, which means there is no timeout. The request will continue till the server
            responds. <br>
            - The XHR request that is sent is an asynchronous request by default. <br>
            - This is a sample jQuery request that we are using:
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/2a18485409506d33ef2453d5901aa3ac.js"></script>
            </div>
            b) <p class="inline-heading">Send the request</p>: Nothing special to do here. When you call <code>$.ajax()</code>, it both initializes and sends the HTTP request. <br>
            c) <p class="inline-heading">Process the response</p>: The <code>getResponseHeader</code> and <code>getAllResponseHeaders</code> methods can be used to read the HTTP
            headers on the response.
            <code>getResponseHeader</code> returns the value of a given response header whereas <code>getAllResponseHeaders</code> returns all response headers as a single string.
            <br>
            - <p class="inline-heading">NOTE:</p>There is one caveat to reading response headers on a cross-origin request. By default, CORS only allows the client code to read the
            following response headers: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma <br>
            - If the <i>server</i> sets any additional response headers that are not in this list, the client won't be able to see them. But the server can also override this
            behavior by specifically indicating that these additional response headers should be visible to the client code. <br>
        </div>


        <div class="sub-heading">When will the <code>success</code> block be triggered vs when will the <code>error</code> block be triggered</div>
        <div>
            - HTTP responses have an associated status code. A successful response usually has a status code of 200, although any status code in the 200 range signals a success.
            Status codes in the 300 range signal that the request is being redirected, while status codes of 400 or above signal an error (the 400 range is reserved for client
            errors while the 500 range is reserved for server errors). <br>
            - Regardless of the underlying response status code, if the response makes it back to the browser, the onload event handler will fire. So although a request may fail
            due to a file not found (status code 404) or an internal server error (status code 500), the onload event handler will still fire. The below figure shows the
            relationship between the response and the response status code. <br>
            - If the request fails for some other reason, the onerror event handler will fire. These are errors where the server doesn't send a valid response to the browser, or
            the server doesn't support CORS.

            <img src="images/Ch2/HTTP_Error_Codes.PNG"
                 width="750"
                 class="center-block img-fluid"
                 alt="Http Error Codes">
            - But note that in jQuery the errors are set up differently. Anything other than a 2XX response code causes the <code>error</code> block to be executed.

            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/e8e6f0a159cd113c7cd75ae7ea7e8916.js"></script>
            </div>
            - And the errors that are logged on the console and the Network tab are as follows:

            <img src="images/Ch2/jQueryErrorCodes.png"
                 width="1500"
                 class="center-block img-fluid"
                 alt="jQuery Error Codes">
        </div>

        <div class="sub-heading">How can I include cookies on cross-origin requests</div>
        <div>
            - Websites can identify users through user credentials, a general term for any bit of information that can identify a user. The most popular form of user credentials is
            the cookie. Servers will use cookies to store a unique ID that identifies the user. The browser then includes this cookie on every request to the server. <br>
            - <p class="inline-heading">NOTE</p>: Same-origin HTTP requests will always contain the cookie in the request. In contrast, cross-origin requests don't include cookies
            by default. <br>
            - Cookies can be included on cross-origin requests by setting the <code>XMLHttpRequest</code>'s <code>withCredentials</code> property to true. Setting the <code>withCredentials</code>
            property to true indicates that user credentials such as cookies, basic authentication information, or clientside Secure Sockets Layer (SSL) certificates should be
            included on cross-origin requests. <br>
            - However, just setting the <code>withCredentials</code> property to true is not enough to complete the request. The server also has to indicate that it allows cookies
            for the request to succeed.
        </div>

        <div class="sub-heading">jQuery does not include the <code>X-Requested-With</code> header in the cross-origin requests</div>
        <div>
            - jQuery doesn't set the X-Requested-With request header on cross-origin requests. JQuery traditionally sets the X-Requested-With header on HTTP requests. <br>
            - This header is used by clients to indicate that a request is coming from an <code>XMLHttpRequest</code> object. The server receiving the request can look for the
            <code>XMLHttpRequest</code> header to determine where the request is coming from. JQuery always sets this header when making same-origin requests, but removes it from
            cross-origin requests. The reason is that setting custom request headers requires an additional server configuration step. Rather than force developers to make changes
            to their server, jQuery chose to drop this header. <br>
            - You can set this header manually in jQuery as follows:
            <div class="code-snippet">
                <script src="https://gist.github.com/rgbk21/8365c38ee1b25a7c3368da86b0b9a08d.js"></script>
            </div>
            - And you can see the header being sent in the request below. Note that on the server-side we are allowing ALL headers, and that is why we can see the CORS request
            being successful.
            <img src="images/Ch2/Additional_Headers.PNG"
                 width="1500"
                 class="center-block img-fluid"
                 alt="Additional Headers">
        </div>
    </div>


    <hr>
    <div id="Chapter3" class="chapter">Chapter 3: Handling CORS Requests</div>
    <hr>

    <div class="textual-content">

        - We will be starting from scratch. Commented out the <code>@CrossOrigin</code> annotation on the Controller.

        <div class="sub-heading">What error do we get when CORS is completely disabled on the server, and by disabled I just mean not enabled</div>
        <div>
            - When we try to send a cross-origin request, this is what we see in the console and the network tab:

            <img src="images/Ch3/No_CORS_Enabled.png"
                 width="1800"
                 class="center-block img-fluid"
                 alt="CORS is disabled">

            - Note that on the server side we do not see any error when the log level is set to <code>info</code>.
        </div>

        <div class="sub-heading">Key players in a CORS request</div>
        <div>
            - The key players in the CORS request are the client, the browser, and the server. The client wants some piece of data from the server, such as JSON API response or the
            contents of a web page. The browser acts as the trusted intermediary to verify that the client can access the data from the server. We will be looking at each of them
            one-by-one<br>
            - <p class="inline-heading">Client</p>: The client is a snippet of JS code running on a website that is responsible for initiating the CORS request. It's served from a
            particular domain and usually consists of an <code>XMLHttpRequest</code> to a remote server. <br>
            - <p class="inline-heading">Browser</p>: The client code runs inside a web browser. The browser acts as the trusted intermediary in this communication flow. It does two
            things: <br>
            a) The browser adds additional information to the request so that the server can identify the client <br>
            b) The browser interprets the server's response and decides whether to send the response to the client or to return an error. <br>
            If the browser didn't do these things, a client could send ANY request to the server, and the protection offered by the browser's same-origin policy could be broken. So
            the browser ensures that both the client and the server play by the rules of CORS. <br>
            - <p class="inline-heading">Server</p>: The server is the destination of the CORS request. It has the final say as to whether the CORS request is allowed or not.
        </div>

        <div class="sub-heading">Lifecycle of a CORS Request</div>
        <div>
            - An end-to-end CORS request looks something like this (note that the client code runs inside the browser, but we are separating that here in order to make the flow
            more obvious)
            <img src="images/Ch3/Lifecycle_Of_A_CORS_Request.PNG"
                 width="800"
                 class="center-block img-fluid"
                 alt="CORS is disabled">
            - The browser and the server talk to each other through HTTP headers. CORS includes many headers, but the two that are the most important are: <br>
            a) The <code>Origin</code> request header: This header is silently added to the request by the browser. You do not need to explicitly set it in the JS code. <br>
            b) The <code>Access-Control-Allow-Origin</code> response header <br>
            - Both these headers are mandatory on a successful CORS request.
        </div>

        <div class="sub-heading">What is an 'Origin'</div>
        <div>
            - The origin is everything in the URL up until the path. In more formal terms, the Origin is the <i>scheme</i>, <i>host</i>, and the <i>port</i> of the URL. <br>
            <img src="images/Ch3/Origin_Values_For_Example_URLS.PNG"
                 width="650"
                 class="center-block img-fluid"
                 alt="CORS is disabled">
            - The string <code>null</code> can also be a valid value for the origin, even though it doesn't follow the scheme/host/port pattern. Browsers use the value
            <code>null</code> when the origin of the client can't be determined. An example of this is opening an HTML file directly in your browser. <br>
            - Origin has nothing to do with HTTP requests/responses. It's only a property of a URL. Any URL can have an origin. When an origin refers to the client making the
            request, we call it the <i>client origin</i>. When an origin refers to the URL receiving the request, we call it the <i>server origin</i>. <br>
            - Servers use the origin to determine where a request is coming from. Browsers use the origin to define whether a request is same-origin or cross-origin, and exhibits
            different behavior for each. <br>
        </div>


        <div class="sub-heading">Same-Origin vs Cross-Origin Requests</div>
        <div>
            - A request is a same-origin request when the client origin and the server origin are exactly the same. Otherwise the request is a cross-origin request. <br>
            - When the client initiates the request, the browser extracts the server origin from the URL of the request. It then compares the server origin against the client
            origin to determine if the request is same-origin or cross-origin. Browsers allow clients to make same-origin requests without any restrictions. But if the request is
            cross-origin, the browser uses CORS to determine how to handle the request.
            <img src="images/Ch3/SameOrigin_vs_CrossOrigin_requests.PNG"
                 width="650"
                 class="center-block img-fluid"
                 alt="SameOrigin vs CrossOrigin Requests">
            - Note the last example carefully: the origin comparison only compares the string values of the scheme, host, and port, and knows nothing about what host an IP address
            maps to. In this example, "localhost" and "127.0.0.1" are different strings, and therefore the request isn't a same-origin request.
        </div>

        <div class="sub-heading">Sending the Cross-Origin request from Client: who sets the 'Origin' header</div>
        <div>
            - The browser is solely responsible for setting the Origin header. The Origin header is always present on cross-origin requests, and the client has no way of setting or
            overriding the value. <br>
            - Same-origin requests may sometimes have an Origin header as well. Chrome and Safari include an Origin header on same-origin non-GET requests. In these cases, the
            Origin header has the same value as the server's origin value. This is important to keep in mind. When identifying CORS requests, it's not enough to check that the
            Origin header exists. You should also check that the origin value is different from your server's origin value. <br>
        </div>

        <div class="sub-heading">Sending the Cross-Origin response from Server: setting the 'Access-Control-Allow-Origin' header</div>
        <div>
            - The server uses the Access-Control-Allow-Origin response header to approve the request. This header must be present on every successful CORS response. <br>
            - The value of the Access-Control-Allow-Origin header can be either a wildcard or an origin value. The wildcard value says that clients from any origin can access the
            resource, while the origin value only gives access to a specific client. <br>
            - The Access-Control-Allow-Origin header can have only a single origin value. You cannot specify multiple origins in the same header. If your server supports clients
            from different origins, the Access-Control-Allow-Origin header will have to contain only the origin for the specific client making the request. <br>
            - Access-Control-Allow-Origin doesn't allow Regular expressions either. <br>
            - But you can work around this by first getting the value of the Origin header from the
            request, then do a regex check with the value of the request Origin. If the request's origin passes the check with the allowed regex expression, then you can simply set
            the value of Access-Control-Allow-Origin to the value of the request's Origin. In this way, you aren't violating the rule of the access control being a strict url, but
            also allowing the server to accept multiple different allowed origins (<a href="https://stackoverflow.com/questions/18439340/using-a-regular-expression-with-cors">Source
            on SO</a>). <br>
            - <a href="https://stackoverflow.com/questions/14003332/access-control-allow-origin-wildcard-subdomains-ports-and-protocols">SO Link that contains many other linked
            questions</a>
        </div>
    </div>

    <hr>
    <div id="Chapter4" class="chapter">Chapter 4: Handling PreFlight Requests</div>
    <hr>

    <div class="textual-content">

        <div class="sub-heading">What is a preflight request</div>
        <div>
            - Certain types of requests, such as DELETE or PUT (if they are cross-origin), need to ask for the server's permission before actually making the cross-origin request.
            <br>
            - The browser asks for permissions by using what is called a <i>preflight request</i>. A preflight request is a small request that is sent by the browser before the
            actual request. It contains information like which HTTP method is used, as well as if any custom HTTP headers are present. The preflight gives the server a chance to
            examine what the actual request will look like before it's made. The server can then indicate whether the browser should send the actual request, or return an error to
            the client without sending the request. <br>
            - Hence the preflight isn't the request itself. Instead, it contains metadata about the request. The server inspects this metadata to decide whether the browser is
            allowed to send the request. Depending on that, the server sends it's response back to the browser. <br>
            - The browser uses the server's response to the preflight to determine if the request can be made. If the server grants the right permissions on the preflight response,
            the browser sends the actual request to the server. The server can also decide not to approve the preflight request, in which case the browser will return an error to
            the client, and the actual request will never be sent.
            <img src="images/Ch4/Lifecycle_of_a_CORS_request.PNG"
                 width="900"
                 class="center-block img-fluid"
                 alt="Lifecycle of a CORS request">
        </div>

        <div class="sub-heading">Why does the preflight request exist</div>
        <div>
            - The concept of a preflight was introduced to allow cross-origin requests to be made without breaking existing servers that depend on the browser’s same-origin policy.
            If the preflight hits a server that is CORS-enabled, the server knows what a preflight request is and can respond appropriately. But if the preflight hits a server that
            doesn't know or doesn't care about CORS, the server won't send the correct preflight response, and the actual request will never be sent. The preflight protects
            unsuspecting servers from receiving cross-origin requests they may not want. <br>
            - <a href="https://stackoverflow.com/questions/15381105/what-is-the-motivation-behind-the-introduction-of-preflight-cors-requests">Motivation behind introduction of
            preflight for CORS</a> on SO. <a href="https://stackoverflow.com/a/37040608/8742428">This answer</a> on the page is probably the one that explains it the best. <br>
            - The story is: There are probably APIs out there which rely on the browser's same-origin policy to protect their resources. They should have additional security, but
            they rely on the same-origin policy instead. Without the preflight, a user on a different domain could now issue a request to the API. The API would assume the request
            is valid (since it knows nothing of CORS) and execute the request. The browser could block the response from reaching the user, but at this point, the damage may
            already be done. If the request was a PUT/DELETE, the resource may have been updated or deleted.
        </div>

        <div class="sub-heading">When is a preflight request sent</div>
        <div>
            - The browser can make these kinds of cross-domain requests without having to use CORS: <br>
            a) A web page can easily make GET requests to another origin. Every <code>&lt;script&gt;</code> tag or <code>&lt;img&gt;</code> tag issues a GET request.
            <code>&lt;img src="http://example.com/image.jpg"&gt;</code> is an example of using HTML to make a GET request for an image. <br>
            b) A web page can make POST requests via the <code>&lt;form&gt;</code> tag. The <code>&lt;form&gt;</code> tag also allows the <code>Content-Type</code> header to be set
            to
            application/x-www-form-urlencoded, multipart/form-data, or text/plain. The below is an example of using HTML to make POST request with a Content-Type header<br>
            <code>&lt;form enctype="text/plain" method="post" action="http://example.com/form_submit" id="myform"&gt;</code> <br>
            <code>&lt;input type="submit" value="Submit" /&gt;</code> <br>
            <code>&lt;/form&gt;</code> <br>
            - Both of the above are cross-domain requests that are not blocked by the browser. Since the browser can already make these kinds of requests without CORS the preflight
            doesn't provide any additional value. For example, if there were a preflight on a GET request, the client could always use a script tag to get around the preflight. The
            browser skips the preflight in cases where the client can already make the cross-origin request through other means. <br>
            - Sidenote: You cannot open local resource (an image file that is on your local system) in chrome. For example, you cannot do this:
            <code>&lt;img src="file://C:\\MY_BACKUP\\YjRMt83.jpg" alt=""&gt;</code> (<a href="https://stackoverflow.com/a/49351590/8742428">Source on SO</a>) <br>
            - The question still remains: when IS a preflight used? A preflight is used when a request meets any of the following criteria: (<a
                href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests">Read on MDN</a>)<br>
            a) It uses an HTTP method other than GET, POST, or HEAD <br>
            b) It sets the Content-Type request header with values other than: 'application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain' <br>
            c) It sets additional request headers that are not: 'Accept', 'Accept-Language', 'Content-Language' <br>
            d) The <code>XMLHttpRequest</code> contains upload events <br>
            - The CORS spec collectively refers to these HTTP methods as <i>simple methods</i>, and the HTTP headers as <i>simple headers</i>. <br>
        </div>


        <div class="sub-heading">How do you identify that a request is a preflight request</div>
        <div>
            -
        </div>


    </div>


</div>

<script src="script.js"></script>
</body>
</html>
